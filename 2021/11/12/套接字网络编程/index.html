<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>套接字网络编程 | MyMind</title><meta name="keywords" content="博客"><meta name="author" content="XuSheng"><meta name="copyright" content="XuSheng"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="介绍TCP套接字网络编程 To Do">
<meta property="og:type" content="article">
<meta property="og:title" content="套接字网络编程">
<meta property="og:url" content="https://xushengim.github.io/2021/11/12/%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="MyMind">
<meta property="og:description" content="介绍TCP套接字网络编程 To Do">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://xushengim.github.io/img/code.png">
<meta property="article:published_time" content="2021-11-11T18:19:21.000Z">
<meta property="article:modified_time" content="2021-11-30T16:24:08.356Z">
<meta property="article:author" content="XuSheng">
<meta property="article:tag" content="博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://xushengim.github.io/img/code.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://xushengim.github.io/2021/11/12/%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="baidu-site-verification" content="code-kGUPdLRv7f"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '套接字网络编程',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2021-12-01 00:24:08'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/touxiang.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/code.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">MyMind</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">套接字网络编程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-11-11T18:19:21.000Z" title="发表于 2021-11-12 02:19:21">2021-11-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-11-30T16:24:08.356Z" title="更新于 2021-12-01 00:24:08">2021-12-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/">C++</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>35分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="套接字网络编程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>主要参考UNIX网络编程卷1: 套接字联网API(第三版)</p>
<h1 id="套接字对"><a href="#套接字对" class="headerlink" title="套接字对"></a>套接字对</h1><p>发送端的IP地址和端口号与目的端的IP地址和端口号，组成一个套接字对，对应唯一的一个TCP链接</p>
<p><img src="/2021/11/12/%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20211118171739791.png" alt="image-20211118171739791"></p>
<h1 id="套接字地址结构"><a href="#套接字地址结构" class="headerlink" title="套接字地址结构"></a>套接字地址结构</h1><h2 id="套接字地址结构-1"><a href="#套接字地址结构-1" class="headerlink" title="套接字地址结构"></a>套接字地址结构</h2><p>大多数套接字函数都需要一个指向套接字地址结构的指针作为参数。</p>
<p>每个协议族都定义它的套接字地址结构。这些结构的名字均以sockaddr_开头，并以对应每个协议族的唯一后缀结尾，如IPv4套接字地址结构struct sockaddr_in，IPv6套接字地址结构struct sockaddr_in6</p>
<h3 id="IPV4-sockaddr-in"><a href="#IPV4-sockaddr-in" class="headerlink" title="IPV4 sockaddr_in"></a>IPV4 sockaddr_in</h3><p>通常也被称为”网际套接字地址结构”，它以sockaddr_in命名，定义在&lt;netinet/in.h&gt;头文件中。</p>
<p><img src="/2021/11/12/%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20211118172548113.png" alt="image-20211118172548113"></p>
<p><img src="/2021/11/12/%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20211118172732549.png" alt="image-20211118172732549"></p>
<h3 id="传递套接字地址结构的函数"><a href="#传递套接字地址结构的函数" class="headerlink" title="传递套接字地址结构的函数"></a>传递套接字地址结构的函数</h3><h4 id="从进程传到内核"><a href="#从进程传到内核" class="headerlink" title="从进程传到内核"></a>从进程传到内核</h4><p>bind，connect，sendto</p>
<p><img src="/2021/11/12/%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20211118173036348.png" alt="image-20211118173036348"></p>
<h4 id="从内核传到进程"><a href="#从内核传到进程" class="headerlink" title="从内核传到进程"></a>从内核传到进程</h4><p>accept，recvfrom，getsockname，getpeername</p>
<p><img src="/2021/11/12/%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20211118173043752.png" alt="image-20211118173043752"></p>
<h3 id="字节排序函数"><a href="#字节排序函数" class="headerlink" title="字节排序函数"></a>字节排序函数</h3><p>网络字节序(network byte order)是大端字节序</p>
<h4 id="大端小端字节序"><a href="#大端小端字节序" class="headerlink" title="大端小端字节序"></a>大端小端字节序</h4><p>&emsp;&emsp;同时参考了博客<a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.cnblogs.com/folm/p/12004711.html">大端(Big Endian)/小端(Little Endian)字节序 - Folm - 博客园 (cnblogs.com)</a>。文章写得好，背景也养眼。</p>
<p>&emsp;&emsp;术语大端小端表示多个字节值(如int, long)的哪一端字节存储在虚拟主存中该值的起始地址。其中MSB表示most significant bit最高位，LSB表示least significant bit最低位。</p>
<p>&emsp;&emsp;注意！字节序是以字节为单位的，不要考虑单个字节的顺序。</p>
<p><img src="/2021/11/12/%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20211118173256919.png" alt="image-20211118173256919"></p>
<p>&emsp;&emsp;看一下虚拟机的字节序：程序中令int a=127，64位系统中，int是4字节。gdb二进制查看内存，4表示看4个字节，t表示以二进制显示，b表示间隔1字节。我们发现内存的低位存放低位，是小端字节序。对于一个字节的8位来讲，并不需要我们去考虑实际存放的顺序。</p>
<img src="/2021/11/12/%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20211119164701545.png" alt="image-20211119164701545" style="zoom:200%;">

<p>&emsp;&emsp;而网络字节序是大端字节序。int a=127按照主机的小端字节序，一个4字节大小的值在内存中(地址由低到高)依次为0x 8f 00 00 00。在TCP,IP协议看来，高位放在起始地址，这是127左移24位的大小。 </p>
<p>&emsp;&emsp;为了TCP,IP能正确认出我们填写的服务器ip地址和端口地址，需要将按主机字节序存放的多字节数值，转换成按网络字节序存放的多字节数值。</p>
<p>&emsp;然而对于网络间用write，read传递的值，强制转换成了const void* buf，所以全是单字节值，不需要考虑字节序。</p>
<h4 id="主机字节序和网络字节序的转换函数"><a href="#主机字节序和网络字节序的转换函数" class="headerlink" title="主机字节序和网络字节序的转换函数"></a>主机字节序和网络字节序的转换函数</h4><p>其中h表示host，n表示network，s表示short，l表示long</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">htons</span><span class="params">(<span class="keyword">uint16_t</span> host16bitvalue)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">htonl</span><span class="params">(<span class="keyword">uint32_t</span> host32bitvalue)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">ntohs</span><span class="params">(<span class="keyword">uint16_t</span> net16bitvalue)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">ntohl</span><span class="params">(<span class="keyword">uint32_t</span> net32bitvalue)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="字节操纵函数"><a href="#字节操纵函数" class="headerlink" title="字节操纵函数"></a>字节操纵函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bzero</span><span class="params">(<span class="keyword">void</span>* dest, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bcopy</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* src, <span class="keyword">void</span>* dest, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *ptr1, <span class="keyword">const</span> <span class="keyword">void</span>* ptr2, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br></pre></td></tr></table></figure>

<p>bzero把目标字节串中的指定数目的字节置为0；</p>
<p>bcopy把指定数目的字节从源字节串移到目标字节串；</p>
<p>bcmp比较两个任意字节串，相同返回0，不同返回非0.</p>
<h4 id="IPV4的地址转换函数"><a href="#IPV4的地址转换函数" class="headerlink" title="IPV4的地址转换函数"></a>IPV4的地址转换函数</h4><p>在ASCII字符串(点分十进制数串)与网络字节序的二进制值之间转换网际地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_aton</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* strptr, struct in_addr *addrptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">inet_ntoa</span><span class="params">(struct in_addr inaddr)</span></span>;</span><br></pre></td></tr></table></figure>

<p>inet_aton将strptr所指C字符串转换成一个32位的网络字节序二进制值，并通过指针addrptr来存储，成功返回1，否则返回0。</p>
<p>inet_ntoa将一个32位网络字节序的二进制IPv4地址转换成相应的点分十进制数串。</p>
<h1 id="基本套接字函数"><a href="#基本套接字函数" class="headerlink" title="基本套接字函数"></a>基本套接字函数</h1><img src="/2021/11/12/%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20211118175340842.png" alt="image-20211118175340842" style="zoom:150%;">

<h2 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h2><p>指定期望的通信协议类型，获得一个套接字描述符</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> family, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line"><span class="comment">//若成功则为非负描述符，若出错则为-1</span></span><br></pre></td></tr></table></figure>

<h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><p>把一个本地协议地址(IP地址和端口号)赋予一个套接字描述符</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *myaddr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"><span class="comment">//成功返回0，失败返回-1</span></span><br></pre></td></tr></table></figure>

<h2 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h2><p>TCP客户建立与TCP服务器的连接</p>
<p><img src="/2021/11/12/%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20211130105238429.png" alt="image-20211130105238429"></p>
<ol>
<li>服务器必须准备好接受外来的连接。这通常通过调用socket、bind和listen这3个函数来完成，我们称之为被动打开(passive open)。</li>
<li>客户通过调用connect发起主动打开(active open)。这导致客户TCP发送一个SYN(同步)分节，它告诉服务器客户将在(待建立的)连接中发送的数据的初始序列号。通常SYN分节不携带数据，其所在的IP数据报只含有一个IP首部、一个TCP首部及可能有的TCP选项。</li>
<li>服务器必须确认(ACK)客户的SYN,同时自己也得发送一个SYN分节，它还有服务器将在同一连接中发送的数据的初始序列号。服务器在单个分节中发送SYN和对客户SYN的ACK(确认)。</li>
<li>客户必须确认服务器的SYN。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr* servaddr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"><span class="comment">//成功返回0，出错返回-1</span></span><br></pre></td></tr></table></figure>

<p>激发三路握手，仅在连接建立成功或出错时才返回：SYN分节无响应，返回ETIMEDOUT错误；响应RST，返回ECONNREFUSED错误；ICMP不可达错误报文，返回EHOSTUNREACH或ENETUNREACH错误。</p>
<p>若connect失败则套接字不可再用，必须关闭并重新调用socket</p>
<h2 id="close"><a href="#close" class="headerlink" title="close"></a>close</h2><p>关闭一个套接字描述符</p>
<p><img src="/2021/11/12/%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20211130110745392.png" alt="image-20211130110745392"></p>
<ol>
<li>某个应用进程首先调用close，我们称该端执行主动关闭(active close)。该端的TCP于是发送一个FIN分节，表示数据发送完毕。</li>
<li>接收到这个FIN的对端执行被动关闭(passive close)。这个FIN由TCP确认。它的接收也作为一个文件结束符(end-of-file)传递给接收端应用进程(放在已排队等候该应用进程接收的任何其他数据之后)，因为FIN的接收意味着接收端应用进程在相应连接上再无额外数据可接收。</li>
<li>一段时间后，接收到这个文件结束符的应用进程将调用close关闭它的套接字。这导致它的TCP也发送一个FIN。</li>
<li>接收这个最终FIN的原发送端TCP(即执行主动关闭的那一端)确认这个FIN。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span>;</span><br><span class="line"><span class="comment">//成功返回0，出错返回-1</span></span><br></pre></td></tr></table></figure>

<h2 id="listen"><a href="#listen" class="headerlink" title="listen"></a>listen</h2><p>由TCP服务器调用，做两件事</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br><span class="line"><span class="comment">//成功返回0，失败返回-1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>listen函数指示内核应该接收指向该套接字描述符的连接请求。</li>
<li>backlog参数规定了内核应该为该套接字描述符排队的最大连接个数。</li>
</ul>
<p>监听套接字描述符的两个队列：</p>
<p><img src="/2021/11/12/%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20211118180647106.png" alt="image-20211118180647106"></p>
<p><img src="/2021/11/12/%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20211118180652448.png" alt="image-20211118180652448"></p>
<h2 id="accept"><a href="#accept" class="headerlink" title="accept"></a>accept</h2><p>由TCP服务器调用，用于从已完成连接队列队头取一个已完成连接。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr* cliaddr, <span class="keyword">socklen_t</span>* addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<p>内核为每个由服务器进程接受的客户连接创建一个已连接描述符。accept返回已连接描述符，填写客户的套接字地址。</p>
<h2 id="fork和exec"><a href="#fork和exec" class="headerlink" title="fork和exec"></a>fork和exec</h2><h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><p>fork函数是Unix中派生进程的唯一方法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">//返回：在子进程中为0，在父进程中为子进程ID,若出错则为-1</span></span><br></pre></td></tr></table></figure>

<p>子进程分享父进程调用fork之前打开的所有描述符，网络服务器利用这个特性让子进程分享已连接套接字，而父进程则关闭这个已连接套接字，子进程则关闭监听套接字。</p>
<h3 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h3><p>在fork创建新进程后可以调用exec把自身替换成新的程序</p>
<h3 id="典型的并发服务器程序轮廓"><a href="#典型的并发服务器程序轮廓" class="headerlink" title="典型的并发服务器程序轮廓"></a>典型的并发服务器程序轮廓</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line"><span class="keyword">int</span> listenfd, connfd;</span><br><span class="line">listenfd = socket( ... ); <span class="comment">//fill in sockaddr_in&#123;&#125; with server&#x27;s well-known port</span></span><br><span class="line">listen(listenfd, listenq);</span><br><span class="line"><span class="keyword">for</span> ( ; ; )&#123;</span><br><span class="line">    connfd = accept(listenfd, ... ); <span class="comment">//probably blocks</span></span><br><span class="line">    <span class="keyword">if</span> ( (pid = fork()) == <span class="number">0</span> )&#123;</span><br><span class="line">        close(listenfd);  <span class="comment">//child closes listening socket file descriptor</span></span><br><span class="line">        doit(connfd);  <span class="comment">//process the request</span></span><br><span class="line">        close(connfd);  <span class="comment">//done with this client</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//child terminates</span></span><br><span class="line">    &#125;</span><br><span class="line">    close(connfd);  <span class="comment">//parent closes connected socket fd, and continue listen</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="getsockname和getpeername"><a href="#getsockname和getpeername" class="headerlink" title="getsockname和getpeername"></a>getsockname和getpeername</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockname</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr* lockaddr, <span class="keyword">socklen_t</span>* addrlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getpeername</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr* peeraddr, <span class="keyword">socklen_t</span>* addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="getsockname返回本地协议地址"><a href="#getsockname返回本地协议地址" class="headerlink" title="getsockname返回本地协议地址"></a>getsockname返回本地协议地址</h3><p>在一个没有调用bind的TCP客户上，connect成功返回后，getsockname用于返回由内核赋予该连接的本地IP地址和本地端口号。</p>
<p>在以端口号0调用bind(告知内核去选择本地端口号)后，getsockname用于返回由内核赋予的本地端口号</p>
<p>getpeername返回外地协议地址</p>
<h3 id="getpeername返回外地协议地址"><a href="#getpeername返回外地协议地址" class="headerlink" title="getpeername返回外地协议地址"></a>getpeername返回外地协议地址</h3><p>服务器调用过accept后再调用fork时，外地套接字地址结构丢失，只能知道已连接套接字描述符，使用getpeername获取客户的套接字地址结构(IP地址和端口号)。</p>
<h1 id="简易Remote-Procedure-Call"><a href="#简易Remote-Procedure-Call" class="headerlink" title="简易Remote Procedure Call"></a>简易Remote Procedure Call</h1><p>阻塞式/非阻塞式/复用 读写，多进程，多线程的细节将在各个版本迭代中呈现。由于数据都很小，所以read，write一次就行。</p>
<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>编写一个简易RPC框架：YA-RPC，支持 At-least-once 语义。</p>
<p>使用YA-RPC编写一个demo程序，实现如下API：</p>
<p>1）远程调用 float sum(float a, float b)</p>
<p>2）远程调用 string uppercase(str)</p>
<p>3）不少于2个客户端，1个服务端 </p>
<h2 id="版本1-挨个服务，无读写，客户使用本地函数"><a href="#版本1-挨个服务，无读写，客户使用本地函数" class="headerlink" title="版本1 挨个服务，无读写，客户使用本地函数"></a>版本1 挨个服务，无读写，客户使用本地函数</h2><p>YA_RPC框架由YA_PRC.h和YA_RPC.c构成</p>
<p>YA_RPC.h包含所有需要的库文件和服务器参数。</p>
<h3 id="希望达到的效果"><a href="#希望达到的效果" class="headerlink" title="希望达到的效果"></a>希望达到的效果</h3><p>client.c，创建一个RPC_Client类的对象cli，调用cli提供的sum和uppercase方法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;YA_RPC.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	RPC_Client cli;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">float</span> a = <span class="number">1.1</span>;</span><br><span class="line">	<span class="keyword">float</span> b = <span class="number">2.2</span> ;</span><br><span class="line">	<span class="keyword">float</span> c = cli.sum(a, b);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;c=&quot;</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">string</span> s1 = <span class="string">&quot;it is a test&quot;</span>;</span><br><span class="line">	<span class="built_in">string</span> s2 = cli.uppercase(s1);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;s2=&quot;</span>&lt;&lt;s2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>server.c，创建一个RPC_Server类的对象srv，执行srv提供的Do方法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;YA_RPC.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	RPC_Server srv;</span><br><span class="line">	srv.Do();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="YA-RPC实现"><a href="#YA-RPC实现" class="headerlink" title="YA_RPC实现"></a>YA_RPC实现</h3><p>YA_RPC.h包含了所有库和宏，客户类和服务器类。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> YA_RPC</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> YA_RPC</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span> <span class="comment">//sockaddr</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;strings.h&gt;</span>	<span class="comment">//bzero</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span>	<span class="comment">//inet_aton</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span> <span class="comment">//socket</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span>	<span class="comment">//close</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span>	<span class="comment">//strerror</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVADDR <span class="meta-string">&quot;192.168.1.103&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVPORT 9999</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LISTENQ 20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RPC_Client</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	RPC_Client();</span><br><span class="line">	~RPC_Client();</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">float</span> <span class="title">sum</span><span class="params">(<span class="keyword">float</span> a, <span class="keyword">float</span> b)</span></span>;</span><br><span class="line">	<span class="function"><span class="built_in">string</span> <span class="title">uppercase</span><span class="params">(<span class="built_in">string</span> s1)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span>	<span class="comment">//server&#x27;s sockaddr</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span>	<span class="comment">//client&#x27;s sockaddr  </span></span><br><span class="line">	<span class="keyword">socklen_t</span> clisocklen = <span class="keyword">sizeof</span>(client_addr);	<span class="comment">//clent&#x27;s sockaddr length</span></span><br><span class="line">	<span class="keyword">int</span> sockfd;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RPC_Server</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	RPC_Server();</span><br><span class="line">	~RPC_Server();</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Do</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span>	<span class="comment">//server&#x27;s sockaddr</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span>	<span class="comment">//client&#x27;s sockaddr  </span></span><br><span class="line">	<span class="keyword">socklen_t</span> clisocklen = <span class="keyword">sizeof</span>(client_addr);	<span class="comment">//clent&#x27;s sockaddr length</span></span><br><span class="line">	<span class="keyword">int</span> listenfd, connfd;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>YA_RPC.c给出了客户类和服务器类的具体实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;YA_RPC.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Client</span></span><br><span class="line">RPC_Client::RPC_Client()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// user fill in server&#x27;s information (struct sockaddr_in) </span></span><br><span class="line">	bzero(&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">	server_addr.sin_family = AF_INET;</span><br><span class="line">	server_addr.sin_port = htons(SERVPORT);</span><br><span class="line">	inet_aton(SERVADDR, &amp;(server_addr.sin_addr));</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//create sockfd</span></span><br><span class="line">	<span class="keyword">int</span> sockfd;</span><br><span class="line">	<span class="keyword">if</span>( (sockfd=socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) == <span class="number">-1</span> )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Socket Error:&quot;</span>&lt;&lt; strerror(errno)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//connect</span></span><br><span class="line">	connect(sockfd, (struct sockaddr*)(&amp;server_addr), <span class="keyword">sizeof</span>(struct sockaddr));</span><br><span class="line">	<span class="comment">//print client&#x27;s sockaddr information</span></span><br><span class="line">	getsockname(sockfd, (struct sockaddr*)&amp;client_addr, &amp;clisocklen);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;connect success! &quot;</span>&lt;&lt;<span class="string">&quot;server&#x27;s ip: &quot;</span>&lt;&lt;inet_ntoa(client_addr.sin_addr)&lt;&lt;<span class="string">&quot; port: &quot;</span>&lt;&lt;ntohs(client_addr.sin_port)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RPC_Client::~RPC_Client()</span><br><span class="line">&#123;</span><br><span class="line">	close(sockfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">RPC_Client::sum</span><span class="params">(<span class="keyword">float</span> a, <span class="keyword">float</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">float</span> c = a+b;</span><br><span class="line">	<span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">RPC_Client::uppercase</span><span class="params">(<span class="built_in">string</span> s1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	transform(s1.begin(), s1.end(), s1.begin(), ::<span class="built_in">toupper</span>);</span><br><span class="line">	<span class="keyword">return</span> s1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Server</span></span><br><span class="line">RPC_Server::RPC_Server()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//create a socket</span></span><br><span class="line">	listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">  	</span><br><span class="line">  	<span class="comment">//fill in server&#x27;s sockaddr information</span></span><br><span class="line">	bzero(&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">	server_addr.sin_family = AF_INET;</span><br><span class="line">	inet_aton(SERVADDR,&amp;(server_addr.sin_addr)); <span class="comment">//ip</span></span><br><span class="line">	server_addr.sin_port = htons(SERVPORT); <span class="comment">//port</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//bind server&#x27;s sockaddr with socket</span></span><br><span class="line">	bind(listenfd,(sockaddr *)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//change the socket as listen socket</span></span><br><span class="line">	listen(listenfd, LISTENQ); <span class="comment">//LISTENQ sets number of 2 listen array (connecting and conneted);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RPC_Server::Do</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//accept and do</span></span><br><span class="line">	<span class="keyword">for</span>( ; ; )&#123;	</span><br><span class="line">		connfd = accept(listenfd,(sockaddr*)&amp;client_addr, &amp;clisocklen);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;client&#x27;s ip: &quot;</span>&lt;&lt;inet_ntoa(client_addr.sin_addr)&lt;&lt;<span class="string">&quot; port: &quot;</span>&lt;&lt;ntohs(client_addr.sin_port)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">//here we wait user to close the tcp link</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RPC_Server::~RPC_Server()</span><br><span class="line">&#123;</span><br><span class="line">	close(listenfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="版本2-挨个服务，阻塞式读写，客户接收服务器的结果"><a href="#版本2-挨个服务，阻塞式读写，客户接收服务器的结果" class="headerlink" title="版本2 挨个服务，阻塞式读写，客户接收服务器的结果"></a>版本2 挨个服务，阻塞式读写，客户接收服务器的结果</h2><p>修改YA_RPC.c中客户类的sum和uppercase方法，修改服务器类的Do方法，新增sum和uppercase方法。</p>
<p>后面的版本客户都是接收服务器返回的结果了。</p>
<h3 id="套接字的发送缓冲区"><a href="#套接字的发送缓冲区" class="headerlink" title="套接字的发送缓冲区"></a>套接字的发送缓冲区</h3><p>&emsp;&emsp;每一个socket都有一个发送缓冲区，当某个应用进程写数据到一个套接字中时，内核从该应用进程的缓冲区(这里用虚拟主存感觉比缓冲区要好)中复制所有数据到所写套接字的发送缓冲区。如果该套接字的发送缓冲区容不下该应用进程的所有数据(或是应用进程的缓冲区大于套接字的发送缓冲区，或是套接字的发送缓冲区中已有其他数据)，该应用程序将被投入睡眠。</p>
<p>&emsp;&emsp;可以用SO_SNDBUF套接字选项来更改缓冲区大小。MSS (Maximum Segment Szie)最大报文大小是网络层报文的最大字节数，MTU(Maximum Ttransmission Unit)最大传输单位是链路层帧的最大字节数。</p>
<p><img src="/2021/11/12/%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20211119142148537.png" alt="image-20211119142148537"></p>
<p>&emsp;&emsp;这一端的TCP提取套接字发送缓冲区中的数据把它发送给对端TCP。对端TCP必须确认收到的数据，伴随来自对打的ACK不断到达，本段TCP才能从套接字发送缓冲区丢弃已确认的数据。TCP必须为已发送的数据保留一个副本，直到它被对端确认为止。</p>
<p>&emsp;&emsp;每个套接字一个的发送缓冲区中的数据经过TCP,IP协议的处理，变成一个一个的分组传到数据链路的输出队列，如果队列已满，新到的分组将被丢弃，并沿着协议栈向上返回一个错误。TCP将注意到这个错误，并在以后某个时刻重传相应的分节。应用进程并不知道这种暂时的情况。</p>
<h3 id="套接字的接收缓冲区"><a href="#套接字的接收缓冲区" class="headerlink" title="套接字的接收缓冲区"></a>套接字的接收缓冲区</h3><p>&emsp;&emsp;相应的，每一个套接字除了有一个发送缓冲区，还有一个接收缓冲区。对端发来的数据会被缓存入套接字的接收缓冲区，应用进程一直没有读取的话，此数据会一直缓存在相应socket的接收缓冲区内。</p>
<h3 id="阻塞式写接收缓冲区"><a href="#阻塞式写接收缓冲区" class="headerlink" title="阻塞式写接收缓冲区"></a>阻塞式写接收缓冲区</h3><p>&emsp;&emsp;write不一定写入你希望它写的字节数，因为发送缓冲区可能不够，成功时它返回实际写入的字节数；</p>
<p>&emsp;&emsp;如果失败返回-1，错误码放入errno(在errno.h中定义)中；具体错误和对应的errno如下：</p>
<ul>
<li>阻塞时被中断，进程被信号唤醒，由内核态返回用户态。（The call was interrupted by a signal before any data was written），errno为EINTR</li>
</ul>
<p>&emsp;&emsp;缓冲区满时阻塞。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>;</span><br><span class="line"> </span><br><span class="line">如果顺利write()会返回实际写入的字节数。当有错误发生时则返回<span class="number">-1</span>，错误代码存入errno中。</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;为了尽可能一次写n个字节，构造writen函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">writen</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span>* vptr, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> nleft;	<span class="comment">//left bytes to write</span></span><br><span class="line">    <span class="keyword">ssize_t</span> nwritten;	<span class="comment">//bytes have written</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* ptr;</span><br><span class="line">    </span><br><span class="line">    ptr = vptr;</span><br><span class="line">    nleft = n;</span><br><span class="line">    <span class="keyword">while</span> (nleft&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    	  <span class="keyword">if</span>( ( nwritten = write(fd, ptr, nleft) ) &lt;= <span class="number">0</span> )&#123;</span><br><span class="line">              <span class="keyword">if</span>(nwritten&lt;<span class="number">0</span> &amp;&amp; errno==EINTR)</span><br><span class="line">                  nwritten = <span class="number">0</span>;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          nleft -= nwritten;</span><br><span class="line">          ptr += nwritten;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="阻塞式读接收缓冲区"><a href="#阻塞式读接收缓冲区" class="headerlink" title="阻塞式读接收缓冲区"></a>阻塞式读接收缓冲区</h3><p>&emsp;&emsp;read不一定读取你希望它读的字节数，因为数据可能没有全部赋值到接收缓冲区中，成功时它返回实际读取的字节数；</p>
<p>&emsp;&emsp;如果失败返回-1并设置errno；</p>
<p>&emsp;&emsp;接收缓冲区空时阻塞。</p>
<p>&emsp;&emsp;如果返回0，表示链接关闭。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>;</span><br><span class="line"> </span><br><span class="line">成功返回读取的字节数，出错返回<span class="number">-1</span>并设置errno，如果在调read之前已到达文件末尾，则这次read返回<span class="number">0</span>。</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;为了尽可能读n个字节，构造readn函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">readn</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span>* vptr, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> nleft;	<span class="comment">//left bytes to read</span></span><br><span class="line">    <span class="keyword">ssize_t</span> nread;	<span class="comment">//bytes have read</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* ptr;</span><br><span class="line">    </span><br><span class="line">    ptr = vptr;</span><br><span class="line">    nleft = n;</span><br><span class="line">    <span class="keyword">while</span> (nleft&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>( ( nread = read(fd, ptr, nleft) ) &lt; <span class="number">0</span> )&#123;</span><br><span class="line">              <span class="keyword">if</span>(errno==EINTR)</span><br><span class="line">                  nread = <span class="number">0</span>;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>)</span><br><span class="line">              <span class="keyword">break</span>;	<span class="comment">/*EOF*/</span></span><br><span class="line">          nleft -= nread;</span><br><span class="line">          ptr += nread;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (n-nleft);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;从一个套接字接收缓冲区中读文本行，一次1字节</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">readline</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span>* vptr, <span class="keyword">size_t</span> maxlen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">ssize_t</span> n, readnum;</span><br><span class="line">    <span class="keyword">char</span> c, *ptr;</span><br><span class="line">    </span><br><span class="line">    ptr = vptr;</span><br><span class="line">    <span class="keyword">for</span> (n=<span class="number">1</span>; n&lt;maxlen; n++)&#123;</span><br><span class="line">        again:</span><br><span class="line">        <span class="keyword">if</span>( (readnum = read(fd, &amp;c, <span class="number">1</span>)) == <span class="number">1</span> )&#123;</span><br><span class="line">            *ptr++ = c;	<span class="comment">/* equals ptr=c ptr+=1 */</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span>;	<span class="comment">/*new line is stored*/</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (readnum == <span class="number">0</span>)&#123;</span><br><span class="line">            *ptr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> (n<span class="number">-1</span>);	<span class="comment">/* EOF, n-1 bytes were read*/</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">                <span class="keyword">goto</span> again;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;	<span class="comment">/* error */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *ptr = <span class="number">0</span>;	<span class="comment">/* null terminate */</span></span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;每读一字节就调用一次系统的read函数，PAINFULLY SLOW!(极端痛苦的慢)。我们可以一次读很多字节到应用进程的缓存，再挨个读缓存中的字节，就这样改写readline。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> read_cnt;	<span class="comment">//bytes in readbuf</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span>* read_ptr;	<span class="comment">//address of readbuf</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> readbuf[MAXLINE];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">my_read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span>* ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (read_cnt &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        again:</span><br><span class="line">        <span class="keyword">if</span> ( (read_cnt = read(fd, read_buf, <span class="keyword">sizeof</span>(read_buf))) &lt; <span class="number">0</span> )&#123;	<span class="comment">//try to read read_buf bytes</span></span><br><span class="line">            <span class="keyword">if</span>(errno == EINTR)	<span class="comment">/* interrupt */</span></span><br><span class="line">                <span class="keyword">goto</span> again;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(read_cnt == <span class="number">0</span>)	<span class="comment">/* EOF */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        read_ptr = read_buf;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    read_cnt--;</span><br><span class="line">    *ptr = *read_ptr++;	<span class="comment">//return char to c and readptr+=1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">readline</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span>* vptr, <span class="keyword">size_t</span> maxlen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">ssize_t</span> n, readnum;</span><br><span class="line">    <span class="keyword">char</span> c, *ptr;</span><br><span class="line">    </span><br><span class="line">    ptr = vptr;</span><br><span class="line">    <span class="keyword">for</span> (n=<span class="number">1</span>; n&lt;maxlen; n++)&#123;</span><br><span class="line">        again:</span><br><span class="line">        <span class="keyword">if</span>( (readnum = my_read(fd, &amp;c)) == <span class="number">1</span> )&#123;</span><br><span class="line">            *ptr++ = c;	<span class="comment">/* equals ptr=c ptr+=1 */</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span>;	<span class="comment">/*new line is stored*/</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (readnum == <span class="number">0</span>)&#123;</span><br><span class="line">            *ptr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> (n<span class="number">-1</span>);	<span class="comment">/* EOF, n-1 bytes were read*/</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;	<span class="comment">/* error */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *ptr = <span class="number">0</span>;	<span class="comment">/* null terminate */</span></span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">readlinebuf</span><span class="params">(<span class="keyword">void</span>** vptrptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (read_cnt)</span><br><span class="line">        *vptrptr = read_ptr;</span><br><span class="line">    <span class="keyword">return</span> read_cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;my_read每次最多读MAXLINE个字符，然后每次返回一个字符。readlinebuf函数可以展示应用进程虚拟主存中的缓冲区是什么状态(还剩多少字符，剩余字符的起始位置)，便于调用者查看当前文本行之后是否收到了新的数据。</p>
<h3 id="改写版本1至版本2时，出现的bug"><a href="#改写版本1至版本2时，出现的bug" class="headerlink" title="改写版本1至版本2时，出现的bug"></a>改写版本1至版本2时，出现的bug</h3><h4 id="1-sockfd没用类的成员变量，用了局部变量"><a href="#1-sockfd没用类的成员变量，用了局部变量" class="headerlink" title="1. sockfd没用类的成员变量，用了局部变量"></a>1. sockfd没用类的成员变量，用了局部变量</h4><p>&emsp;&emsp;DEBUG半天，发现自己在客户类的构造函数中用了局部变量sockfd，而没用类的成员变量sockfd，导致退出构造函数后，sockfd的值3丢失，变成了1。我还纳闷为什么我write东西给服务器，本地却显示一些奇怪的字符呢。原来套接字描述符变了。我在茫然地debug2个小时候，gdb打印sockfd发现是0。实在是印象深刻。</p>
<p><img src="/2021/11/12/%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20211119194223391.png" alt="image-20211119194223391"></p>
<p><img src="/2021/11/12/%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20211119194311326.png" alt="image-20211119194311326"></p>
<h4 id="2-char-s-”it-is-a-test”是常量，地址不可访问，故不可修改"><a href="#2-char-s-”it-is-a-test”是常量，地址不可访问，故不可修改" class="headerlink" title="2. char* s=”it is a test”是常量，地址不可访问，故不可修改"></a>2. char* s=”it is a test”是常量，地址不可访问，故不可修改</h4><p>&emsp;&emsp;用char s[] = “it is a test”就可以了。或者在客户端的uppercase函数里再申请一个新数组，就不麻烦用户了。</p>
<h3 id="版本2的具体实现"><a href="#版本2的具体实现" class="headerlink" title="版本2的具体实现"></a>版本2的具体实现</h3><h3 id="RPC-Server-Do监听客户想调用什么函数"><a href="#RPC-Server-Do监听客户想调用什么函数" class="headerlink" title="RPC_Server::Do监听客户想调用什么函数"></a>RPC_Server::Do监听客户想调用什么函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RPC_Server::Do</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> require; <span class="comment">// 1-sum; 2-uppercase</span></span><br><span class="line">	<span class="comment">//accept and do</span></span><br><span class="line">	<span class="keyword">for</span>( ; ; )&#123;	</span><br><span class="line">		connfd = accept(listenfd,(sockaddr*)&amp;client_addr, &amp;clisocklen);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;client&#x27;s ip: &quot;</span>&lt;&lt;inet_ntoa(client_addr.sin_addr)&lt;&lt;<span class="string">&quot; port: &quot;</span>&lt;&lt;ntohs(client_addr.sin_port)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>( ; ; )&#123;<span class="comment">//read the require</span></span><br><span class="line">			<span class="keyword">ssize_t</span> r;</span><br><span class="line">			<span class="keyword">if</span> ( ( r = read(connfd, &amp;require, <span class="keyword">sizeof</span>(<span class="keyword">char</span>))) &lt;= <span class="number">0</span> )&#123;</span><br><span class="line">				<span class="keyword">break</span>;	<span class="comment">//link terminate</span></span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">if</span>( require == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">					<span class="keyword">this</span>-&gt;sum();</span><br><span class="line">				&#125;<span class="keyword">else</span> <span class="keyword">if</span>( require == <span class="string">&#x27;2&#x27;</span>)&#123;</span><br><span class="line">					<span class="keyword">this</span>-&gt;uppercase();</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;require error!&quot;</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//wait user close the tcp link</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="服务器和客户端的sum"><a href="#服务器和客户端的sum" class="headerlink" title="服务器和客户端的sum"></a>服务器和客户端的sum</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RPC_Server::sum</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="keyword">float</span> a, b;</span><br><span class="line">	read(connfd, &amp;a, <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">	read(connfd, &amp;b, <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">	<span class="keyword">float</span> c = a+b;</span><br><span class="line">    write(connfd, &amp;c, <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">RPC_Client::sum</span><span class="params">(<span class="keyword">float</span> a, <span class="keyword">float</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> require = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">	<span class="keyword">float</span> c;</span><br><span class="line">	write(sockfd, &amp;require, <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">	write(sockfd, &amp;a, <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">	write(sockfd, &amp;b, <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">	read(sockfd, &amp;c, <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">	<span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="服务器和客户端的uppercase"><a href="#服务器和客户端的uppercase" class="headerlink" title="服务器和客户端的uppercase"></a>服务器和客户端的uppercase</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RPC_Server::uppercase</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> size;</span><br><span class="line">    read(connfd, &amp;size, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">char</span>* s = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(size); <span class="comment">//require mem</span></span><br><span class="line">	read(connfd, s, size);</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size<span class="number">-1</span>; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(s[i]&gt;=<span class="string">&#x27;a&#x27;</span> &amp;&amp; s[i]&lt;=<span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">			s[i] += (<span class="string">&#x27;A&#x27;</span>-<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	write(connfd, s, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">RPC_Client::uppercase</span><span class="params">(<span class="keyword">char</span>* s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> require = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">	write(sockfd, &amp;require, <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">	<span class="keyword">int</span> size = <span class="built_in">strlen</span>(s) + <span class="number">1</span>;	<span class="comment">//contain &#x27;\0&#x27;</span></span><br><span class="line">	write(sockfd, &amp;size, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">	write(sockfd, s, size);</span><br><span class="line">	<span class="keyword">char</span>* s1 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(size);</span><br><span class="line">	read(sockfd, s1, size);</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">return</span> s1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="版本3-多进程服务，阻塞式读写"><a href="#版本3-多进程服务，阻塞式读写" class="headerlink" title="版本3 多进程服务，阻塞式读写"></a>版本3 多进程服务，阻塞式读写</h2><h3 id="把要写的内容放在一起"><a href="#把要写的内容放在一起" class="headerlink" title="把要写的内容放在一起"></a>把要写的内容放在一起</h3><p>&emsp;&emsp;客户类的sum函数先后调用系统write三次发送请求标志和两个参数，可以把它们放到一个结构体中中，仅调用一次write。服务器类在Do函数中读一次请求标志选择执行的函数，在sum函数中读出2个剩余的float。由于uppercase函数传递长度未知的字符串，所以仍然需要先读size，再在堆上申请一块空间来存放字符串。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SumData</span>&#123;</span></span><br><span class="line">	<span class="keyword">char</span> require;</span><br><span class="line">	<span class="keyword">float</span> a;</span><br><span class="line">	<span class="keyword">float</span> b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">RPC_Client::sum</span><span class="params">(<span class="keyword">float</span> a, <span class="keyword">float</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">SumData</span> <span class="title">sumdata</span>;</span></span><br><span class="line">	sumdata.require = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">	sumdata.a = a;</span><br><span class="line">	sumdata.b = b; </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">float</span> c;</span><br><span class="line">	write(sockfd, &amp;sumdata, <span class="keyword">sizeof</span>(sumdata));</span><br><span class="line">	read(sockfd, &amp;c, <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">	<span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RPC_Server::sum</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">SumData</span> <span class="title">sumdata</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">SumData</span>* <span class="title">p</span> =</span> &amp;sumdata;</span><br><span class="line">	(connfd, (<span class="keyword">char</span>*)p+<span class="number">1</span>, <span class="keyword">sizeof</span>(sumdata)<span class="number">-1</span>);	<span class="comment">//char require has read by Do()</span></span><br><span class="line">	<span class="keyword">float</span> c = sumdata.a+sumdata.b;</span><br><span class="line">	write(connfd, &amp;c, <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="fork-1"><a href="#fork-1" class="headerlink" title="fork"></a>fork</h3><p>服务器改写Do函数：子进程分享父进程调用fork之前打开的所有描述符，网络服务器利用这个特性让子进程分享已连接套接字，而父进程则关闭这个已连接套接字，子进程则关闭监听套接字。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RPC_Server::Do</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pid_t</span> childpid;</span><br><span class="line">	<span class="keyword">char</span> require; <span class="comment">// 1-sum; 2-uppercase</span></span><br><span class="line">	<span class="comment">//accept and do</span></span><br><span class="line">	<span class="keyword">for</span>( ; ; )&#123;	</span><br><span class="line">		connfd = accept(listenfd,(sockaddr*)&amp;client_addr, &amp;clisocklen);</span><br><span class="line">		<span class="keyword">if</span>( (childpid = fork()) == <span class="number">0</span> )&#123;</span><br><span class="line">			close(listenfd); <span class="comment">/* child closes listen socketfd */</span></span><br><span class="line">			<span class="comment">//read the require</span></span><br><span class="line">			<span class="keyword">for</span>( ; ; )&#123;</span><br><span class="line">				<span class="keyword">if</span> ( ( read(connfd, &amp;require, <span class="keyword">sizeof</span>(<span class="keyword">char</span>))) &lt;= <span class="number">0</span> )&#123;</span><br><span class="line">					<span class="keyword">break</span>;	<span class="comment">//link terminate</span></span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					<span class="keyword">if</span>( require == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">						<span class="keyword">this</span>-&gt;sum();</span><br><span class="line">					&#125;<span class="keyword">else</span> <span class="keyword">if</span>( require == <span class="string">&#x27;2&#x27;</span>)&#123;</span><br><span class="line">						<span class="keyword">this</span>-&gt;uppercase();</span><br><span class="line">					&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">						<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;require error!&quot;</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span>;	</span><br><span class="line">		&#125;</span><br><span class="line">		close(connfd); <span class="comment">/* parent closes connected socketfd */</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端也改成多进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;YA_RPC.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=<span class="number">100</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;int process &quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot; :&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">pid_t</span> childpid;</span><br><span class="line">		<span class="keyword">if</span>( (childpid = fork()) == <span class="number">0</span> )</span><br><span class="line">		&#123;</span><br><span class="line">			RPC_Client cli;</span><br><span class="line">	</span><br><span class="line">			<span class="keyword">float</span> a = <span class="number">1.1</span>;</span><br><span class="line">			<span class="keyword">float</span> b = <span class="number">2.2</span> ;</span><br><span class="line">			<span class="keyword">float</span> c = cli.sum(a, b);</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;c=&quot;</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">char</span>* s1 = <span class="string">&quot;it is a test&quot;</span>;</span><br><span class="line">			<span class="keyword">char</span>* s2 = cli.uppercase(s1);</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;s2=&quot;</span>&lt;&lt;s2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="版本4-多线程服务，阻塞式读写"><a href="#版本4-多线程服务，阻塞式读写" class="headerlink" title="版本4 多线程服务，阻塞式读写"></a>版本4 多线程服务，阻塞式读写</h2><h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3><p>fork是昂贵的，线程的创建比进程快10-100倍，线程间通信也更容易。</p>
<p>线程共享：全局变量，进程指令，大多数数据，打开的文件(即描述符)，信号处理函数和信号处置，当前工作目录，用户ID和组ID。</p>
<p>线程独有：线程ID，寄存器集合包括程序计数器和栈指针，栈(用于存放局部变量和返回地址)，errno，信号掩码，优先级。</p>
<p>现在在主线程中accept已连接套接字，创建线程服务该已连接套接字</p>
<h3 id="线程的创建和终止"><a href="#线程的创建和终止" class="headerlink" title="线程的创建和终止"></a>线程的创建和终止</h3><h4 id="pthread-create创建一个线程"><a href="#pthread-create创建一个线程" class="headerlink" title="pthread_create创建一个线程"></a>pthread_create创建一个线程</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span> *tid, <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">void</span> *(*func)(<span class="keyword">void</span> *), <span class="keyword">void</span> *arg)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>pthread_t *tid：一个进程内的每个线程都由线程ID标识，数据类型是pthread_t(往往是unsigned int)。如果新的线程成功创建，其ID就通过tid指针返回。</li>
<li>pthread_attr_t *attr：每个线程有许多属性：优先级、初始栈大小、是否该成为一个守护线程，等等。可以在创建线程时初始化一个取代默认设置的pthread_attr_t变量指定这些属性。空指针即采纳默认设置</li>
<li>void* (*func)(void *)，void *arg：func所指函数作为参数接受一个通用指针(void *),又作为返回值返回一个通用指针(void *)。该函数的唯一调用参数是指针arg，如果我们需要给该函数传递多个参数，我们就得把它们打包成一个结构。</li>
<li>返回值：成功返回0，出错返回某个非0值，与套接字函数及大多数系统调用出错时返回-1并设置errno为某个正直的做法不同的是：Pthread函数出错时作为函数返回值返回正值错误指示。Pthread函数不设置errno</li>
</ul>
<h4 id="pthread-join等待某个线程终止"><a href="#pthread-join等待某个线程终止" class="headerlink" title="pthread_join等待某个线程终止"></a>pthread_join等待某个线程终止</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> *tid, <span class="keyword">void</span> **status)</span></span>;</span><br></pre></td></tr></table></figure>

<p>如果status指针非空，来自所等待线程的返回值(一个指向某个对象的指针)将存入由status指向的位置。</p>
<h4 id="pthread-self获取自身线程ID"><a href="#pthread-self获取自身线程ID" class="headerlink" title="pthread_self获取自身线程ID"></a>pthread_self获取自身线程ID</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pthread_t</span> <span class="title">pthread_self</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br></pre></td></tr></table></figure>

<h4 id="pthread-detach将指定线程变成脱离状态"><a href="#pthread-detach将指定线程变成脱离状态" class="headerlink" title="pthread_detach将指定线程变成脱离状态"></a>pthread_detach将指定线程变成脱离状态</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="keyword">pthread_t</span> tid)</span></span>;</span><br></pre></td></tr></table></figure>

<p>一个线程是可汇合的(joinable,默认值)，或者是脱离的(detached)。当一个可汇合的线程终止时，它的线程ID和退出状态将留存到另一个线程对它调用pthread_join。脱离的线程却像守护进程，当它们终止时，所有相关资源都被释放。本函数通常由想让自己脱离的线程调用，就如该语句pthread_detach(pthread_self());</p>
<h4 id="pthread-exit退出线程"><a href="#pthread-exit退出线程" class="headerlink" title="pthread_exit退出线程"></a>pthread_exit退出线程</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span> *status)</span></span>;</span><br></pre></td></tr></table></figure>

<p>如果线程未曾脱离，它的线程ID和退出状态将一直留存到调用进程内的某个其他线程对它调用pthread_join。指针status不能指向局部于调用线程的对象，因为线程终止时这样的对象也消失。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>客户类没有变动，服务器类发生改变</p>
<p>Do函数现在为每一个accept的已连接套接字创建一个线程，传递套接字去执行doit函数。</p>
<p>考虑到线程切换引起的内核态和用户态的切换，可能导致系统调用中断，所以用版本2中提到的相对可靠的readn和writen取代read和write。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RPC_Server::Do</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//accept and create thread to handle</span></span><br><span class="line">	<span class="keyword">for</span>( ; ; )&#123;	</span><br><span class="line">		connfd = accept(listenfd,(sockaddr*)&amp;client_addr, &amp;clisocklen);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;client&#x27;s ip: &quot;</span>&lt;&lt;inet_ntoa(client_addr.sin_addr)&lt;&lt;<span class="string">&quot; port: &quot;</span>&lt;&lt;ntohs(client_addr.sin_port)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">pthread_t</span> tid;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;new connfd is &quot;</span>&lt;&lt;connfd&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		pthread_create(&amp;tid, <span class="literal">NULL</span>, &amp;doit, (<span class="keyword">void</span>*) connfd);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">RPC_Server::doit</span><span class="params">(<span class="keyword">void</span>* connfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> tconnfd = (<span class="keyword">int</span>)connfd;</span><br><span class="line">	pthread_detach(pthread_self());</span><br><span class="line">	<span class="keyword">ssize_t</span> r;</span><br><span class="line">	<span class="keyword">char</span> require;</span><br><span class="line">	<span class="keyword">for</span>( ; ; )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> ( ( r = readn(tconnfd, &amp;require, <span class="keyword">sizeof</span>(<span class="keyword">char</span>))) &lt;= <span class="number">0</span> )&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;pthread_self()&lt;&lt;<span class="string">&quot; doit connfd &quot;</span>&lt;&lt;tconnfd&lt;&lt;<span class="string">&quot; r=&quot;</span>&lt;&lt;r&lt;&lt;<span class="string">&quot;,require=&quot;</span>&lt;&lt;require&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">if</span>( require == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">				sum(tconnfd);</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>( require == <span class="string">&#x27;2&#x27;</span>)&#123;</span><br><span class="line">				uppercase(tconnfd);</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;pthread_self()&lt;&lt;<span class="string">&quot; doit connfd &quot;</span>&lt;&lt;tconnfd&lt;&lt;<span class="string">&quot; require error!&quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	close(tconnfd); <span class="comment">/* done with connected socket */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将服务器类的sum和uppercase成员函数改成static函数，因为只传递了connfd给线程(原因见下面的错误3)，为了让线程在没有服务器类对象的this指针的情况下，可以调用该对象的方法，才将sum和uppercase成员函数改成static函数。</p>
<h3 id="犯的错误"><a href="#犯的错误" class="headerlink" title="犯的错误"></a>犯的错误</h3><ol>
<li>在服务器每个线程执行的doit函数中，没有for循环监听客户的require，导致服务完一个函数sum后，链接关闭，不再服务uppercase</li>
<li>每个线程都根据客户的require字节调用sum或uppercase函数处理之后客户传来的参数，在sum和uppercase中用的是成员变量connfd，多进程中，每个进程都有一个不同的connfd并没有问题，然而多线程中，线程共用一个connfd，就会出错，需要给sum和uppercase传递已连接套接字描述符作为参数。</li>
<li>仅仅观察三个线程，发现第三个线程和第二个线程的文件描述符相同。原因是我传参给线程的时候，传递了地址，因为void*只能传8字节的数据或者地址。而我想传递connfd和对象指针，传递connfd是为了区分链接，传递对象指针是为了调用sum和uppercase，看来只能用键或者不传递this指针了，我选择不传this。这个错误最为致命，我打印了所有的线程id和connfd才看出问题来。</li>
</ol>
<h2 id="版本5-线程池服务，阻塞式读写"><a href="#版本5-线程池服务，阻塞式读写" class="headerlink" title="版本5 线程池服务，阻塞式读写"></a>版本5 线程池服务，阻塞式读写</h2><p>网络编程卷1：联网套接字API中，第三十章客户/服务器程序设计范式中给出的图：</p>
<p><img src="/2021/11/12/%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20211129221657131.png" alt="image-20211129221657131"></p>
<p>每个线程各自accept取listen套接字维护的的队列中的已连接套接字，进行服务，不停重复这一过程。或者由主线程统一accept再分配给线程进行服务。</p>
<p>前者比后者更快，所以让每个线程各自accept。每个线程中用互斥锁保护一个accept函数，因为如果使用无锁版本，可能同时有多个accept函数阻塞，当listenfd监听套接字的已连接套接字队列中有已连接套接字时，还要内核花时间决定分给哪个accept，花费一些用户时间来决定哪个accept接收已连接套接字将节省更多内核时间。</p>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p> 在YA_PRC.h文件中增加NTHREADS宏为线程数量，线程数组(线程池)的组成结构，其中包含线程ID和已服务链接的计数器，在YA_RPC.h中的Server类中加一个线程数组指针和互斥锁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NTHREADS 20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">pthread_t</span> thread_tid;	<span class="comment">/* thread ID */</span></span><br><span class="line">    <span class="keyword">long</span> thread_count;	<span class="comment">/* # connections handled */</span></span><br><span class="line">&#125; Thread;</span><br><span class="line"></span><br><span class="line">Thread *tptr;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mlock;</span><br></pre></td></tr></table></figure>

<p>在Do中初始化互斥锁，初始化NTHREADS个线程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_mutex_t</span> mlock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line">tptr = Calloc(NTHREADS, <span class="keyword">sizeof</span>(Thread));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;NTHREADS; i++)</span><br><span class="line">&#123;</span><br><span class="line">    pthread_create(&amp;tptr[i].thread_tid, <span class="literal">NULL</span>, &amp;doit, (<span class="keyword">void</span>*)i);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>每个线程执行的doit函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_lock(&amp;mlock);</span><br><span class="line">connfd = Accept(listennfd, cliaddr, &amp;clilen)</span><br><span class="line">pthread_mutex_unlock(&amp;mlock);</span><br><span class="line">tptr[(<span class="keyword">int</span>) arg].thread_count++;</span><br></pre></td></tr></table></figure>

<h3 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h3><p> error: invalid use of member ‘RPC_Server::listenfd’ in static member function。在doit静态函数中使用了成员变量，因为doit函数是void* func (void*)类型的函数，所以它没有对象指针this。这次我们没传connfd而是传递了Thread结构在线程数组中的位置，因为connfd线程自己accept，不用从主线程中传参进来了，而为了给每个线程的服务链接计数，要传递i，即Thread结构在线程池中的位置。</p>
<p>所以我先尝试把listenfd和tptr改成静态成员变量。由于静态的意图是只在一个源文件中生效，会导致链接器报undefend reference问题，所以直接改成全局变量。结果由于YA_RPC.c和server.c都应用了YA_RPC.h导致编译生成的两个.o文件都有全局变量，链接器报错multiple definition。所以我把listenfd，tptr和mlock都扔到YA_RPC.c中了。另一种解决办法是在.h中使用extern关键字声明全局变量，在YA_RPC.c中定义这些全局变量。</p>
<h2 id="版本6-IO复用之epoll监听事件与非阻塞式读写"><a href="#版本6-IO复用之epoll监听事件与非阻塞式读写" class="headerlink" title="版本6 IO复用之epoll监听事件与非阻塞式读写"></a>版本6 IO复用之epoll监听事件与非阻塞式读写</h2><h3 id="非阻塞套接字"><a href="#非阻塞套接字" class="headerlink" title="非阻塞套接字"></a>非阻塞套接字</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将套接字设置为非阻塞模式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setnonblock</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> flags;</span><br><span class="line">  flags = fcntl(fd, F_GETFL);</span><br><span class="line">  flags |= O_NONBLOCK;</span><br><span class="line">  fcntl(fd, F_SETFL, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>套接字的默认状态是阻塞的。这就意味着当发出一个不能立即完成的套接字调用时，其进程将被投入睡眠，等待相应操作的完成。</p>
<h4 id="输入操作"><a href="#输入操作" class="headerlink" title="输入操作"></a>输入操作</h4><ul>
<li>包括read，readv，recv，recvfrom和recvmsg共5个函数。</li>
<li>阻塞条件：该套接字阻塞，接收缓冲区中没有数据可读</li>
<li>唤醒条件：TCP是字节流协议，只要有一些数据到达，这些数据既可能是单个字节，也可以是一个完整的TCP分节中的数据。如果想等到某个固定数目的数据可读为止，那么可以调用我们的readn函数，或指定MSG_WAITALL标志。</li>
<li>非阻塞：如果输入操作不能被满足(对于TCP套接字即至少有一个字节的数据可读，对于UDP套接字即有一个完整的数据报可读)，相应调用将立即返回一个EWOULDBLOCK错误。</li>
</ul>
<h4 id="输出操作"><a href="#输出操作" class="headerlink" title="输出操作"></a>输出操作</h4><ul>
<li>包括write、writev、send、sendto和sendmsg共5个函数</li>
<li>阻塞条件：如果其发送缓冲区中没有空间，进程将被投入睡眠，直到有空间为止。</li>
<li>唤醒条件：发送缓冲区有空间</li>
<li>非阻塞：如果其发送缓冲区中没有空间，输出函数调用将立即返回一个EWOULDBLOCK错误。如果其发送缓冲区中有一些空间，返回值将是能够复制到该缓冲区中的字节数(不足计数 short count)</li>
</ul>
<h4 id="接收外来链接"><a href="#接收外来链接" class="headerlink" title="接收外来链接"></a>接收外来链接</h4><p>对于一个阻塞的套接字调用accept函数，并且尚无新的连接到达，accept调用将立即返回一个EWOULDBLOCK错误。</p>
<h4 id="发起外出链接"><a href="#发起外出链接" class="headerlink" title="发起外出链接"></a>发起外出链接</h4><p>connect函数一直要等到客户收到对于自己的SYN的ACK为止才返回。这意味着TCP的每个connect总会阻塞其调用进程至少一个服务器的RTT时间。</p>
<p>如果对于一个非阻塞的TCP套接字调用connect，并且连接不能立即建立，那么连接的建立能照样发起，不过会返回一个EINPROGRESS错误。(立即建立的连接通常发生在服务器和客户处于同一个主机的情况下)</p>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>可以监听建立连接、读、写事件。</p>
<h4 id="epoll-create，创建一个epoll句柄"><a href="#epoll-create，创建一个epoll句柄" class="headerlink" title="epoll_create，创建一个epoll句柄"></a>epoll_create，创建一个epoll句柄</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"><span class="comment">//返回值为一个文件描述符</span></span><br></pre></td></tr></table></figure>

<p>size为最大可监听的描述符个数</p>
<h4 id="epoll-ctl，注册要监听的描述符和事件"><a href="#epoll-ctl，注册要监听的描述符和事件" class="headerlink" title="epoll_ctl，注册要监听的描述符和事件"></a>epoll_ctl，注册要监听的描述符和事件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>int epfd：是epoll_create()的返回值</li>
<li>int op：EPOLL_CTL_ADD，注册新的fd到epfd中；EPOLL_CTL_MOD，修改已经注册的fd的监听事件；EPOLL_CTL_DEL，从epfd中删除一个fd。</li>
<li>int fd：需要监听的描述符</li>
<li>struct epoll_event *event</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span>&#123;</span></span><br><span class="line">  <span class="keyword">void</span> *ptr;</span><br><span class="line">  <span class="keyword">int</span> fd;</span><br><span class="line">  <span class="keyword">__uint32_t</span> u32;</span><br><span class="line">  <span class="keyword">__uint64_t</span> u64;</span><br><span class="line">&#125;<span class="keyword">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span>&#123;</span></span><br><span class="line">  <span class="keyword">__uint32_t</span> events; <span class="comment">/*Epoll events*/</span></span><br><span class="line">  <span class="keyword">epoll_data_t</span> data; <span class="comment">/*User data variable*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>events代表事件：EPOLLIN表示对应的文件描述符可读(包括对端socket正常关闭)；EPOLLOUT表示对应的文件描述符可以写；EPOLLPRI表示对应的文件描述符有紧急的数据可读(带外数据)；EPOLLERR表示对应的文件描述符发生错误；EPOLLHUP表示对应的文件描述符被挂断；EPOLLET将EPOLL设为边缘触发(Edge Triggered)，处理完事件后才会再收到事件</p>
<h4 id="epoll-wait"><a href="#epoll-wait" class="headerlink" title="epoll_wait"></a>epoll_wait</h4><p>events里存储所有读写事件，函数返回需要处理的事件数目，如返回0表示已超时</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>int epfd：epfd为epoll_create()创建的描述符</li>
<li>struct epoll_event *events：从内核得到事件的集合</li>
<li>int maxevents：返回描述符事件的最大数目</li>
<li>int timeout：超时时间，0立刻返回，-1一直等下去</li>
</ul>
<h3 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h3><p>epoll监听建立链接，读，写事件并分别处理，可能会出现读到EOF，链接关闭， 然而还有一些本该处理的写事件没处理完</p>
<p>close把描述符的引用计数减1，仅在该计数变为0时才关闭套接字。使用shutdown可以不管引用计数就激发TCP的正常连接终止序列。</p>
<p>close终止读和写两个方向的数据传递。shutdown可以关闭一半TCP链接。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#inlcude <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> howto)</span></span>;</span><br></pre></td></tr></table></figure>

<p>该函数的行为依赖于howto参数的值。</p>
<ul>
<li>SHUT_RD：关闭链接的读一半——套接字中不再有数据可接收，而且套接字接收缓冲区中的现有数据都被丢弃。进程不能再对这样的套接字调用任何读函数。对一个TCP套接字这样调用shutdown函数后，由该套接字接收的来自对端的任何数据都被确认，然后丢弃。</li>
<li>SHUT_WR：关闭链接的写一半——当前留在套接字发送缓冲区中的数据将被发送掉，后跟TCP的正常连接中止序列。进程不能再对这样的套接字调用任何写函数。</li>
</ul>
<p>然而在本次实现中，客户端通过客户类，在构造函数中建立连接，完成所有任务后在析构函数中关闭连接，所以不用使用shutdown，只使用close就好。</p>
<h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><p>首先创建一个epoll实例</p>
<p>注册listenfd和EPOLLIN，监听建立链接的事件，如果有已建立的链接，服务器accept然后注册connfd和读事件到epoll中。</p>
<p>循环接收已发生的事件，如果有某已链接套接字的可读事件，就读该套接字，如果链接结束就删除，如果要写，就注册该套接字的写事件到epoll中。</p>
<p>如果有某已链接套接字的可写事件，就写该套接字。</p>
<p>在服务器类的构造函数中，创建epoll实例并注册listenfd的EPOLLIN事件，以accept链接。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//create epoll</span></span><br><span class="line">epfd = epoll_create(MAXFDS);	</span><br><span class="line"></span><br><span class="line"><span class="comment">//regit listenfd and accept event</span></span><br><span class="line">ev.data.fd = listenfd;</span><br><span class="line">ev.events = EPOLLIN;</span><br><span class="line">epoll_ctl(epfd, EPOLL_CTL_ADD, listenfd, &amp;ev);</span><br></pre></td></tr></table></figure>

<p>在Do中循环接收监听到的事件</p>
<p>此时发现，epoll监听注册的套接字的读写事件，将读写分离开来，没有连续地处理客户请求。比较复杂。所以咕咕咕。</p>
<p>目前就实现到线程池。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined" rel="external nofollow noreferrer">XuSheng</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://xushengim.github.io/2021/11/12/%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">https://xushengim.github.io/2021/11/12/%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://xushengim.github.io" target="_blank">MyMind</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/code.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/11/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E6%95%B0%E5%80%BC/"><img class="prev-cover" src="/img/code.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">计算机中的数值</div></div></a></div><div class="next-post pull-right"><a href="/2021/11/10/%E5%A6%82%E4%BD%95%E7%94%A8%E7%94%B5%E5%AD%98%E5%82%A8%E5%92%8C%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE/"><img class="next-cover" src="/img/electricity.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">如何用电存储和传输数据</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC81NDYzNS8zMTEwNg=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">XuSheng</div><div class="author-info__description">九层之台起于垒土,从垒土开始,认识真实的世界</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/xushengim" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:xushengim@163.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A5%97%E6%8E%A5%E5%AD%97%E5%AF%B9"><span class="toc-number">1.</span> <span class="toc-text">套接字对</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A5%97%E6%8E%A5%E5%AD%97%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">套接字地址结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A5%97%E6%8E%A5%E5%AD%97%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84-1"><span class="toc-number">2.1.</span> <span class="toc-text">套接字地址结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IPV4-sockaddr-in"><span class="toc-number">2.1.1.</span> <span class="toc-text">IPV4 sockaddr_in</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E9%80%92%E5%A5%97%E6%8E%A5%E5%AD%97%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.2.</span> <span class="toc-text">传递套接字地址结构的函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E8%BF%9B%E7%A8%8B%E4%BC%A0%E5%88%B0%E5%86%85%E6%A0%B8"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">从进程传到内核</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E5%86%85%E6%A0%B8%E4%BC%A0%E5%88%B0%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.1.2.2.</span> <span class="toc-text">从内核传到进程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E6%8E%92%E5%BA%8F%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.3.</span> <span class="toc-text">字节排序函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF%E5%AD%97%E8%8A%82%E5%BA%8F"><span class="toc-number">2.1.3.1.</span> <span class="toc-text">大端小端字节序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E6%9C%BA%E5%AD%97%E8%8A%82%E5%BA%8F%E5%92%8C%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F%E7%9A%84%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.3.2.</span> <span class="toc-text">主机字节序和网络字节序的转换函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E6%93%8D%E7%BA%B5%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.3.3.</span> <span class="toc-text">字节操纵函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IPV4%E7%9A%84%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.3.4.</span> <span class="toc-text">IPV4的地址转换函数</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%A5%97%E6%8E%A5%E5%AD%97%E5%87%BD%E6%95%B0"><span class="toc-number">3.</span> <span class="toc-text">基本套接字函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#socket"><span class="toc-number">3.1.</span> <span class="toc-text">socket</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bind"><span class="toc-number">3.2.</span> <span class="toc-text">bind</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#connect"><span class="toc-number">3.3.</span> <span class="toc-text">connect</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#close"><span class="toc-number">3.4.</span> <span class="toc-text">close</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#listen"><span class="toc-number">3.5.</span> <span class="toc-text">listen</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#accept"><span class="toc-number">3.6.</span> <span class="toc-text">accept</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fork%E5%92%8Cexec"><span class="toc-number">3.7.</span> <span class="toc-text">fork和exec</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#fork"><span class="toc-number">3.7.1.</span> <span class="toc-text">fork</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#exec"><span class="toc-number">3.7.2.</span> <span class="toc-text">exec</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E8%BD%AE%E5%BB%93"><span class="toc-number">3.7.3.</span> <span class="toc-text">典型的并发服务器程序轮廓</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#getsockname%E5%92%8Cgetpeername"><span class="toc-number">3.8.</span> <span class="toc-text">getsockname和getpeername</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#getsockname%E8%BF%94%E5%9B%9E%E6%9C%AC%E5%9C%B0%E5%8D%8F%E8%AE%AE%E5%9C%B0%E5%9D%80"><span class="toc-number">3.8.1.</span> <span class="toc-text">getsockname返回本地协议地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getpeername%E8%BF%94%E5%9B%9E%E5%A4%96%E5%9C%B0%E5%8D%8F%E8%AE%AE%E5%9C%B0%E5%9D%80"><span class="toc-number">3.8.2.</span> <span class="toc-text">getpeername返回外地协议地址</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E6%98%93Remote-Procedure-Call"><span class="toc-number">4.</span> <span class="toc-text">简易Remote Procedure Call</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9C%80%E6%B1%82"><span class="toc-number">4.1.</span> <span class="toc-text">需求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%88%E6%9C%AC1-%E6%8C%A8%E4%B8%AA%E6%9C%8D%E5%8A%A1%EF%BC%8C%E6%97%A0%E8%AF%BB%E5%86%99%EF%BC%8C%E5%AE%A2%E6%88%B7%E4%BD%BF%E7%94%A8%E6%9C%AC%E5%9C%B0%E5%87%BD%E6%95%B0"><span class="toc-number">4.2.</span> <span class="toc-text">版本1 挨个服务，无读写，客户使用本地函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%8C%E6%9C%9B%E8%BE%BE%E5%88%B0%E7%9A%84%E6%95%88%E6%9E%9C"><span class="toc-number">4.2.1.</span> <span class="toc-text">希望达到的效果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#YA-RPC%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.2.2.</span> <span class="toc-text">YA_RPC实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%88%E6%9C%AC2-%E6%8C%A8%E4%B8%AA%E6%9C%8D%E5%8A%A1%EF%BC%8C%E9%98%BB%E5%A1%9E%E5%BC%8F%E8%AF%BB%E5%86%99%EF%BC%8C%E5%AE%A2%E6%88%B7%E6%8E%A5%E6%94%B6%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E7%BB%93%E6%9E%9C"><span class="toc-number">4.3.</span> <span class="toc-text">版本2 挨个服务，阻塞式读写，客户接收服务器的结果</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%97%E6%8E%A5%E5%AD%97%E7%9A%84%E5%8F%91%E9%80%81%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">4.3.1.</span> <span class="toc-text">套接字的发送缓冲区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%97%E6%8E%A5%E5%AD%97%E7%9A%84%E6%8E%A5%E6%94%B6%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">4.3.2.</span> <span class="toc-text">套接字的接收缓冲区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E5%BC%8F%E5%86%99%E6%8E%A5%E6%94%B6%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">4.3.3.</span> <span class="toc-text">阻塞式写接收缓冲区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E5%BC%8F%E8%AF%BB%E6%8E%A5%E6%94%B6%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">4.3.4.</span> <span class="toc-text">阻塞式读接收缓冲区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%B9%E5%86%99%E7%89%88%E6%9C%AC1%E8%87%B3%E7%89%88%E6%9C%AC2%E6%97%B6%EF%BC%8C%E5%87%BA%E7%8E%B0%E7%9A%84bug"><span class="toc-number">4.3.5.</span> <span class="toc-text">改写版本1至版本2时，出现的bug</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-sockfd%E6%B2%A1%E7%94%A8%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%EF%BC%8C%E7%94%A8%E4%BA%86%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">4.3.5.1.</span> <span class="toc-text">1. sockfd没用类的成员变量，用了局部变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-char-s-%E2%80%9Dit-is-a-test%E2%80%9D%E6%98%AF%E5%B8%B8%E9%87%8F%EF%BC%8C%E5%9C%B0%E5%9D%80%E4%B8%8D%E5%8F%AF%E8%AE%BF%E9%97%AE%EF%BC%8C%E6%95%85%E4%B8%8D%E5%8F%AF%E4%BF%AE%E6%94%B9"><span class="toc-number">4.3.5.2.</span> <span class="toc-text">2. char* s&#x3D;”it is a test”是常量，地址不可访问，故不可修改</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%88%E6%9C%AC2%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.3.6.</span> <span class="toc-text">版本2的具体实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RPC-Server-Do%E7%9B%91%E5%90%AC%E5%AE%A2%E6%88%B7%E6%83%B3%E8%B0%83%E7%94%A8%E4%BB%80%E4%B9%88%E5%87%BD%E6%95%B0"><span class="toc-number">4.3.7.</span> <span class="toc-text">RPC_Server::Do监听客户想调用什么函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84sum"><span class="toc-number">4.3.8.</span> <span class="toc-text">服务器和客户端的sum</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84uppercase"><span class="toc-number">4.3.9.</span> <span class="toc-text">服务器和客户端的uppercase</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%88%E6%9C%AC3-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%9C%8D%E5%8A%A1%EF%BC%8C%E9%98%BB%E5%A1%9E%E5%BC%8F%E8%AF%BB%E5%86%99"><span class="toc-number">4.4.</span> <span class="toc-text">版本3 多进程服务，阻塞式读写</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%8A%E8%A6%81%E5%86%99%E7%9A%84%E5%86%85%E5%AE%B9%E6%94%BE%E5%9C%A8%E4%B8%80%E8%B5%B7"><span class="toc-number">4.4.1.</span> <span class="toc-text">把要写的内容放在一起</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fork-1"><span class="toc-number">4.4.2.</span> <span class="toc-text">fork</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%88%E6%9C%AC4-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%8D%E5%8A%A1%EF%BC%8C%E9%98%BB%E5%A1%9E%E5%BC%8F%E8%AF%BB%E5%86%99"><span class="toc-number">4.5.</span> <span class="toc-text">版本4 多线程服务，阻塞式读写</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.5.1.</span> <span class="toc-text">进程与线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E7%BB%88%E6%AD%A2"><span class="toc-number">4.5.2.</span> <span class="toc-text">线程的创建和终止</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-create%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.5.2.1.</span> <span class="toc-text">pthread_create创建一个线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-join%E7%AD%89%E5%BE%85%E6%9F%90%E4%B8%AA%E7%BA%BF%E7%A8%8B%E7%BB%88%E6%AD%A2"><span class="toc-number">4.5.2.2.</span> <span class="toc-text">pthread_join等待某个线程终止</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-self%E8%8E%B7%E5%8F%96%E8%87%AA%E8%BA%AB%E7%BA%BF%E7%A8%8BID"><span class="toc-number">4.5.2.3.</span> <span class="toc-text">pthread_self获取自身线程ID</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-detach%E5%B0%86%E6%8C%87%E5%AE%9A%E7%BA%BF%E7%A8%8B%E5%8F%98%E6%88%90%E8%84%B1%E7%A6%BB%E7%8A%B6%E6%80%81"><span class="toc-number">4.5.2.4.</span> <span class="toc-text">pthread_detach将指定线程变成脱离状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-exit%E9%80%80%E5%87%BA%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.5.2.5.</span> <span class="toc-text">pthread_exit退出线程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.5.3.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%AF%E7%9A%84%E9%94%99%E8%AF%AF"><span class="toc-number">4.5.4.</span> <span class="toc-text">犯的错误</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%88%E6%9C%AC5-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9C%8D%E5%8A%A1%EF%BC%8C%E9%98%BB%E5%A1%9E%E5%BC%8F%E8%AF%BB%E5%86%99"><span class="toc-number">4.6.</span> <span class="toc-text">版本5 线程池服务，阻塞式读写</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">4.6.1.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%99%E8%AF%AF"><span class="toc-number">4.6.2.</span> <span class="toc-text">错误</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%88%E6%9C%AC6-IO%E5%A4%8D%E7%94%A8%E4%B9%8Bepoll%E7%9B%91%E5%90%AC%E4%BA%8B%E4%BB%B6%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%BC%8F%E8%AF%BB%E5%86%99"><span class="toc-number">4.7.</span> <span class="toc-text">版本6 IO复用之epoll监听事件与非阻塞式读写</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="toc-number">4.7.1.</span> <span class="toc-text">非阻塞套接字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="toc-number">4.7.1.1.</span> <span class="toc-text">输入操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%93%8D%E4%BD%9C"><span class="toc-number">4.7.1.2.</span> <span class="toc-text">输出操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6%E5%A4%96%E6%9D%A5%E9%93%BE%E6%8E%A5"><span class="toc-number">4.7.1.3.</span> <span class="toc-text">接收外来链接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E8%B5%B7%E5%A4%96%E5%87%BA%E9%93%BE%E6%8E%A5"><span class="toc-number">4.7.1.4.</span> <span class="toc-text">发起外出链接</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#epoll"><span class="toc-number">4.7.2.</span> <span class="toc-text">epoll</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#epoll-create%EF%BC%8C%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAepoll%E5%8F%A5%E6%9F%84"><span class="toc-number">4.7.2.1.</span> <span class="toc-text">epoll_create，创建一个epoll句柄</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#epoll-ctl%EF%BC%8C%E6%B3%A8%E5%86%8C%E8%A6%81%E7%9B%91%E5%90%AC%E7%9A%84%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%92%8C%E4%BA%8B%E4%BB%B6"><span class="toc-number">4.7.2.2.</span> <span class="toc-text">epoll_ctl，注册要监听的描述符和事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#epoll-wait"><span class="toc-number">4.7.2.3.</span> <span class="toc-text">epoll_wait</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shutdown"><span class="toc-number">4.7.3.</span> <span class="toc-text">shutdown</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">4.7.4.</span> <span class="toc-text">实现</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/11/25/%E5%8B%BE%E8%82%A1%E5%AE%9A%E7%90%86/" title="勾股定理"><img src="/img/math.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="勾股定理"/></a><div class="content"><a class="title" href="/2021/11/25/%E5%8B%BE%E8%82%A1%E5%AE%9A%E7%90%86/" title="勾股定理">勾股定理</a><time datetime="2021-11-25T13:03:25.000Z" title="发表于 2021-11-25 21:03:25">2021-11-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/25/%E5%9C%86/" title="圆"><img src="/img/top.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="圆"/></a><div class="content"><a class="title" href="/2021/11/25/%E5%9C%86/" title="圆">圆</a><time datetime="2021-11-25T02:45:11.000Z" title="发表于 2021-11-25 10:45:11">2021-11-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/24/%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2/" title="线性变换"><img src="/img/math.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="线性变换"/></a><div class="content"><a class="title" href="/2021/11/24/%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2/" title="线性变换">线性变换</a><time datetime="2021-11-24T02:47:20.000Z" title="发表于 2021-11-24 10:47:20">2021-11-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/22/%E5%AF%BC%E6%95%B0/" title="导数"><img src="/img/top.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="导数"/></a><div class="content"><a class="title" href="/2021/11/22/%E5%AF%BC%E6%95%B0/" title="导数">导数</a><time datetime="2021-11-22T07:15:56.000Z" title="发表于 2021-11-22 15:15:56">2021-11-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/20/makefile/" title="makefile"><img src="/img/top.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="makefile"/></a><div class="content"><a class="title" href="/2021/11/20/makefile/" title="makefile">makefile</a><time datetime="2021-11-20T04:30:30.000Z" title="发表于 2021-11-20 12:30:30">2021-11-20</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/code.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By XuSheng</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadLivere () {
  if (typeof LivereTower === 'object') {
    window.LivereTower.init()
  }
  else {
    (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
    })(document, 'script');
  }
}

if ('Livere' === 'Livere' || !false) {
  if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
  else loadLivere()
}
else {
  function loadOtherComment () {
    loadLivere()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>