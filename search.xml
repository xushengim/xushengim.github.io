<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>一元二次方程求根公式</title>
      <link href="/2022/01/13/%E4%B8%80%E5%85%83%E4%BA%8C%E6%AC%A1%E6%96%B9%E7%A8%8B%E6%B1%82%E6%A0%B9%E5%85%AC%E5%BC%8F/"/>
      <url>/2022/01/13/%E4%B8%80%E5%85%83%E4%BA%8C%E6%AC%A1%E6%96%B9%E7%A8%8B%E6%B1%82%E6%A0%B9%E5%85%AC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<script type="math/tex; mode=display">ax^2+bx+c=0\ (a≠0)</script><p>两边同除a</p><script type="math/tex; mode=display">x^2+{b\over a}x+{c\over a}=0</script><p>凑平方项，移项</p><script type="math/tex; mode=display">(x+{b\over 2a})^2={b^2 \over 4a^2}-{c\over a}={b^2-4ac\over 4a^2}</script><p>开根号</p><script type="math/tex; mode=display">x+{b\over 2a}=±\sqrt{b^2-4ac\over 4a^2}</script><p>整理</p><script type="math/tex; mode=display">x={-b±\sqrt{b^2-4ac}\over 2a}</script><h1 id="极值点"><a href="#极值点" class="headerlink" title="极值点"></a>极值点</h1><p>导数就是瞬时变化率，就是斜率，通过导数为0可以找到可能的极值点</p><script type="math/tex; mode=display">(ax^2+bx+c)'=2ax+b，</script><script type="math/tex; mode=display">当x=-{b\over2a}时，导数为0，x<-{b\over2a}时，导数＜0，x＞-{b\over2a}时，导数＞0.</script><p>说明函数先随着自变量的增加而减少，在某点之后随着x的增加而增加，该点处即为局部极小值。</p><h1 id="韦达定理"><a href="#韦达定理" class="headerlink" title="韦达定理"></a>韦达定理</h1><script type="math/tex; mode=display">x1+x2={-b+\sqrt{b^2-4ac}\over 2a}+{-b-\sqrt{b^2-4ac}\over 2a}=-{b\over a}</script><script type="math/tex; mode=display">x1·x2={-b+\sqrt{b^2-4ac}\over 2a}·{-b-\sqrt{b^2-4ac}\over 2a}={c\over a}</script>]]></content>
      
      
      <categories>
          
          <category> 数 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>洛必达法则</title>
      <link href="/2022/01/11/%E6%B4%9B%E5%BF%85%E8%BE%BE%E6%B3%95%E5%88%99/"/>
      <url>/2022/01/11/%E6%B4%9B%E5%BF%85%E8%BE%BE%E6%B3%95%E5%88%99/</url>
      
        <content type="html"><![CDATA[<p>参考中科大-李柏坚的视频</p><h2 id="极限"><a href="#极限" class="headerlink" title="极限"></a>极限</h2><h3 id="数列的极限"><a href="#数列的极限" class="headerlink" title="数列的极限"></a>数列的极限</h3><script type="math/tex; mode=display">a_n={1\over 2^n},\ \lim_{n->\infty}a_n=0</script><p>n取的值越大(与无穷大的距离越小)，an的值与的0差距越小。另一种说法是当n趋于0时，an的值趋于0，这种说法使人感觉n是随时间运动的，n随着时间变大，an随着n变大而变小，不如第一种说法，只是静态地取一个值，没有时间和运动的感觉。</p><h3 id="函数的极限"><a href="#函数的极限" class="headerlink" title="函数的极限"></a>函数的极限</h3><p>自变量取的值与某数的距离越小(但不与该数相等)，函数(含变数之数)与极限值的距离越小。 </p><h3 id="极限的严格定义"><a href="#极限的严格定义" class="headerlink" title="极限的严格定义"></a>极限的严格定义</h3><p><img src="/2022/01/11/%E6%B4%9B%E5%BF%85%E8%BE%BE%E6%B3%95%E5%88%99/image-20220111191059047.png" alt="image-20220111191059047"></p><p>Given epsilon&gt;0，choose δ=…，if 0&lt;|x-c|&lt;δ, =&gt; |f(x)-L|<epsilon，称x->c, f(x)-&gt;L（x的取值于c的距离越小，f(x)的值与L的距离越小）</epsilon，称x-></p><p><img src="/2022/01/11/%E6%B4%9B%E5%BF%85%E8%BE%BE%E6%B3%95%E5%88%99/image-20220113231902965.png" alt="image-20220113231902965"></p><h2 id="极限的证明"><a href="#极限的证明" class="headerlink" title="极限的证明"></a>极限的证明</h2><p><img src="/2022/01/11/%E6%B4%9B%E5%BF%85%E8%BE%BE%E6%B3%95%E5%88%99/image-20220113231952782.png" alt="image-20220113231952782"></p><p><img src="/2022/01/11/%E6%B4%9B%E5%BF%85%E8%BE%BE%E6%B3%95%E5%88%99/image-20220113232020888.png" alt="image-20220113232020888"></p><h2 id="连续和可微"><a href="#连续和可微" class="headerlink" title="连续和可微"></a>连续和可微</h2><h3 id="连续"><a href="#连续" class="headerlink" title="连续"></a>连续</h3><p>若f(x)在点a处连续，则f(a)=lim_{x-&gt;a}f(x)</p><h3 id="可微"><a href="#可微" class="headerlink" title="可微"></a>可微</h3><p>若f(x)在点a处可微，则lim_{x-&gt;a}f(x)-f(a)/x-a存在</p><h3 id="可微-gt-连续"><a href="#可微-gt-连续" class="headerlink" title="可微=&gt;连续"></a>可微=&gt;连续</h3><p><img src="/2022/01/11/%E6%B4%9B%E5%BF%85%E8%BE%BE%E6%B3%95%E5%88%99/image-20220113211326879.png" alt="image-20220113211326879"></p><h3 id="连续-gt-可微"><a href="#连续-gt-可微" class="headerlink" title="连续!=&gt;可微"></a>连续!=&gt;可微</h3><p><img src="/2022/01/11/%E6%B4%9B%E5%BF%85%E8%BE%BE%E6%B3%95%E5%88%99/image-20220113211715257.png" alt="image-20220113211715257"></p><h2 id="均值定理"><a href="#均值定理" class="headerlink" title="均值定理"></a>均值定理</h2><p><img src="/2022/01/11/%E6%B4%9B%E5%BF%85%E8%BE%BE%E6%B3%95%E5%88%99/image-20220113220739771.png" alt="image-20220113220739771"></p><p>f是一个可微的函数，两点a，b构成的割线的斜率与过其中一点c的切线斜率相等</p><h3 id="衍生的洛尔定理"><a href="#衍生的洛尔定理" class="headerlink" title="衍生的洛尔定理"></a>衍生的洛尔定理</h3><p><img src="/2022/01/11/%E6%B4%9B%E5%BF%85%E8%BE%BE%E6%B3%95%E5%88%99/image-20220113221202452.png" alt="image-20220113221202452"></p><p><img src="/2022/01/11/%E6%B4%9B%E5%BF%85%E8%BE%BE%E6%B3%95%E5%88%99/image-20220113223911254.png" alt="image-20220113223911254"></p><h2 id="柯西均值定理，使用洛尔定理证明"><a href="#柯西均值定理，使用洛尔定理证明" class="headerlink" title="柯西均值定理，使用洛尔定理证明"></a>柯西均值定理，使用洛尔定理证明</h2><p><img src="/2022/01/11/%E6%B4%9B%E5%BF%85%E8%BE%BE%E6%B3%95%E5%88%99/image-20220113230916610.png" alt="image-20220113230916610"></p><p><img src="/2022/01/11/%E6%B4%9B%E5%BF%85%E8%BE%BE%E6%B3%95%E5%88%99/image-20220113225049046.png" alt="image-20220113225049046"></p><h2 id="洛必达法则"><a href="#洛必达法则" class="headerlink" title="洛必达法则"></a>洛必达法则</h2><h3 id="右极限的证明"><a href="#右极限的证明" class="headerlink" title="右极限的证明"></a>右极限的证明</h3><p><img src="/2022/01/11/%E6%B4%9B%E5%BF%85%E8%BE%BE%E6%B3%95%E5%88%99/image-20220113230623253.png" alt="image-20220113230623253"></p><p><img src="/2022/01/11/%E6%B4%9B%E5%BF%85%E8%BE%BE%E6%B3%95%E5%88%99/image-20220113231503239.png" alt="image-20220113231503239"></p><p>z∈(c,x)，x-&gt;c，那么z-&gt;c，此时认为z可用x替换</p><h3 id="左极限同理。"><a href="#左极限同理。" class="headerlink" title="左极限同理。"></a>左极限同理。</h3>]]></content>
      
      
      <categories>
          
          <category> 数 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>指数和对数</title>
      <link href="/2021/12/25/%E6%8C%87%E6%95%B0%E5%92%8C%E5%AF%B9%E6%95%B0/"/>
      <url>/2021/12/25/%E6%8C%87%E6%95%B0%E5%92%8C%E5%AF%B9%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>参考 Youtube——Stepp学院</p><h1 id="指数"><a href="#指数" class="headerlink" title="指数"></a>指数</h1><p>一开始，指数是正整数连乘的标记</p><p><img src="/2021/12/25/%E6%8C%87%E6%95%B0%E5%92%8C%E5%AF%B9%E6%95%B0/image-20211226084616460.png" alt="image-20211226084616460"></p><p>根据面积，可以拓展为正实数的连乘标记</p><p><img src="/2021/12/25/%E6%8C%87%E6%95%B0%E5%92%8C%E5%AF%B9%E6%95%B0/image-20211226084702110.png" alt="image-20211226084702110"></p><p>通过在底数的右上角写上指数的记号</p><h2 id="三条指数运算规则-指数律"><a href="#三条指数运算规则-指数律" class="headerlink" title="三条指数运算规则-指数律"></a>三条指数运算规则-指数律</h2><p><img src="/2021/12/25/%E6%8C%87%E6%95%B0%E5%92%8C%E5%AF%B9%E6%95%B0/image-20211226085214007.png" alt="image-20211226085214007"></p><p>底数为实数，指数为正整数，指数律的证明通过将左边的式子写成连乘的形式，再化为右边的式子。</p><h2 id="指数能否为0，负数，分数，不可比数？"><a href="#指数能否为0，负数，分数，不可比数？" class="headerlink" title="指数能否为0，负数，分数，不可比数？"></a>指数能否为0，负数，分数，不可比数？</h2><p>从连乘的角度想，会觉得很奇怪。</p><p>从形式的角度考虑，从满足指数律的角度，推广指数的范围。</p><p>这种推广有两个好处，一个好处是使指数运算具有连续性，另一个好处是对我们的计算和分析具有一定的帮助。</p><p><img src="/2021/12/25/%E6%8C%87%E6%95%B0%E5%92%8C%E5%AF%B9%E6%95%B0/image-20211226085440736.png" alt="image-20211226085440736"></p><h1 id="指数的扩充"><a href="#指数的扩充" class="headerlink" title="指数的扩充"></a>指数的扩充</h1><h2 id="指数为0"><a href="#指数为0" class="headerlink" title="指数为0"></a>指数为0</h2><p><img src="/2021/12/25/%E6%8C%87%E6%95%B0%E5%92%8C%E5%AF%B9%E6%95%B0/image-20211226090007040.png" alt="image-20211226090007040"></p><p>底数为0，a^0 = a^0/a^0 = 0/0 无定义</p><h2 id="指数为负整数"><a href="#指数为负整数" class="headerlink" title="指数为负整数"></a>指数为负整数</h2><p><img src="/2021/12/25/%E6%8C%87%E6%95%B0%E5%92%8C%E5%AF%B9%E6%95%B0/image-20211226090502198.png" alt="image-20211226090502198"></p><p>底数为0，a^-n = 1/a^n = 1/0 无定义</p><p><img src="/2021/12/25/%E6%8C%87%E6%95%B0%E5%92%8C%E5%AF%B9%E6%95%B0/image-20211226090554816.png" alt="image-20211226090554816"></p><h2 id="指数为可比数"><a href="#指数为可比数" class="headerlink" title="指数为可比数"></a>指数为可比数</h2><p><img src="/2021/12/25/%E6%8C%87%E6%95%B0%E5%92%8C%E5%AF%B9%E6%95%B0/image-20211226091038741.png" alt="image-20211226091038741"></p><p><img src="/2021/12/25/%E6%8C%87%E6%95%B0%E5%92%8C%E5%AF%B9%E6%95%B0/image-20211226091508281.png" alt="image-20211226091508281"></p><p>y=x^n 与 y=a 两条曲线的交点情况根据n的奇偶分为两种情况。</p><p><img src="/2021/12/25/%E6%8C%87%E6%95%B0%E5%92%8C%E5%AF%B9%E6%95%B0/image-20211226091844154.png" alt="image-20211226091844154"></p><p>为了使a^1/n的值存在且唯一，我们不再考虑a&lt;0的情况，而且只考虑方程的正根。</p><p><img src="/2021/12/25/%E6%8C%87%E6%95%B0%E5%92%8C%E5%AF%B9%E6%95%B0/image-20211226091935914.png" alt="image-20211226091935914"></p><p>指数为分数，底数＜0时，错误的使用指数律</p><p><img src="/2021/12/25/%E6%8C%87%E6%95%B0%E5%92%8C%E5%AF%B9%E6%95%B0/image-20211226092035952.png" alt="image-20211226092035952"></p><h2 id="指数为不可比数"><a href="#指数为不可比数" class="headerlink" title="指数为不可比数"></a>指数为不可比数</h2><p><img src="/2021/12/25/%E6%8C%87%E6%95%B0%E5%92%8C%E5%AF%B9%E6%95%B0/image-20211226092549064.png" alt="image-20211226092549064"></p><h1 id="对数"><a href="#对数" class="headerlink" title="对数"></a>对数</h1><p><img src="/2021/12/25/%E6%8C%87%E6%95%B0%E5%92%8C%E5%AF%B9%E6%95%B0/image-20211226093512163.png" alt="image-20211226093512163"></p><p>16是2的4次方，12是2的多少次方呢？怎么用一个数表示？</p><p>使用符号log，2为底，12为真数，表示使2的次方为12的指数</p><p><img src="/2021/12/25/%E6%8C%87%E6%95%B0%E5%92%8C%E5%AF%B9%E6%95%B0/image-20211226093824505.png" alt="image-20211226093824505"></p><p>a＞0，因为我们扩展指数的时候就规定了a＞0</p><p>为什么a≠1？</p><p><img src="/2021/12/25/%E6%8C%87%E6%95%B0%E5%92%8C%E5%AF%B9%E6%95%B0/image-20211226094024993.png" alt="image-20211226094024993"></p><p>为什么b＞0？因为a&gt;0，a^x&gt;0，只有b＞0，a^x=b才有交点</p><p>对数的含义：</p><p><img src="/2021/12/25/%E6%8C%87%E6%95%B0%E5%92%8C%E5%AF%B9%E6%95%B0/image-20211226093908290.png" alt="image-20211226093908290"></p><h2 id="对数律"><a href="#对数律" class="headerlink" title="对数律"></a>对数律</h2><h3 id="还原公式"><a href="#还原公式" class="headerlink" title="还原公式"></a>还原公式</h3><p>从代数的角度看</p><p><img src="/2021/12/25/%E6%8C%87%E6%95%B0%E5%92%8C%E5%AF%B9%E6%95%B0/image-20211226094513721.png" alt="image-20211226094513721"></p><p>从函数的角度看：指数计算和对数计算互为逆运算</p><p><img src="/2021/12/25/%E6%8C%87%E6%95%B0%E5%92%8C%E5%AF%B9%E6%95%B0/image-20211226094717677.png" alt="image-20211226094717677"></p><p><img src="/2021/12/25/%E6%8C%87%E6%95%B0%E5%92%8C%E5%AF%B9%E6%95%B0/image-20211226094726391.png" alt="image-20211226094726391"></p><h3 id="和差公式"><a href="#和差公式" class="headerlink" title="和差公式"></a>和差公式</h3><p><img src="/2021/12/25/%E6%8C%87%E6%95%B0%E5%92%8C%E5%AF%B9%E6%95%B0/image-20211226095257413.png" alt="image-20211226095257413"></p><p><img src="/2021/12/25/%E6%8C%87%E6%95%B0%E5%92%8C%E5%AF%B9%E6%95%B0/image-20211226095229290.png" alt="image-20211226095229290"></p><h3 id="指系数互换公式"><a href="#指系数互换公式" class="headerlink" title="指系数互换公式"></a>指系数互换公式</h3><p><img src="/2021/12/25/%E6%8C%87%E6%95%B0%E5%92%8C%E5%AF%B9%E6%95%B0/image-20211226095642948.png" alt="image-20211226095642948"></p><p><img src="/2021/12/25/%E6%8C%87%E6%95%B0%E5%92%8C%E5%AF%B9%E6%95%B0/image-20211226095758351.png" alt="image-20211226095758351"></p><p><img src="/2021/12/25/%E6%8C%87%E6%95%B0%E5%92%8C%E5%AF%B9%E6%95%B0/image-20211226095812210.png" alt="image-20211226095812210"></p><h3 id="换底公式"><a href="#换底公式" class="headerlink" title="换底公式"></a>换底公式</h3><p><img src="/2021/12/25/%E6%8C%87%E6%95%B0%E5%92%8C%E5%AF%B9%E6%95%B0/image-20211226100051133.png" alt="image-20211226100051133"></p><p><img src="/2021/12/25/%E6%8C%87%E6%95%B0%E5%92%8C%E5%AF%B9%E6%95%B0/image-20211226100219497.png" alt="image-20211226100219497"></p><h3 id="倒数公式"><a href="#倒数公式" class="headerlink" title="倒数公式"></a>倒数公式</h3><p><img src="/2021/12/25/%E6%8C%87%E6%95%B0%E5%92%8C%E5%AF%B9%E6%95%B0/image-20211226100321182.png" alt="image-20211226100321182"></p><h3 id="连锁公式"><a href="#连锁公式" class="headerlink" title="连锁公式"></a>连锁公式</h3><p><img src="/2021/12/25/%E6%8C%87%E6%95%B0%E5%92%8C%E5%AF%B9%E6%95%B0/image-20211226100432824.png" alt="image-20211226100432824"></p><h3 id="互换公式"><a href="#互换公式" class="headerlink" title="互换公式"></a>互换公式</h3><p><img src="/2021/12/25/%E6%8C%87%E6%95%B0%E5%92%8C%E5%AF%B9%E6%95%B0/image-20211226100557445.png" alt="image-20211226100557445"></p>]]></content>
      
      
      <categories>
          
          <category> 数 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>钱</title>
      <link href="/2021/12/23/%E9%92%B1/"/>
      <url>/2021/12/23/%E9%92%B1/</url>
      
        <content type="html"><![CDATA[<p>稀有金属作为货币，是一个国家最重要的财富，增加货币流入，减少货币流出，是国家最重要的任务。这种重视贸易盈余，和金银累积的观念，被后来人称为重商主义，也叫重金注意。</p><p>亚当·斯密和李嘉图指出，货币的价值只是表象，价值在商品中，货币只是个中介(货币中立说)。决定商品价值的，是生产一个商品所需要的劳动时间(劳动价值论)。</p><p>亚当·斯密自己也被水和钻石难住了，劳动很直观，价值却很模糊。水极易获得，但很有价值，钻石极难获得，但价值连城。</p><p>后来，亚当·斯密说，水的使用价值很高，但交换价值很低，钻石的使用价值很低，但交换价值很高（价值二分法）。</p><p>塞缪尔·贝利：价值并不表示什么绝对的内在的东西，不过是作为两个对象可以交换的商品之间的关系。价值即同时代各种商品之间的关系。因为只有这些商品才能够相互得到交换。</p><p>价值基于某次偶然的交换，交换的结果被其他交换所参考即承认。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>逻辑学</title>
      <link href="/2021/12/20/%E9%80%BB%E8%BE%91%E5%AD%A6/"/>
      <url>/2021/12/20/%E9%80%BB%E8%BE%91%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<p>参考：Youtube——汤质看本质</p><h1 id="追溯语言"><a href="#追溯语言" class="headerlink" title="追溯语言"></a>追溯语言</h1><p>我们的所有认识，都用语言来表达，符号，声音，含义。语言和思考是我们认识世界的工具。那么，语言这个工具是怎么产生的呢，是否足够清晰呢？实际上，我们很多时候都是使用着不怎么清晰但有效的工具生活着。</p><p>要想溯源语言，就要先不使用语言的工具，像一个远古的人类一样，在没有语言的情况下生活，然后慢慢开始创造符号，利用声带，描述和记录自己的感官感受到的一切。</p><p>这样之后我们才明白，最初的语言是不能解释的的，直接与感受到的东西对应的。</p><p>在语言上发展起来的，可描述记录的，复杂的认识，其底层也是不能解释的，直接与感受到的东西关联的。</p><p>如果没有千差万别的实物，就没有各种感受，就不能根据感受的差异，用符号和声音定义实物，归纳出种类。</p><p>没有定义出的概念和归纳出的种类，就不能进行类比，人类就没法依靠实物去理解就看不见摸不着的东西。</p><p>我们总是比较地，也就是相对地看实物，是否有绝对的存在，没有短处的存在？把我们感受到的或想象出来的绝对的东西，称为理性的东西/存在，如，绝对的数，绝对的逻辑，默认的公理。</p><p>语言靠感受对应符号和声音产生，靠归纳和类比发展。语言是我们认识、理解一切的工具。</p><p>人从过去(曾经的实物，实物间的关系，一切的可能有规律可能无规律的变化)通过归纳、类比和演绎获得认识\知识\经验，从而，能根据现在的一切，预测未来。认识是有了语言之后，进一步通过归纳，类比，演绎的手段得到的东西。必然的演绎也是在或然的归纳和类比后出现的。</p><p>人可以通过观察，定义，归纳，类比，演绎来认识和预测自己感受和想象到的一切，但也只能认识和预测自己感受和想象到的一切。</p><h2 id="想象自己是个野蛮人"><a href="#想象自己是个野蛮人" class="headerlink" title="想象自己是个野蛮人"></a>想象自己是个野蛮人</h2><p>感官发现一切不同之处，用符号，声音，在大脑中与做感受到的东西绑定</p><p>“”表示还没出现的词，</p><h2 id="语言中到处是归纳和类比"><a href="#语言中到处是归纳和类比" class="headerlink" title="语言中到处是归纳和类比"></a>语言中到处是归纳和类比</h2><p><strong>“名词”：</strong></p><p>水，树，草，苹果，石榴，石头，毛皮，兔子，鹿，狮子，狼，鱼，蘑菇，蛇，血，人，女人，男人，小孩，老人，篮子，袋子，盒子，平地，山——兽，果，肉</p><p>手，手掌，手指，脚，腿，头，眼睛，鼻子，耳朵，舌头，唇，牙——身体，部位</p><p>红，黄，蓝，绿，紫，橙——颜色</p><p>惊，怒，喜，悲——情绪</p><p>天空</p><p>凳子，椅子</p><p>标记，地点，位置</p><p>生长，长大，增长</p><p>——类</p><p>——部分和整体，元素和集合</p><p>——实(东西，物)，虚</p><p>——名词</p><p><strong>“动词”:</strong></p><p>看，听，摸，出现，发现，拿，采摘，咀嚼，吃，喝，吞，撕，劈，扔，游，分割，指，点，抽取</p><p>——动作</p><p>——作用</p><p>——对象</p><p>抱，保护，持，贴，靠</p><p>走，跑，站，坐</p><p>睡</p><p>思考，反思</p><p>渴望\想</p><p>定义\命名</p><p>比较</p><p>想象(象就是实物，脑里出现象)</p><p>抽象(从象里抽出什么东西)</p><p>——动词</p><p><strong>“形容词”：</strong></p><p>高的，矮的，长的，短的，大的，小的，强壮的，瘦弱的，圆的，不规则的，锋利的，钝的，红色的，蓝色的，绿色的，美的，丑的，善的，恶的，勇敢的，胆小的</p><p>倒霉的，幸运的</p><p>某人的</p><p>相同的，不同的，类似的，一样的</p><p>实际的，虚妄的，存在的，不存在的</p><p>什么什么的</p><p>——形容词</p><p><strong>“副词”：</strong></p><p>凶猛地，轻轻地，粗暴地，温柔地，飞快地，慢慢地，类似地，一样地(也)，一起(走)，分开(走)</p><p>只，仅仅</p><p>——副词</p><p><strong>“数词”</strong></p><p>1果子，1狮子，2果子，2狮子，3人，全部，所有，没有</p><p>——数词</p><p><strong>“代词”</strong></p><p>我，你，他，我们，你们，他们，这，那，此</p><p>什么</p><p>——代词</p><p>——代表，指代，表示</p><p><strong>“介词”</strong>(空间中的位置，时间中的位置，元素属于整体)</p><p>“空间”：在…上，在…下，在…里，这里，那里</p><p>”时间“：在…时，现在，在…前，刚才，在…后，之后，先，后</p><p>起点：从</p><p>终点：到</p><p>从这里到那里，100米</p><p>部分和整体：</p><p>我属于/是人</p><p>她是/属于美丽的女人</p><p>我属于村子</p><p>手属于身体</p><p>那东西是狮子</p><p>狮子是兽</p><p>等价，两物相同：</p><p>凤梨就是菠萝</p><p>我是神</p><p>——介词</p><p><strong>“助词”</strong></p><p>开始形容：</p><p>他是唐吉坷德-&gt;它的名字是唐吉坷德</p><p>他是一个勇敢的人</p><p>指向动作的对象：</p><p>我对着他打了一拳</p><p><strong>“冠词”</strong>(特指)</p><p>这个，那个</p><p><strong>“连词”</strong></p><p>连接词语</p><p>我和你，女人和孩子</p><p>连接句子</p><p>要么我死，要么你死</p><p>选这条路，或者那条路</p><p>先打猎，后吃肉</p><p>因为没有食物，所有人都没有希望了</p><p>虽然没有食物，但是我们有信念</p><p><strong>“叹词”</strong></p><p>啊，额，哦，呀，嗯，哎，</p><p>——叹词</p><h2 id="“逻辑词”"><a href="#“逻辑词”" class="headerlink" title="“逻辑词”"></a>“逻辑词”</h2><p>而且</p><p>否定</p><p>不</p><p>导致</p><p>决定</p><p>或</p><p>类比</p><p>推出</p><p>如果A，那么B（A是B的充分条件）</p><h2 id="类比-隐喻"><a href="#类比-隐喻" class="headerlink" title="类比\隐喻"></a>类比\隐喻</h2><p>用某种实物的属性，描述对象(对表示关注，象就是实物)的特征</p><p>“实-&gt;虚”</p><p>圆规，直尺，音律，相似地重复——规律</p><h3 id="认识"><a href="#认识" class="headerlink" title="认识"></a>认识</h3><p>认出，识别出实物-&gt;认识实物或虚物。认识是动词，知识是名词。认识做名词时，等同于知识。</p><p>人从过去得到认识\知识，根据现在的一切，预测未来。</p><p>认识\知识归纳的强度，即知识解释过去现象的覆盖程度，和预测未来现象的覆盖程度。</p><p>认识\知识都是归纳出来的，都可能有错。必然的演绎，也是在归纳和类比之后发展出来的。</p><hr><p>长矛，坚盾-&gt;矛盾(两个对象(或实或虚)有着非常不同的属性)</p><p>-&gt;冲突</p><p>绳子-&gt;联系</p><p>扫干净-&gt;澄清</p><p>解绳子-&gt;理解</p><p>重-&gt;重要</p><p>实物的大，-&gt;有巨大的作用</p><p>展示货品-&gt;展现力量，展现精神</p><p>坏蛋-&gt;坏人</p><p>制作工具-&gt;做决定，做选择，做判断</p><p>皮-&gt;表面的</p><p>有钱的人-&gt;有身份的人</p><p>这个人有很多牛羊-&gt;货币有一样的数目-&gt;等价</p><p>前后-&gt;先后</p><p>水-&gt;时间</p><p>盒子-&gt;空间</p><p>实际的东西-&gt;心理</p><p>扔-&gt;放弃</p><p>要“有”耐心</p><p>“保持”警惕</p><p>人对物的认识，理解</p><p>实际的活动-&gt;思维活动</p><p>分割，摆放-&gt;区分，归纳</p><p>多面体-&gt;在\从多方面说，在\从时间上说，在\从空间上说</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>名词-&gt;类-&gt;部分和整体-&gt;实物，虚物-&gt;指代-&gt;联系</p><p>语言从实物发展起，用实物解释虚物</p><h1 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h1><p>数学是理解自然的语言，自然的规律通过数学符号简洁、明确地呈现；数学是科学的王后，数论是数学的王冠，从自然数、可比数到不可比数，实数、复数、使用集合论公理化数集，数衡量一切；一切悬而未决的数论的问题，被称为王冠上的明珠，比如哥德巴赫的猜想“一个合数可以分解为两个质数”至今未能解决。</p><h1 id="教育"><a href="#教育" class="headerlink" title="教育"></a>教育</h1><p>教，带有强迫意味。经历过许多的长辈，知道哪些知识很重要，而小孩不知道，长辈要先强迫小孩一会儿。而好的教学能让小孩尽快地对所传授的知识感兴趣，并能更好地理解和应用。</p><p>育，带有长辈对后辈的关怀与期望。苏联一位教育家，叫苏霍姆林斯基，他说：我们的教育是为了把青少年培养成一个全面和谐发展的人，一个社会积极的进步参与者。而培养这样一个人，需要德育、智育、体育、劳动教育和审美教育深度交织在一起。也就是说，我们要把学生培养成一个合格的公民，使他们有明确的是非善恶观，能够积极地参与社会活动，对社会有贡献。</p><p>筛选的教育：国家的教育资源是有限的，教师有限，设备有限，只能筛选出一部分人重点发展。教育除了育人，还肩负筛选的功能。谁愿意自甘落后呢？谁愿意被筛选下去呢？谁不想享受丰富的资源呢？这是一个难以解决的问题，只有当社会资源足够丰富，或者社会中人的观念发生改变，激烈的教育资源竞争，本质上是社会资源的竞争，才能得到缓解。电子通信设施能把优质的教学资源带给普通人，实在是壮举。</p><h1 id="哲学"><a href="#哲学" class="headerlink" title="哲学"></a>哲学</h1><p>一开始我们问，世界的本质是什么？世界广阔无垠，我们认怂了。</p><p>后来我们问，我们能认识到什么？个体千差万别，我们又认怂了。</p><p>之后，我们从怀疑我们认识到的内容，怀疑产生这些认识的工具，也就是语言。如果连语言都不能无二义，那连我们有限的认识都是混乱的。</p><p>罗素用来发现语言中无二义的工具是逻辑，罗素把逻辑发展到了极致。他认为语言的混乱来自于我们概念关系的混乱。但是语言中蕴含的逻辑形式，是精确的无二义的，可以去除语言的混乱。</p><p>维特根斯坦是罗素的学生，发现了终结一切哲学的哲学，又亲手推翻了终结一切哲学的哲学。</p><h2 id="什么是逻辑？"><a href="#什么是逻辑？" class="headerlink" title="什么是逻辑？"></a>什么是逻辑？</h2><p>逻辑，是推理的规律，逻辑学是研究推理的有效性的知识。</p><p>什么是推理的有效性，推理的有效性就是“从真推出真”。逻辑研究的不是这里面的真，真是实际科学观测验证的，逻辑研究的是这个推出怎么发生的。</p><ul><li><p>因为苏格拉底是人</p></li><li><p>所以苏格拉底会死</p></li></ul><p>我不关心苏格拉底到底是不是真的是人，但是我关心为什么他是人，可以推出他会死。</p><p>也就是说从一个前提或者多个前提，得到某个结论，这里面的内在规律是什么样子的。答案只有可能是，你前面的所有东西，包含了后面所需要的所有信息。至于你前面说的事情是不是真的，逻辑管不着。</p><p><img src="/2021/12/20/%E9%80%BB%E8%BE%91%E5%AD%A6/image-20211220170246292.png" alt="image-20211220170246292"></p><p>逻辑和数学一样，只是关于形式的学科，而不是关于内容的学科。形式永远不会创造新的信息，结论必须包含在前提里。</p><h1 id="逻辑学-必然的演绎"><a href="#逻辑学-必然的演绎" class="headerlink" title="逻辑学-必然的演绎"></a>逻辑学-必然的演绎</h1><h2 id="概念-词项-，命题，推理，论证，逻辑"><a href="#概念-词项-，命题，推理，论证，逻辑" class="headerlink" title="概念(词项)，命题，推理，论证，逻辑"></a>概念(词项)，命题，推理，论证，逻辑</h2><p>逻辑学，确保推理的有效性，通过旧的知识，产生新的知识。知识是世界的规律的呈现，放到你的心灵面前，你欣然接受（你已有的经验认可），且在实际应用中有效。</p><p>思维最基本的单位是概念，我们用概念划分事物，如果事物之间没有任何差异，那么就不再需要概念。</p><p>比思维大一些的，是模型。模型可以是命题，可以是公式，可以是图示，无论它是什么，它都包含了很多个概念。我们用模型来建立和把握概念之间的关系。</p><p>我们划分事物，建立事物间的关系，是为了进行有效的判断。命题是有判断功能的语句</p><p>从已知命题中推出未知命题的行为，叫做推理。在推理中，已知命题叫前提，未知命题叫结论。推理有三种方法：</p><ul><li>演绎推理，从大范围范畴中找到小范畴，是必然性推理</li><li>归纳推理，从众多小范畴中找到大范畴，是或然(可能正确)性推理</li><li>类比推理，在相似的范畴之间，进行推理，是或然性推理</li></ul><p>多个前提，用各种推理形式(作用到前提和中间命题上)得到结论，这个过程称为论证。</p><p><img src="/2021/12/20/%E9%80%BB%E8%BE%91%E5%AD%A6/image-20211223162109636.png" alt="image-20211223162109636"></p><p>逻辑，确保推理和论证有效的规则，推理和论证是否有效，你说了不算，逻辑说了算</p><p><img src="/2021/12/20/%E9%80%BB%E8%BE%91%E5%AD%A6/image-20211223162239023.png" alt="image-20211223162239023"></p><h1 id="逻辑的有效性"><a href="#逻辑的有效性" class="headerlink" title="逻辑的有效性"></a>逻辑的有效性</h1><p>逻辑，确保推理和论证有效的规则，推理和论证是否有效，你说了不算，逻辑说了算。</p><p>逻辑规则为什么有效？</p><h2 id="逻辑的本质是必然的得出"><a href="#逻辑的本质是必然的得出" class="headerlink" title="逻辑的本质是必然的得出"></a>逻辑的本质是必然的得出</h2><p>经典逻辑学的创始人，亚里士多德认为，逻辑的本质就是必然的得出。只有演绎逻辑是符合这个要求的，所以在经典逻辑学中，只有演绎逻辑，和基于演绎逻辑发展起来的数理逻辑。</p><p>演绎逻辑和数理逻辑，统称为形式逻辑</p><p><img src="/2021/12/20/%E9%80%BB%E8%BE%91%E5%AD%A6/image-20211220153534866.png" alt="image-20211220153534866"></p><h2 id="四种基本命题"><a href="#四种基本命题" class="headerlink" title="四种基本命题"></a>四种基本命题</h2><p>命题的基本单位是概念，推理和论证的基本单位是命题，</p><p>AEIO是四种基本命题的缩写，它们是推理和论证的基本起点。</p><p>AEIO来源于两个拉丁单词affirmo和nego，对应的是肯定和否定的意思。分别取这两个单词中的元音字母AI和EO，A和I代表肯定，E和O代表否定。同时前面的字母代表全体，后面的字母代表特定，所以，A和E分别是全称肯定和全称否定，I和O分别是特称肯定和否定。</p><p>你如何构建命题，澄清你和苹果之间的关系呢？</p><p>你迅速得出，我不是苹果！你得出这样的判断，你等同于拒绝了我是苹果这样的判断，也拒绝了一部分我是苹果这样的判断，接收了一部分我不是苹果这样的判断。一些人将这样的规则整理出来，形成了一个逻辑方阵：</p><p><img src="/2021/12/20/%E9%80%BB%E8%BE%91%E5%AD%A6/image-20211220154445881.png" alt="image-20211220154445881"></p><p>反对：一命题真，则另一命题假，可以全假</p><p>矛盾：两命题不能同时真或同时假</p><h2 id="三段论-词项逻辑-画圈圈"><a href="#三段论-词项逻辑-画圈圈" class="headerlink" title="三段论-词项逻辑-画圈圈"></a>三段论-词项逻辑-画圈圈</h2><p>亚里士多德认为，三段论的实质是事物中的必然因果关系在思维形式中的展现。</p><p>三段论是在头脑里画圈圈，帮助我们澄清概念之间的关系，圈定一个概念的范畴，范畴的覆盖范围也叫外延。</p><p>三段论要有效，要符合一套规则。其中之一是：中圈不出现在结论中，但必须出现在两个前提中，作为大圈和小圈的中介，来明确大圈和小圈的关系。</p><p><img src="/2021/12/20/%E9%80%BB%E8%BE%91%E5%AD%A6/image-20211220155414665.png" alt="image-20211220155414665"></p><p><img src="/2021/12/20/%E9%80%BB%E8%BE%91%E5%AD%A6/image-20211220155438446.png" alt="image-20211220155438446"></p><p>还有一条规则是：中圈还要在两个前提中至少被覆盖一次。</p><p><img src="/2021/12/20/%E9%80%BB%E8%BE%91%E5%AD%A6/image-20211220160042399.png" alt="image-20211220160042399"></p><p>当然如果前提为假，结论必为假，但是推理的有效是形式上的有效，内容的正假，需要实证科学的支持，逻辑是形式科学。</p><h3 id="256种三段论形式"><a href="#256种三段论形式" class="headerlink" title="256种三段论形式"></a>256种三段论形式</h3><p>三段论中的每一段，都是四种基本命题之一，所以我们可以得到64种三段论的基本组合。</p><p><img src="/2021/12/20/%E9%80%BB%E8%BE%91%E5%AD%A6/image-20211223172849911.png" alt="image-20211223172849911"></p><p>根据大中小项的位置不一样，我们可以得到三段论的四大类型。</p><p><img src="/2021/12/20/%E9%80%BB%E8%BE%91%E5%AD%A6/image-20211223172919452.png" alt="image-20211223172919452"></p><p>然后，我们可以得到256种三段论的形式，其中只有15种有效的推理形式。</p><p><img src="/2021/12/20/%E9%80%BB%E8%BE%91%E5%AD%A6/image-20211223173005278.png" alt="image-20211223173005278"></p><h3 id="6条规则判断三段论是否有效"><a href="#6条规则判断三段论是否有效" class="headerlink" title="6条规则判断三段论是否有效"></a>6条规则判断三段论是否有效</h3><p><img src="/2021/12/20/%E9%80%BB%E8%BE%91%E5%AD%A6/image-20211223173119975.png" alt="image-20211223173119975"></p><h2 id="命题逻辑"><a href="#命题逻辑" class="headerlink" title="命题逻辑"></a>命题逻辑</h2><p>三段论也叫词项逻辑，词项之后才有所谓的命题逻辑，才有后面数学化后的命题运算和谓词逻辑等</p><p>词项逻辑关注概念之间的关系，命题逻辑关注命题之间的关系。在命题逻辑中，命题分为两种：</p><ul><li><p>基本命题：AEIO，如所有苹果都是食物</p></li><li><p>复合命题：多个基本命题加上命题连接词组成的复合命题，如所有苹果都是食物，而且所有食物都可以吃。</p></li></ul><p>人们之所以需要命题逻辑，是要在知道一个基本命题的真假之后，能够判断一个复合命题的真假。</p><p>词项逻辑穷尽了所有词项间的推理规则，命题逻辑要穷尽所有复合命题的真假判断规则</p><p><img src="/2021/12/20/%E9%80%BB%E8%BE%91%E5%AD%A6/image-20211223173951778.png" alt="image-20211223173951778"></p><p>常用的连接词有 与,或,非,如果…那么..(-&gt;)</p><p>关于如果…，那么。如果p:你能秒我，那么q:我就把键盘吃下去。</p><p>①条件p发生，结论q发生，推导有效</p><p>②条件p发生，结论q没发生，推导无效</p><p>③条件p没发生，结论q发生，规定推导有效</p><p>④条件p没发生，结论q没发生，规定推导有效</p><p>真值作用(function)</p><p>复合命题的基本命题的真假，经过连接词作用后，得到真或假输出，称命题连接词为真值作用。</p><p>真值表</p><p>复合命题的基本命题的各种真假情况，以及在各种连接词作用后得到的真假，它们的排列叫做真值表。</p><p>命题运算</p><p>这种通过运算得到复合命题的真假的过程，叫做命题运算</p><p>逻辑代数</p><p>1854年，乔治布尔发表了《THE LAWS OF THOUGHT》 THE MATHEMATICAL THEORIES OF LOGIC AND PROBABILITIES。创立了逻辑代数，布尔发现，对命题的运算可以简化成对符号的代数(用符号代替数，用数代替数，这里是用0,1代替真假)运算。</p><p><img src="/2021/12/20/%E9%80%BB%E8%BE%91%E5%AD%A6/image-20211223212044706.png" alt="image-20211223212044706"></p><p><img src="/2021/12/20/%E9%80%BB%E8%BE%91%E5%AD%A6/image-20211223212102343.png" alt="image-20211223212102343"></p><p><img src="/2021/12/20/%E9%80%BB%E8%BE%91%E5%AD%A6/image-20211223212132693.png" alt="image-20211223212132693"></p><h1 id="ToDo，逻辑代数的公理，推出的定理，为什么与或非能替代所有命题连接词。逻辑代数在逻辑电路-数字电路-中的应用，数字电路分为组合逻辑电路，时序逻辑电路-带存储元件-。看实用电子元器件和电路基础后再来探究。"><a href="#ToDo，逻辑代数的公理，推出的定理，为什么与或非能替代所有命题连接词。逻辑代数在逻辑电路-数字电路-中的应用，数字电路分为组合逻辑电路，时序逻辑电路-带存储元件-。看实用电子元器件和电路基础后再来探究。" class="headerlink" title="ToDo，逻辑代数的公理，推出的定理，为什么与或非能替代所有命题连接词。逻辑代数在逻辑电路(数字电路)中的应用，数字电路分为组合逻辑电路，时序逻辑电路(带存储元件)。看实用电子元器件和电路基础后再来探究。"></a>ToDo，逻辑代数的公理，推出的定理，为什么与或非能替代所有命题连接词。逻辑代数在逻辑电路(数字电路)中的应用，数字电路分为组合逻辑电路，时序逻辑电路(带存储元件)。看实用电子元器件和电路基础后再来探究。</h1><p><strong>我们可以用且或非三个命题连接词表示所有命题连接词的功能。</strong></p><p>这种运算使得用数学符号来规范自然语言成为可能。</p><p>数学家弗雷格在命题逻辑中加入了量词，开创了量化逻辑，也叫谓词逻辑</p><p>并宣称能用它描述和分析所有数学上的和思想上的命题</p><p>紧接着，伯特兰·罗素和怀特海在数学原理中试图用与、或、非三种逻辑为整个数学建立基础。</p><p>信息论的创始人香农发现，逻辑代数的计算能力是可以外包出去的(用电路实现)，1936年，香农发表了《继电器与开关电路的符号分析》，他发现布尔逻辑中的真假值，可以和电路开关相对应，线路闭合电流通过表示1，线路断开电流受阻表示0，我们还能在电路中加入特定的开关结构，来实现且或非这样的逻辑关系，这就是电路图上的逻辑门：与门，或门，非门</p><p>神经科学家沃伦·麦卡洛可发现，神经元要么发射信号，要么不发射信号，这种工作方式与布尔电路非常相似。也许不只是判断，包括认识在内的所有行为都是可以外包给电路的。他和他的合作者沃尔特·彼茨合作发表论文《A LOGICAL CALCULUS OF THE IDEAS IMMANENT IN NERVOUS ACTIVITY》神经活动中固有的思想的逻辑运算，提出了人工神经元的数学模型，为人工智能的诞生奠定了基础</p><p>早期的计算机用继电器来控制线路闭合，每秒只能操作五十次</p><p>后来的计算机用非机械结构的晶体管来作为通断开关，能达到每秒通断几百上千亿次，这样一个晶体管只有几十甚至几纳米大，一块CPU上能够装上几百亿个。AlphaGo有1000多个这样的CPU。在最微观的层面上，它依然只是不断地连通和断开，但在宏观的层面上，它们做出了以前只有人能做出的，甚至连人类都做不出的复杂的判断。</p><h1 id="最初的归纳"><a href="#最初的归纳" class="headerlink" title="最初的归纳"></a>最初的归纳</h1><h1 id="奇妙的类比"><a href="#奇妙的类比" class="headerlink" title="奇妙的类比"></a>奇妙的类比</h1><h2 id="谬误"><a href="#谬误" class="headerlink" title="谬误"></a>谬误</h2><ul><li>前提谬误</li><li>支持谬误</li><li>相干谬误</li></ul><h2 id="逻辑与语言表述"><a href="#逻辑与语言表述" class="headerlink" title="逻辑与语言表述"></a>逻辑与语言表述</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>微积分</title>
      <link href="/2021/12/13/%E5%BE%AE%E7%A7%AF%E5%88%86/"/>
      <url>/2021/12/13/%E5%BE%AE%E7%A7%AF%E5%88%86/</url>
      
        <content type="html"><![CDATA[<p>参考台湾大学的微积分课程-陈金次教授</p><p>Youtube-Stepp学院</p><p>Youtube-冉哥 参考书《Principles of Mathematical Analysis》Third EDITION by Walter Rudin</p><p>Youtube-李永乐</p><p>知乎，百度</p><h1 id="一、《Principles-of-Mathematical-Analysis》Chapter1-结合冉哥视频"><a href="#一、《Principles-of-Mathematical-Analysis》Chapter1-结合冉哥视频" class="headerlink" title="一、《Principles of Mathematical Analysis》Chapter1 结合冉哥视频"></a>一、《Principles of Mathematical Analysis》Chapter1 结合冉哥视频</h1><p>公理化数集，繁琐，严谨，但不直观，建议跳过。</p><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>从习惯上的自然数、可比数及其加减乘除次方运算，发展到用集合定义数集，定义运算</p><h3 id="集合，元素，常见数集"><a href="#集合，元素，常见数集" class="headerlink" title="集合，元素，常见数集"></a>集合，元素，常见数集</h3><p>把你感兴趣的东西放在一起，被放到一起的东西叫element(元素)，整体称为Set(集合)。</p><p>元素符合的条件：不重复，无顺序。</p><p>元素和集合的关系：元素∈(属于)或∉(不属于)一个集合。</p><p>集合和集合的关系：如果一个集合的元素，总是属于另一个集合，称该集合包含于另一个集合，若两集合不相同，则成该集合真包含于另一个集合。</p><p>常见的数集：</p><ul><li>N 自然数集：0, 1, 2, 3, …</li><li>Z 整数集：…, -3, -2, -1, 0, 1, 2, 3, …，在N的基础上增加负数</li><li>Q 可比数集：1, 1.1, 1.11,  1/2, 1.232323…, …</li><li>R 实数集：根号2，π，e,… 在Q的基础上增加不可比数</li></ul><p>超越实际世界之处：集合的元素，可以是无穷多个的(没有确定的上界，总能找到更大的元素)</p><p>无尽：没有尽头，假设一个尽头，总能找到尽头之外的东西。</p><p>稠密：指定一个点，无法指定邻点，如果指定邻点，总能找到更近的邻点。</p><h3 id="集合的运算"><a href="#集合的运算" class="headerlink" title="集合的运算"></a>集合的运算</h3><p>集合与另一个集合做运算，产生新的集合</p><p>Union(联合) AUB={a|a∈A or a∈B}</p><p>Intersection(相交) A∩B={a|a∈A and a∈B}</p><p>Complement(补) A-B={a|a∈A and a∉B}</p><h3 id="集合的运算性质"><a href="#集合的运算性质" class="headerlink" title="集合的运算性质"></a>集合的运算性质</h3><p>集合的运算性质建立在逻辑运算(and or not)的运算性质上，逻辑运算的运算性质是观察真实世界后，规定出来的，是不可证的公理。</p><ul><li>commutative law 交换律：</li></ul><p>AUB=BUC，A∩B=B∩A</p><script type="math/tex; mode=display">\begin{matrix}证明:\ A\cup B=B\cup A \\令\ X=A\cup B=\{a|a\in A\ or\ a\in B\}\\Y=B\cup A=\{a|a\in B\ or\ a\in A\}\\由于逻辑运算or的可交换性，X=Y，即\ A\cup B=B\cup A\end{matrix}</script><ul><li>associative law 结合律：</li></ul><p>AU(BUC) = (AUB)UC</p><p>A∩(B∩C) = (A∩B)∩C</p><ul><li>distributive law 分配率：</li></ul><p>AU(B∩C) = (AUB)∩(AUC)</p><p>A∩(BUC) = (A∩B)U(A∩C)</p><h3 id="有序集"><a href="#有序集" class="headerlink" title="有序集"></a>有序集</h3><p>Ordered Set 集合中的元素可以比大小</p><p>Order：(i)x∈S，y∈S，要么x＜y，要么x＝y，要么x＞y。</p><p>(ii) if x＜y and y＜z，then x＜z</p><h3 id="上界和最小上界"><a href="#上界和最小上界" class="headerlink" title="上界和最小上界"></a>上界和最小上界</h3><p><strong>S是一个有序集</strong>，E包含于S，如果β∈S，使得对E集合中的任意元素x都有，x≤β，称β为E的上界</p><p>α是E的一个上界，如果r＜α，则r不是E的上界，则α是E的最小上界。</p><p><img src="/2021/12/13/%E5%BE%AE%E7%A7%AF%E5%88%86/image-20211219204148549.png" alt="image-20211219204148549"></p><p><img src="/2021/12/13/%E5%BE%AE%E7%A7%AF%E5%88%86/image-20211219204203071.png" alt="image-20211219204203071"></p><p><img src="/2021/12/13/%E5%BE%AE%E7%A7%AF%E5%88%86/image-20211219204222142.png" alt="image-20211219204222142"></p><p>类似的，<strong>S是一个有序集</strong>，E包含于S，如果β∈S，使得对E集合中的任意元素x都有，x≥β，称β为E的下界</p><p>α是E的一个下界，如果r＞α，则r不是E的下界，则α是E的最大下界。</p><h4 id="平方平均-算术平均-几何平均-调和平均-勾股定理，相似，切线"><a href="#平方平均-算术平均-几何平均-调和平均-勾股定理，相似，切线" class="headerlink" title="平方平均 算术平均 几何平均 调和平均(勾股定理，相似，切线)"></a>平方平均 算术平均 几何平均 调和平均(勾股定理，相似，切线)</h4><p><img src="/2021/12/13/%E5%BE%AE%E7%A7%AF%E5%88%86/image-20211215203853182.png" alt="image-20211215203853182"></p><h4 id="圆的切线垂直于过切点的半径"><a href="#圆的切线垂直于过切点的半径" class="headerlink" title="圆的切线垂直于过切点的半径"></a>圆的切线垂直于过切点的半径</h4><p><img src="/2021/12/13/%E5%BE%AE%E7%A7%AF%E5%88%86/image-20211215204909001.png" alt="image-20211215204909001"></p><h2 id="最小上界性质"><a href="#最小上界性质" class="headerlink" title="最小上界性质"></a>最小上界性质</h2><p>如果对于有序集S(元素可比较大小)，S的任意子集E非空，E有上界，则E有最小上界，称有序集S具有最小上界性质</p><p>Q没有最小上界性质，因为其子集{x|x∈Q and x^2＜2}没有最小上界。</p><h2 id="定理：确界性定理"><a href="#定理：确界性定理" class="headerlink" title="定理：确界性定理"></a>定理：确界性定理</h2><p>如果一个集合具有最小上界性质，那么它也具有最大下界性质  </p><script type="math/tex; mode=display">\begin{matrix}证：有序集S，B是其子集，有下界，L是B的下界集合 \\x是B的元素，y是L的元素，y是B的下界，故\forall x\in B,\forall y\in L\ \ x\ge y \\所以B中的元素都是L的上界  \\因为S具有最小上界性质，故L有最小上界\alpha,\forall \gamma\lt\alpha\ \ \gamma不是L的上界\\if\ \gamma \lt \alpha,then\ \gamma不是L的上界,即\exists y\gt\gamma,故\gamma \notin B\\从集合S的角度看，元素依次排列:\\比\alpha小的\gamma(\alpha的左侧)\lt x,则\alpha\le x,故\alpha是B的下界，\alpha\in L\\if\ \alpha\lt\beta\ then\ \beta\notin L,\alpha是B的下界，任意比\alpha大的\beta都不是B的下界\\故\alpha是B的下确界\end{matrix}</script><h4 id="自己的思考"><a href="#自己的思考" class="headerlink" title="自己的思考"></a>自己的思考</h4><p>将所有感兴趣的数组成一个集合，这个数集中的所有点挤在一起形成了数轴，数轴的左右或许有或许没有尽头，截取数轴的一小段或许有或许没有尽头。</p><p>无尽：没有尽头，假设一个尽头，总能找到尽头之外的东西。</p><p>稠密：指定一个点，无法指定邻点，如果指定邻点，总能找到更近的邻点。</p><p>自然数是无尽的，但不稠密的；可比数是无尽的，稠密的。</p><p>可以分情况讨论：</p><ol><li>S集合是不稠密的<img src="/2021/12/13/%E5%BE%AE%E7%A7%AF%E5%88%86/image-20211216133425295.png" alt="image-20211216133425295"></li><li>S集合是稠密的，B有最小元素<img src="/2021/12/13/%E5%BE%AE%E7%A7%AF%E5%88%86/image-20211216133415787.png" alt="image-20211216133415787"></li><li>S集合是稠密的，B没有最小元素<img src="/2021/12/13/%E5%BE%AE%E7%A7%AF%E5%88%86/EQFCMN%5DUF13L%7D%5D60TY7DS9T.jpg" alt="img"></li></ol><h2 id="域Field"><a href="#域Field" class="headerlink" title="域Field"></a>域Field</h2><p>域是一个集合，有两个操作 + ·，并且符合域公理(field axioms)</p><p>如果元素都是数，这个域称为数域</p><script type="math/tex; mode=display">\begin{matrix}(A)\ Axioms\ for\ addition \\(1)\ if\ x\in F\ and\ y\in F,then\ their\ sum\ x+y\ is\ in\ F \\(2)Commutative:x+y=y+x\\(3)Associative:(x+y)+z=x+(y+z)\\(4)F\ contains\ an\ element\ 0\ such\ that\ 0+x=x\ for\ every\ x \in F\\(5)To\ every\ x\in F\ corresponds\ an\ element\ -x\in F\ such\ that\ x+(-x)=0\\\\(M)\ Axioms\ for\ multiplication\\(1)\ if\ x\in F\ and\ y\in F,then\ their\ product\ xy\ is\ in\ F \\(2)Commutative:xy=yx\\(3)Associative:(xy)z=x(yz) \\(4)F\ contains\ an\ element\ 1≠0\ such\ that\ 1x=x\ for\ every\ x\in F  \\(5)if\ x\in F\ and\ x≠0\ then\ there\ exists\ an\ element\ 1/x\in F\ such\ that x(1/x)=1\\\\(D)\ The\ distributive\ law\\x(y+z)=xy+xz\end{matrix}</script><h3 id="证明-2x2-4"><a href="#证明-2x2-4" class="headerlink" title="证明 2x2=4"></a>证明 2x2=4</h3><script type="math/tex; mode=display">\begin{matrix}公理和定义：域的加法公理，乘法公理和分配律\\1+1=2\\1+2=3\\1+3=4\\证明：2·2=2·(1+1)\ [2的定义]\\=2·1+2·1\ [分配律]\\=2+2\ [乘法公理]\\=2+1+1\ [2的定义]\\=3+1\ [3的定义]\\=4\ [4的定义]\\\end{matrix}</script><h3 id="证明-x-y-x-z-gt-y-z"><a href="#证明-x-y-x-z-gt-y-z" class="headerlink" title="证明 x+y=x+z=&gt;y=z"></a>证明 x+y=x+z=&gt;y=z</h3><script type="math/tex; mode=display">\begin{matrix}y=0+y\ [加法公理]\\=-x+x+y\ [加法公理]\\=-x+(x+y)\ [加法公理]\\=-x+(x+z\ [给出的条件]\\=(-x+x)+z\ [加法公理]\\=0+z\ [加法公理]\\ =z\end{matrix}</script><h2 id="有序域"><a href="#有序域" class="headerlink" title="有序域"></a>有序域</h2><p>有序集是元素可比较大小的集合，域是元素符合域公理的集合，如果一个集合有序，且符合域公理，且符合</p><p>(i）y＜z =&gt; x+y&lt;x+z</p><p>(ii) x&gt;0 and y&gt;0 =&gt; xy&gt;0</p><p>称该集合为有序域</p><script type="math/tex; mode=display">\begin{matrix}五个推论\\(a) if\ x>0\ then -x<0\ and\ vice\ versa \\if\ x>0\ then 0=-x+x>-x+0,so\ that\ -x<0 \\if\ x<0\ then 0=-x+x<-x+0,so\ that\ -x>0 \\(b) if\ x>0\ and\ y<z\ then\ xy<xz \\since\ z>y\ we\ have\ z-y>y-y=0,hence\ x(z-y)>0 \\and\ therefore\ xz=x(z-y)+xy>0+xy=xy\\(c) if\ x<0\ and\ y<z\ then\ xy>xz \\证明略，用到前面的推论\\(d) if\ x≠0\ then\ x^2>0.\ In\ particular, 1>0\\证明略，用到前面的推论\\(e) if\ 0<x<y\ then\ 0<1/y<1/x\\if\ we\ multiply\ both\ sides\ of\ the\ inequality\ x<y\ by\ (1/x)(1/y) \\we\ obtain\ 1/y<1/x.\\\end{matrix}</script><h3 id="证明-1-gt-0"><a href="#证明-1-gt-0" class="headerlink" title="证明 1&gt;0"></a>证明 1&gt;0</h3><script type="math/tex; mode=display">\begin{matrix}公理：1≠0，1^2=1·1=1\\x≠0，只要证x^2>0即可得1>0\ [有序域公理]\\①x>0，x^2>0\ [有序域公理]\\②x<0，证-x>0:x<-x+x，x-x<-x+x-x，0<-x \\证x^2=(-x)^2:\\x-x=x-x => x(x-x)=-x(x-x)\ [推论0x=x] \\x^2+x(-x)=(-x)^2+x(-x) =>x^2=(-x)^2\ [推论x+y=x+z=>y=z] \\故x^2>0,1>0 \\\end{matrix}</script><h2 id="实数的构建-Dedekind-Cuts"><a href="#实数的构建-Dedekind-Cuts" class="headerlink" title="实数的构建 Dedekind Cuts"></a>实数的构建 Dedekind Cuts</h2><p>100多年前，实数的存在问题才被戴德金，柯西，康托等人解决。</p><p>戴德金分割，构建实数集</p><p>Theorem 1.19：There exists an ordered field R which has the least-upper-bound property. Moreover，R contains Q as a subfield. 存在一个有序域R,有最小上界性质，且可比数集是它的子集。</p><p>证明共9步，没写完。</p><p>证明：第一步，定义实数集合的元素为分割</p><script type="math/tex; mode=display">\begin{matrix}Step1: The\ members\ of\ R\ will\ be\ certain\ subset\ of\ Q, call\ cuts\\符号：p,q,r\in Q\ \ \ \ \alpha,\beta,\gamma:cuts\\def:\alpha \subset Q \\(i)\ \alpha\ is\ not\ empty, and\ \alpha \ne Q \\(ii)\ if\ p\in\alpha,q\in Q\ and\ q<p,then\ q\in\alpha，即\alpha中一点的左侧全部在\alpha中 \\(iii)\ if\ p\in\alpha,then\ p<r\ for\ some\ r\in\alpha，即一个分割没有最大的元素 \\example: 2<->\{p|p\in Q,p<2\},\sqrt2<->\{p|p\in Q,p<0\ or\ p^2<2\}\end{matrix}</script><p>第二步：定义分割的真包含关系为实数的小于关系，则实数集满足有序集的条件，实数集是一个有序集</p><script type="math/tex; mode=display">\begin{matrix}Step2: def\ \alpha<\beta:\alpha\subsetneq\beta\\\alpha,\beta,\gamma\in R,R\ is\ an\ ordered\ set\\(i)\ \alpha<\beta,\alpha=\beta,\beta<\alpha\\(ii)\ \alpha<\beta,\beta<\gamma=>\alpha<\gamma\\example:\sqrt2<2<=>\alpha\subsetneq\beta\\\alpha\{p|p\in Q,p<0\ or\ p^2<2\} \\\beta\{p|p\in Q, p<2\}\end{matrix}</script><p>第三步，证明实数集有最小上界性质</p><script type="math/tex; mode=display">\begin{matrix}A\ nonempty,A \subseteq R\\\beta\ is\ an\ upper\ bound\ of\ A\\\alpha\in A,\gamma=\bigcup_{\alpha\in A}\alpha \end{matrix}</script><p>第四步，证明实数集符合域的加法公理</p><p>第五步，证明R符合有序域的性质1</p><p>第六步，证明R+满足域的乘法公理，分配律和有序域的性质2</p><p>第七步，拓展R满足域的乘法公理和分配律</p><p>第八步，定义可比分割与可比数一一对应</p><p>第九步，Q是R的真子集</p><p>注：完整过程就先不写了,太多了。</p><h3 id="自己的思考-数的发展"><a href="#自己的思考-数的发展" class="headerlink" title="自己的思考-数的发展"></a>自己的思考-数的发展</h3><p><strong>从朴素的公认的自然数，加减乘除运算；</strong></p><p><strong>到古希腊人的尺规作图产生可比数(通过相似)；</strong></p><p><strong>再到尺规作图产生不可比数(勾股定理或相似)；</strong></p><p><strong>再到使用集合，有序集合，域，有序域及其公理的定义，构建了数集的公理化体系，使实数集在可比数集之上产生。</strong></p><h2 id="实数的阿基米德性质"><a href="#实数的阿基米德性质" class="headerlink" title="实数的阿基米德性质"></a>实数的阿基米德性质</h2><script type="math/tex; mode=display">if\ x\in R,y\in R,and\ x>0,then\ there\ is\ a\ positive\ integer\ n\ such\ that\ nx>y.\\</script><script type="math/tex; mode=display">\begin{matrix}证明：令A=\{nx|x\in R,x>0,n\in Z^+\}\\if\ the\ theorem\ was\ false,\ then\ p\in A,p\le y,y\in R\\so\ y\ is\ an\ upper\ bound\ of\ A.\\so\ A\ has\ a\ least\ upper\ bound\ \alpha\ in\ R. \\since\ x>0,\alpha-x<\alpha,\alpha-x不是A的上界\\所以\alpha-x<mx\ for\ some\ positive\ integer\ m.\\故 \alpha<(m+1)x\in A\\由\alpha是A的最小上界推出的结论与\alpha是A的上界矛盾，故该定理成立\end{matrix}</script><h2 id="可比数在实数集合中是稠密的"><a href="#可比数在实数集合中是稠密的" class="headerlink" title="可比数在实数集合中是稠密的"></a>可比数在实数集合中是稠密的</h2><script type="math/tex; mode=display">if\ x\ in R,y\in R, and\ x<y,then\ there\ exists\ a\ p\in Q\ such\ that\ x<p<y</script><script type="math/tex; mode=display">\begin{matrix}证明：因为y>x故y-x>0,根据阿基米德性质，有n(y-x)>1,n\in Z^+\\因为n>0故{1\over n}也＞0，根据阿基米德性质,有m_1{1\over n}>x,m_2{1\over n}>-x,m1、m2\in Z^+\\即m_1<nx<m_2,故m-1≤nx<m,m\in Z\\由n(y-x)>1和m-1≤nx<m可得nx<m≤nx+1<ny\\故：x<{m\over n}<y\end{matrix}</script><h1 id="二、李永乐讲戴德金分割"><a href="#二、李永乐讲戴德金分割" class="headerlink" title="二、李永乐讲戴德金分割"></a>二、李永乐讲戴德金分割</h1><p>自然，直观，美！</p><p>人们发现可比数之间有空隙，戴德金分割是对可比数集的分割，通过这种分割，找到了所有可比数的空隙——不可比数。定义实数集由所有的可比数及不可比数构成。此时，<strong>进行同样的分割</strong>，可比数集的空隙(不可比数)已经在实数集中，不会切出不在实数中的数，所以说实数是完备的(连续的)。</p><h2 id="可比数"><a href="#可比数" class="headerlink" title="可比数"></a>可比数</h2><p>1.什么是可比数？p=m/n,m和n都是整数且n≠0，称p是可比数。</p><p>2.可比数的稠密性：任意两个可比数之间有无穷多个可比数。</p><p>从数轴的角度看，毕达哥拉斯认为，数轴上的所有点都是可比数，可比数是稠密的，也是连续的 。</p><p>3.有理数是不完备的(不连续的)</p><p>如何定义不可比数是一个困难的问题，以至于很多年来有很多数学家拒绝承认不可比数是数。</p><p>19世纪末20世纪初的时候，轰轰烈烈的数学公理化运动开展之后，它才真正解决了。从第一次发现不可比数，造成第一次数学危机，到不可比数如何定义的问题被解决掉，一共花了两千多年。</p><h2 id="数学公理化"><a href="#数学公理化" class="headerlink" title="数学公理化"></a>数学公理化</h2><p>从第一次数学危机，人们讨论什么是根号2，第二次数学危机，人们讨论什么是无穷小。人们就觉得数要有基础，你必须告诉我数到底是什么。</p><p>通过戴德金的方法——戴德金分割，来思考一下数学的公理化。</p><p>1.戴德金分割：</p><p>我们认为，数轴上有无穷多个可比数，我们称所有可比数的集合为Q，我们在数轴上切一刀，将可比数集合分成两段，一个是集合A，一个是集合B。</p><p>①分割的A与B，A∩B=∅，AUB=Q，即A和B没有重复元素，A和B包含所有的可比数。</p><p>②a∈A，b∈B，则a&lt;b，即集合A在集合B的左侧</p><p>2.分割结果：</p><p>①A中有最大，B中无最小</p><p><img src="/2021/12/13/%E5%BE%AE%E7%A7%AF%E5%88%86/image-20211219192124237.png" alt="image-20211219192124237"></p><p>②A中无最大，B中有最小</p><p><img src="/2021/12/13/%E5%BE%AE%E7%A7%AF%E5%88%86/image-20211219192209737.png" alt="image-20211219192209737"></p><p>③A中无最大，B中无最小</p><p><img src="/2021/12/13/%E5%BE%AE%E7%A7%AF%E5%88%86/image-20211219192416595.png" alt="image-20211219192416595"></p><p>④A中有最大，B中有最小(不存在)</p><p><img src="/2021/12/13/%E5%BE%AE%E7%A7%AF%E5%88%86/image-20211219192604841.png" alt="image-20211219192604841"></p><p>共有三种情况，在①和②中，切一刀，分割点是可比数，A和B有一个端点是可比数。在③中，切一刀，分割点不是可比数，A和B都无端点，说明这一刀从可比数的空隙钻过去了。怎么填补这个空隙，戴德金说我们定义一种数叫不可比数，不可比数就是可比数的空隙。</p><p>3.可比数的全体分割构成实数</p><p>4.戴德金推出这样一个定理：对实数进行分割，分割点只有①②两种情况，即A和B有一个端点是实数。切一刀，不可能切出一个其它的数出来，因此实数是完备的(连续的)。</p><h2 id="证明0-999…-1"><a href="#证明0-999…-1" class="headerlink" title="证明0.999…=1"></a>证明0.999…=1</h2><p>1.分割Q为A和B，定义0.999…(即割点为0.999…)，分割Q为C和D，定义1</p><p>A={x|x∈Q，x&lt;0.999…}，C={x|x∈Q，x&lt;1}</p><p>要证明0.999…=1，即证明这两种分割是一样的，即证这两个集合是一样的</p><p>2.证明A=C</p><p>①设t∈A，则t&lt;0.999…，根据十进制数定义，0.999…不可能比1大，故0.999…≤1，t&lt;0.999…则t&lt;1，即t∈C。故A包含于C。</p><p>②设t∈C，t<1，t=q\p<1=>p&lt;q ,p和q∈正整数集</1，t=q\p<1=></p><p>1-t=1-(p/q)=(q-p)/q≥1/q</p><p>存在n，使得10^n&gt;q=&gt;1/10^n＜1/q</p><p>1-t≥1/q＞1/10^n =&gt; t&lt;1-1/10^n=0.999…9(小数点后n位9)&lt;0.999…，故 t∈A，C包含于A</p><p>综上所述，A=C，0.999…=1</p><h1 id="三、微积分的基石是什么？陈金次-太长了，东西太多了，而且是倒序讲，为什么不顺序讲呢？虽然很系统，但超出了我能接受的范围，不符合我的口味。"><a href="#三、微积分的基石是什么？陈金次-太长了，东西太多了，而且是倒序讲，为什么不顺序讲呢？虽然很系统，但超出了我能接受的范围，不符合我的口味。" class="headerlink" title="三、微积分的基石是什么？陈金次 太长了，东西太多了，而且是倒序讲，为什么不顺序讲呢？虽然很系统，但超出了我能接受的范围，不符合我的口味。"></a>三、微积分的基石是什么？陈金次 太长了，东西太多了，而且是倒序讲，为什么不顺序讲呢？虽然很系统，但超出了我能接受的范围，不符合我的口味。</h1><p>由微积分基本定理来溯源看看</p><p><strong>微积分第一基本定理</strong></p><script type="math/tex; mode=display">f在[a,b]上连续，令G(x)=\int_a^x{f(t)}dt，则G'(x)=f(x)</script><p><strong>微积分第二基本定理</strong></p><script type="math/tex; mode=display">f在[a,b]上连续，若F'(x)=f(x)\ \ \forall x\in[a,b]，则\int_a^bf(x)=F(b)-F(a)</script><script type="math/tex; mode=display">\begin{matrix}第一\Rightarrow第二\\证：令G(x)=\int_a^xf(t)dt，由第一，G'(x)=f(x)=F'(x)\\∴(G-F)'=0\ \ \forall x\in[a,b]\Rightarrow G-F\equiv constant\ on\  [a,b]\\F=G+C\\F(b)-F(a)=G(b)-G(a)=\int_a^bf(x)dx\\\end{matrix}</script><p><strong>问题：</strong></p><script type="math/tex; mode=display">\begin{matrix}1.\ f在[a,b]上连续，为何Riemann可积分？\\2.\ 第一基本定理的溯源\\3.\ \phi在[a,b]上连续，\phi'(x)=0 \Rightarrow \phi \equiv constant\end{matrix}</script><p><strong>Mean Value Theorem</strong></p><p><strong>均值定理（微分）</strong></p><script type="math/tex; mode=display">\begin{matrix}f在[a,b]上连续\\在（a,b）上可导\\则\exists c\in(a,b),使 {f(b)-f(a)\over b-a}=f'(c)\end{matrix}</script><p><strong>均值定理（积分）</strong></p><script type="math/tex; mode=display">\begin{matrix}f在[a,b]上连续\\则\exists c\in(a,b),使 {1 \over b-a}\int_a^bf(x)dx=f(c)\end{matrix}</script><p><strong>问题3的回答</strong></p><script type="math/tex; mode=display">\begin{matrix}\phi(x)-\phi(y)=\phi'(z)(x-y)=0\\z是介于x和y之间的某点\\\forall x,y\in[a,b]\\∴\phi\equiv constant\end{matrix}</script><p>连续函数中间值定理，最大最小值定理</p><p><strong>连续函数</strong></p><script type="math/tex; mode=display">\begin{matrix}Def:f在点x_0连续\\若 \lim\limits_{x\rightarrow x_0}f(x)=f(x_0)\\Def:f在[a,b]上连续\\若f在x点连续，\forall x \in [a,b]\end{matrix}</script><p><strong>实数集的上界和最小上界</strong></p><script type="math/tex; mode=display">\begin{matrix}设R为实数集，S\subset R\\称\alpha为S的上界，若x\le\alpha\ \ \forall x\in S\\称\alpha为S的最小上界，若\\(i)\alpha为S的上界\\(ii)若\beta为S的上界，则\alpha\le\beta\end{matrix}</script><p><strong>实数的完备性(completeness of real numbers)(实数无坑无洞)</strong></p><script type="math/tex; mode=display">\begin{matrix}S\subset R \\S有上界 \\则S有最小上界(未必在S内) \\例如：S=(0,1)，最小上界1，1\notin S\\S=(0,1]，最小上界1，1\in S\\\end{matrix}</script><p><strong>有理数不具备完备性(有理数坑坑洞洞)</strong></p><script type="math/tex; mode=display">\begin{matrix}例 S=\{x|x\in Q,x \gt 0 且 x^2 \lt 2 \}\\最小上界\sqrt2,但\sqrt2\notin Q\end{matrix}</script><p><strong>实数完备性的另一陈述</strong></p><script type="math/tex; mode=display">\begin{matrix}\{a_n\}\subset R \\(i)\ \{a_n\}为递增，a_n \le a_{n+1} \\(ii)\ \{a_n\}上方有界，及\exists k\in R，使a_n\le k \ \ \forall n \\则\lim\limits_{n\rightarrow\infty}a_n存在于R中 \\即\ \exists l\in R,使\lim\limits_{n\rightarrow\infty}a_n=l\end{matrix}</script><h1 id="实数的构建-陈金次"><a href="#实数的构建-陈金次" class="headerlink" title="实数的构建 陈金次"></a>实数的构建 陈金次</h1><p>什么是实数？</p><p>实数为什么有完备性？</p><p>1860年 德国数学家 R Dedekin</p><p>实数完备性与极限</p><script type="math/tex; mode=display">\begin{matrix}例：求 \sqrt{2\sqrt{2\sqrt{2\sqrt{2…}}}}\\令\ x=\sqrt{2\sqrt{2\sqrt{2\sqrt{2…}}}} \\则\ x^2=2\sqrt{2\sqrt{2\sqrt{2\sqrt{2…}}}} \\∴\ x^2=2x \\x(x-2)=0 \\x≠0 \\∴\ x=2\end{matrix}</script><p>数学上严格的陈述如下</p><script type="math/tex; mode=display">\begin{matrix}令 a_1=\sqrt2, a_2=\sqrt{2a_1}, a_3=\sqrt{2a_2},... \\(i) 试证 \lim\limits_{n\rightarrow\infty}a_n存在 \\(ii) 求此极限\end{matrix}</script><script type="math/tex; mode=display">\begin{matrix}解: (i)\ a_1=\sqrt2 \\ a_2=\sqrt{2a_1}\gt a1 \\a_3=\sqrt{2a_2}\gt a2 \\.\\.\\.\\a_{n+1}\gt a_n \\∴ a_n 递增\\\\(ii)\ a_n\lt 2\ \ \forall n\end{matrix}</script><p>最大正整数不存在</p><script type="math/tex; mode=display">\begin{matrix}某人证明1为最大正整数证：设n为最大正整数 \\则\ n\ge n^2 \\n(1-n)\ge 0 \\n \gt 0\ ∴1-n\ge 0，n\le1 \\且n为正整数，n\ge 1 \\故\ n=1 \\\end{matrix}</script><h2 id="实数到底是什么？"><a href="#实数到底是什么？" class="headerlink" title="实数到底是什么？"></a>实数到底是什么？</h2><h3 id="Dedekind-cut-戴德金分割"><a href="#Dedekind-cut-戴德金分割" class="headerlink" title="Dedekind cut 戴德金分割"></a>Dedekind cut 戴德金分割</h3><p>Dedekind（1831-1916）</p><p>1860年 实数的建构</p><p>他把可比数分成两个集合，所有的分割产生实数</p><script type="math/tex; mode=display">\begin{matrix}Q：有理数 \\Q = A U B \\A，B ≠ ∅ \\A：无蛀下达-\infty，即\exists x\in A\ 使\ y\lt x\ 则 y\in Q \\A无最大元素 \\B=Q-A \\(A,B)称为对可比数的一个Cut \\所有的Cut就叫做实数 \\A1=\{x|x\in Q,x\lt 3\},B1=\{x|x\in Q,x\ge 3\} \\A1,B1决定3，可比数 \\A2=\{x|x\in Q,x^2\lt 2 或x\lt0\},B1=\{x|x\in Q,x^2\ge 2,且x\gt0\} \\A2,B2决定\sqrt2，不可比数 \\\end{matrix}</script><p><strong>可比数集合A无最大元素，可比数集合B若有最小元素，则该Cut决定一个可比数，可比数集合若无最小元素，则该Cut决定一个不可比数</strong></p><p>Cut处理四则运算稍繁，故后人修改，以有上界的可比增数列来定义实数</p><script type="math/tex; mode=display">\begin{matrix}X=\{x_1,x_2,x_3,...\}，(i)x_n\le x_{n+1}，(2)\exists k\ 使\ x_n\le k\ \ \forall n \\Y=\{y_1,y_2,y_3,...\}，(i)y_n\le y_{n+1}，(2)\exists k\ 使\ y_n\le k\ \ \forall n \\以X^\bot表示X的一切上界，X^\bot=\{\alpha|\alpha\in Q且\alpha为X的上界\} \\若X^\bot=Y^\bot \\称X\sim Y同一个Class \\令F为一切Q中有界增数列 \\\sim把F分成许多班级S \\S即为实数\end{matrix}</script><h3 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h3><script type="math/tex; mode=display">\begin{matrix}\xi 、 \eta \in R \\在 \xi所相应的班级中任选一位同学\ X=\{x_1,x_2,x_3,...\} \\在 \eta所相应的班级中，任选一位同学\ Y=\{y_1,y_2,y_3,...\} \\则 X+Y=\{ x_1+y_1,x_2+y_2,x_3+y_3,...\}表以可比增数列，上方有界 \\X+Y所属的班级\zeta \\定义:\ \xi + \eta = \zeta\end{matrix}</script><h3 id="well-defined问题"><a href="#well-defined问题" class="headerlink" title="well-defined问题"></a>well-defined问题</h3><script type="math/tex; mode=display">\begin{matrix}X,X'同班，决定\xi \\Y,Y'同班，决定\eta \\问 X+Y 与 X'+Y'同班吗？即(X+Y)^\bot是否等于(X'+Y')^\bot? \\令X=\{x_1,x_2,x_3,...\},Y=\{y_1,y_2,y_3,...\} \\X'=\{x_1',x_2',x_3',...\},Y'=\{y_1',y_2',y_3',...\} \\则 X=Y=\{ x_1+y_1,x_2+y_2,x_3+y_3,...\}\\X'+Y'=\{ x_1'+y_1',x_2'+y_2',x_3'+y_3',...\} \\设 \alpha为X+Y的上界，即x_n+y_n\le \alpha\ \ \forall n \\固定k\end{matrix}</script><h2 id="区间套定理"><a href="#区间套定理" class="headerlink" title="区间套定理"></a>区间套定理</h2><h2 id="B-W定理"><a href="#B-W定理" class="headerlink" title="B-W定理"></a>B-W定理</h2><h2 id="连续函数中间值，最大最小值"><a href="#连续函数中间值，最大最小值" class="headerlink" title="连续函数中间值，最大最小值"></a>连续函数中间值，最大最小值</h2><h2 id="均值定理"><a href="#均值定理" class="headerlink" title="均值定理"></a>均值定理</h2><h2 id="微积分第一第二定理"><a href="#微积分第一第二定理" class="headerlink" title="微积分第一第二定理"></a>微积分第一第二定理</h2><h1 id="四、Stepp学院谈不可比数和极限"><a href="#四、Stepp学院谈不可比数和极限" class="headerlink" title="四、Stepp学院谈不可比数和极限"></a>四、Stepp学院谈不可比数和极限</h1><h2 id="不可比数"><a href="#不可比数" class="headerlink" title="不可比数"></a>不可比数</h2><h3 id="无理数的发现"><a href="#无理数的发现" class="headerlink" title="无理数的发现"></a>无理数的发现</h3><p>毕达哥拉斯：All is number 万物皆数(可比数)，认为数轴由无数个可比数构成，没有空隙。</p><p>Hippasus：数轴似乎不是只由可比数构成的。<img src="/2021/12/13/%E5%BE%AE%E7%A7%AF%E5%88%86/image-20211215155008508.png" alt="image-20211215155008508"></p><p>如果数轴是只有可比数构成的数轴，那么f(x)=x^2-2与数轴就无交点</p><p><img src="/2021/12/13/%E5%BE%AE%E7%A7%AF%E5%88%86/image-20211215155241857.png" alt="image-20211215155241857"></p><h3 id="证明根号2是不可比数"><a href="#证明根号2是不可比数" class="headerlink" title="证明根号2是不可比数"></a>证明根号2是不可比数</h3><h4 id="代数方法："><a href="#代数方法：" class="headerlink" title="代数方法："></a>代数方法：</h4><script type="math/tex; mode=display">\begin{matrix}反证法：假设\sqrt2={a\over b},a和b都是整数且最大公共因数为1\\两边平方：2={a^2 \over b^2} \Rightarrow a^2=2b^2\\\Rightarrow a^2是偶数 \Rightarrow a是偶数\\\Rightarrow a=2k,k为大于1的整数 \\\Rightarrow (2k)^2=2b^2 \Rightarrow b^2=2k^2 \Rightarrow b是偶数 \\a,b都是偶数，最大公因数不为1，与假设矛盾。 \\\sqrt2为不可比数\end{matrix}</script><h4 id="几何方法"><a href="#几何方法" class="headerlink" title="几何方法"></a>几何方法</h4><p><img src="/2021/12/13/%E5%BE%AE%E7%A7%AF%E5%88%86/image-20211215162458981.png" alt="image-20211215162458981"></p><h3 id="可比数不可比数的封闭性和稠密性"><a href="#可比数不可比数的封闭性和稠密性" class="headerlink" title="可比数不可比数的封闭性和稠密性"></a>可比数不可比数的封闭性和稠密性</h3><h4 id="可比数的封闭性"><a href="#可比数的封闭性" class="headerlink" title="可比数的封闭性"></a>可比数的封闭性</h4><p>可比数加减乘除运算之后还是可比数</p><p><img src="/2021/12/13/%E5%BE%AE%E7%A7%AF%E5%88%86/image-20211215164038842.png" alt="image-20211215164038842"></p><h4 id="不可比数不具有封闭性"><a href="#不可比数不具有封闭性" class="headerlink" title="不可比数不具有封闭性"></a>不可比数不具有封闭性</h4><p>不可比数加减乘除运算之后不一定是不可比数</p><p><img src="/2021/12/13/%E5%BE%AE%E7%A7%AF%E5%88%86/image-20211215164133307.png" alt="image-20211215164133307"></p><h4 id="可比数的稠密性"><a href="#可比数的稠密性" class="headerlink" title="可比数的稠密性"></a>可比数的稠密性</h4><p>两可比数之间总能找到新的可比数</p><p>整数就不具有稠密性，因为两个整数之间不总能找到新的整数</p><p><img src="/2021/12/13/%E5%BE%AE%E7%A7%AF%E5%88%86/image-20211215164544168.png" alt="image-20211215164544168"></p><h4 id="不可比数的稠密性"><a href="#不可比数的稠密性" class="headerlink" title="不可比数的稠密性"></a>不可比数的稠密性</h4><p>两不可比数之间总能找到新的不可比数</p><p><img src="/2021/12/13/%E5%BE%AE%E7%A7%AF%E5%88%86/image-20211215164932630.png" alt="image-20211215164932630"></p><h2 id="极限，x趋于某点时，函数的界限。-左极限，x从左侧趋于某点时，函数的界限。右极限，x从右侧趋于某点时，函数的界限。"><a href="#极限，x趋于某点时，函数的界限。-左极限，x从左侧趋于某点时，函数的界限。右极限，x从右侧趋于某点时，函数的界限。" class="headerlink" title="极限，x趋于某点时，函数的界限。 左极限，x从左侧趋于某点时，函数的界限。右极限，x从右侧趋于某点时，函数的界限。"></a>极限，x趋于某点时，函数的界限。 左极限，x从左侧趋于某点时，函数的界限。右极限，x从右侧趋于某点时，函数的界限。</h2><h3 id="切线斜率问题"><a href="#切线斜率问题" class="headerlink" title="切线斜率问题"></a>切线斜率问题</h3><p><img src="/2021/12/13/%E5%BE%AE%E7%A7%AF%E5%88%86/image-20211225210347863.png" alt="image-20211225210347863"></p><p>求过曲线上一点的切线P的斜率。</p><p>使用三角函数可以证明：互相垂直的直线，且直线不在坐标轴上，斜率乘积为-1。</p><p>但你不一定知道垂直于切线的直线的斜率。</p><p>我们知道，两点确定一条直线，知道两个点的坐标，才能知道直线的斜率，可切线只知道一个点，让人不知道怎么处理才好。</p><p>极限的概念就是为了解决这种切线问题所产生的。</p><h3 id="退一步，从割线开始思考"><a href="#退一步，从割线开始思考" class="headerlink" title="退一步，从割线开始思考"></a>退一步，从割线开始思考</h3><p>假设曲线上有不同于P点的一点Q，则过PQ两点的S为曲线的割线，Q越接近P，割线S就越接近切线T。</p><p>当Q点非常非常接近P点的时候，割线S几乎和切线T重叠。也就是说切线T是割线S往切线T逼近的极限，或者说界限(bound)。</p><p>我们设法求出割线S的界限，也就找到了切线T。这个求界限的方法，也就是极限概念想要深入探讨的主题。</p><h3 id="看5个函数，来认识极限的定义"><a href="#看5个函数，来认识极限的定义" class="headerlink" title="看5个函数，来认识极限的定义"></a>看5个函数，来认识极限的定义</h3><p><img src="/2021/12/13/%E5%BE%AE%E7%A7%AF%E5%88%86/image-20211225213212205.png" alt="image-20211225213212205"></p><p>x从左趋近1，从右趋近1，看曲线f(x)的行为，也从左从右趋近1/2</p><p><img src="/2021/12/13/%E5%BE%AE%E7%A7%AF%E5%88%86/image-20211225213435362.png" alt="image-20211225213435362"></p><p>x从左从右趋于1时f(x)的值，无关f(1)的值，f(x)也从左从右趋进1/2</p><p><img src="/2021/12/13/%E5%BE%AE%E7%A7%AF%E5%88%86/image-20211225213721887.png" alt="image-20211225213721887"></p><p>小结：</p><p><img src="/2021/12/13/%E5%BE%AE%E7%A7%AF%E5%88%86/image-20211225214114020.png" alt="image-20211225214114020"></p><p>1.x趋于一点时，f(x)趋于的极限值与该点处的值无关。</p><p>2.若h(x)和f(x)仅在点a处的值不同，x趋于点a，h(x)和f(x)趋于的极限值相同</p><p>3.x趋于点a，f(x)趋于L，等同于，x从左趋点a，f(x)趋于L 且 x从右趋近点a，f(x)趋于L。</p><p><img src="/2021/12/13/%E5%BE%AE%E7%A7%AF%E5%88%86/image-20211225215058158.png" alt="image-20211225215058158"></p><p>x从左从右趋于0，f(x)从左从右趋于0。</p><p>f(x)值域是和定义域中的x一一对应的集合，的左上界和右下界极限为0，定义域从0处分为左右，f(x)也从f(0)=0处分为左右，f(x)左边的最小上界为0，f(x)右边的最小下界为0(实数有最小上界和最小下界)</p><p><img src="/2021/12/13/%E5%BE%AE%E7%A7%AF%E5%88%86/image-20211225215418524.png" alt="image-20211225215418524"></p><p>x从左侧趋于-1，f(x)在-1左侧无定义，f(x)的值在-1左侧没有行为，故x从左侧趋于-1时，f(x)没有bound(极限)，称f(x)没有左极限。</p><p>x从右侧趋于-1，f(x)的值趋于0，称x趋于-1，f(x)右极限为0</p><h3 id="回到求切线斜率问题"><a href="#回到求切线斜率问题" class="headerlink" title="回到求切线斜率问题"></a>回到求切线斜率问题</h3><p><img src="/2021/12/13/%E5%BE%AE%E7%A7%AF%E5%88%86/image-20211225221230116.png" alt="image-20211225221230116"></p><p>分子和分母约去x-1后的函数，与m(x)不是同一个函数，但是x趋于1时两函数的界限相同(替代定理)</p><h2 id="极限的ε-δ定义"><a href="#极限的ε-δ定义" class="headerlink" title="极限的ε-δ定义"></a>极限的ε-δ定义</h2><h3 id="Fermat和Newton使用无穷小量o求切线斜率"><a href="#Fermat和Newton使用无穷小量o求切线斜率" class="headerlink" title="Fermat和Newton使用无穷小量o求切线斜率"></a>Fermat和Newton使用无穷小量o求切线斜率</h3><p><img src="/2021/12/13/%E5%BE%AE%E7%A7%AF%E5%88%86/image-20211225222115992.png" alt="image-20211225222115992"></p><h3 id="Stepp学院的直观求法"><a href="#Stepp学院的直观求法" class="headerlink" title="Stepp学院的直观求法"></a>Stepp学院的直观求法</h3><p><img src="/2021/12/13/%E5%BE%AE%E7%A7%AF%E5%88%86/image-20211225222249435.png" alt="image-20211225222249435"></p><h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><p>无穷小量o，先是o≠0约分，约分后又说o=0。</p><p>定义域中的x，先是x≠1约分，约分后又说x=1。</p><p>虽然这样做，最后的结果是对的，应用上也取得成功，但这个做法是有矛盾的。</p><h3 id="极限的严谨的定义"><a href="#极限的严谨的定义" class="headerlink" title="极限的严谨的定义"></a>极限的严谨的定义</h3><p>Cauchy，Bolzano，weierstrass，Cantor等人给出了极限的严格定义，无穷小量的争议和矛盾才解决了，微积分才可以在一个稳固的基础上做发展。</p><p><img src="/2021/12/13/%E5%BE%AE%E7%A7%AF%E5%88%86/image-20211225223208924.png" alt="image-20211225223208924"></p><p>δ表示与点a的距离，ε表示与f(a)的误差</p><p><img src="/2021/12/13/%E5%BE%AE%E7%A7%AF%E5%88%86/image-20211225223347613.png" alt="image-20211225223347613"></p><p>1.将过去的趋近，逼近，靠近这样的动态描述，用ε和δ两个常数来静态的描述。</p><p>2.过去是现有x趋于点a，才有x趋于点a，f(x)的界限为L。变成了先有y轴上的误差范围ε，再有x轴上的距离范围δ。所以对于任意的ε，只要可以找到满足条件的δ，这个定义就保证，x趋于点a时函数的极限值存在。</p><p>3.在这个定义里面很清楚的规定了，x≠a，x与a相距δ</p><h3 id="使用极限的严格定义，证明某函数的x趋于点a的极限为L"><a href="#使用极限的严格定义，证明某函数的x趋于点a的极限为L" class="headerlink" title="使用极限的严格定义，证明某函数的x趋于点a的极限为L"></a>使用极限的严格定义，证明某函数的x趋于点a的极限为L</h3><p><img src="/2021/12/13/%E5%BE%AE%E7%A7%AF%E5%88%86/image-20211225223725398.png" alt="image-20211225223725398"></p><p><img src="/2021/12/13/%E5%BE%AE%E7%A7%AF%E5%88%86/image-20211225224927657.png" alt="image-20211225224927657"></p><p><img src="/2021/12/13/%E5%BE%AE%E7%A7%AF%E5%88%86/image-20211225225225741.png" alt="image-20211225225225741"></p><h2 id="补充：函数在某点处极限存在，连续，可导"><a href="#补充：函数在某点处极限存在，连续，可导" class="headerlink" title="补充：函数在某点处极限存在，连续，可导"></a>补充：函数在某点处极限存在，连续，可导</h2><p><img src="/2021/12/13/%E5%BE%AE%E7%A7%AF%E5%88%86/image-20211225231107059.png" alt="image-20211225231107059"></p><h1 id="五、林群院士谈微积分"><a href="#五、林群院士谈微积分" class="headerlink" title="五、林群院士谈微积分"></a>五、林群院士谈微积分</h1><p>假传万卷书，真传一案例。高铁瞬时速度，某一时刻计算速度是不行的，因为时间为0，路程也为0，速度为 0比0。必须有很小的一段时间，才有路程，才有路程比时间，尽管速度会发生很小的变化，但变化可以忽略掉。</p><h1 id="六、中科大-李柏坚"><a href="#六、中科大-李柏坚" class="headerlink" title="六、中科大 李柏坚"></a>六、中科大 李柏坚</h1><h2 id="极限"><a href="#极限" class="headerlink" title="极限"></a>极限</h2><h3 id="数列的极限"><a href="#数列的极限" class="headerlink" title="数列的极限"></a>数列的极限</h3><script type="math/tex; mode=display">a_n={1\over 2^n},\ \lim_{n->\infty}a_n=0</script><p>n取的值越大(与无穷大的距离越小)，an的值与的0差距越小。另一种说法是当n趋于0时，an的值趋于0，这种说法使人感觉n是随时间运动的，n随着时间变大，an随着n变大而变小，不如第一种说法，只是静态地取一个值，没有时间和运动的感觉。</p><h3 id="函数的极限"><a href="#函数的极限" class="headerlink" title="函数的极限"></a>函数的极限</h3><p>自变量取的值与某数的距离越小(但不与该数相等)，函数(含变数之数)与极限值的距离越小。 </p><h3 id="极限的严格定义"><a href="#极限的严格定义" class="headerlink" title="极限的严格定义"></a>极限的严格定义</h3><p><img src="/2021/12/13/%E5%BE%AE%E7%A7%AF%E5%88%86/image-20220111191059047.png" alt="image-20220111191059047"></p><p>Given epsilon&gt;0，choose δ=…，if 0&lt;|x-c|&lt;δ, =&gt; |f(x)-L|<epsilon，称x->c, f(x)-&gt;L（x的取值于c的距离越小，f(x)的值与L的距离越小）</epsilon，称x-></p><p><img src="/2021/12/13/%E5%BE%AE%E7%A7%AF%E5%88%86/image-20220113231906085.png" alt="image-20220113231906085"></p><h2 id="极限的证明"><a href="#极限的证明" class="headerlink" title="极限的证明"></a>极限的证明</h2><p><img src="/2021/12/13/%E5%BE%AE%E7%A7%AF%E5%88%86/image-20220113231952782.png" alt="image-20220113231952782"></p><p><img src="/2021/12/13/%E5%BE%AE%E7%A7%AF%E5%88%86/image-20220113232020888.png" alt="image-20220113232020888"></p><h2 id="极限的通常求法"><a href="#极限的通常求法" class="headerlink" title="极限的通常求法"></a>极限的通常求法</h2><h2 id="中间值定理"><a href="#中间值定理" class="headerlink" title="中间值定理"></a>中间值定理</h2><p><img src="/2021/12/13/%E5%BE%AE%E7%A7%AF%E5%88%86/image-20220113202114462.png" alt="image-20220113202114462"></p><p><img src="/2021/12/13/%E5%BE%AE%E7%A7%AF%E5%88%86/image-20220113202134948.png" alt="image-20220113202134948"></p><h3 id="衍生的Bozano定理"><a href="#衍生的Bozano定理" class="headerlink" title="衍生的Bozano定理"></a>衍生的Bozano定理</h3><p><img src="/2021/12/13/%E5%BE%AE%E7%A7%AF%E5%88%86/image-20220113202710844.png" alt="image-20220113202710844"></p><p>也叫勘根定理</p><p><img src="/2021/12/13/%E5%BE%AE%E7%A7%AF%E5%88%86/image-20220113204514183.png" alt="image-20220113204514183"></p><h2 id="连续和可微"><a href="#连续和可微" class="headerlink" title="连续和可微"></a>连续和可微</h2><h3 id="连续"><a href="#连续" class="headerlink" title="连续"></a>连续</h3><p>若f(x)在点a处连续，则f(a)=lim_{x-&gt;a}f(x)</p><h3 id="可微"><a href="#可微" class="headerlink" title="可微"></a>可微</h3><p>若f(x)在点a处可微，则lim_{x-&gt;a}f(x)-f(a)/x-a存在</p><h3 id="可微-gt-连续"><a href="#可微-gt-连续" class="headerlink" title="可微=&gt;连续"></a>可微=&gt;连续</h3><p><img src="/2021/12/13/%E5%BE%AE%E7%A7%AF%E5%88%86/image-20220113211326879.png" alt="image-20220113211326879"></p><h3 id="连续-gt-可微"><a href="#连续-gt-可微" class="headerlink" title="连续!=&gt;可微"></a>连续!=&gt;可微</h3><p><img src="/2021/12/13/%E5%BE%AE%E7%A7%AF%E5%88%86/image-20220113211715257.png" alt="image-20220113211715257"></p><h2 id="均值定理-1"><a href="#均值定理-1" class="headerlink" title="均值定理"></a>均值定理</h2><p><img src="/2021/12/13/%E5%BE%AE%E7%A7%AF%E5%88%86/image-20220113220739771.png" alt="image-20220113220739771"></p><p>f是一个可微的函数，两点a，b构成的割线的斜率与过其中一点c的切线斜率相等</p><h3 id="衍生的洛尔定理"><a href="#衍生的洛尔定理" class="headerlink" title="衍生的洛尔定理"></a>衍生的洛尔定理</h3><p><img src="/2021/12/13/%E5%BE%AE%E7%A7%AF%E5%88%86/image-20220113221202452.png" alt="image-20220113221202452"></p><p><img src="/2021/12/13/%E5%BE%AE%E7%A7%AF%E5%88%86/image-20220113223911254.png" alt="image-20220113223911254"></p><h2 id="柯西均值定理，使用洛尔定理证明"><a href="#柯西均值定理，使用洛尔定理证明" class="headerlink" title="柯西均值定理，使用洛尔定理证明"></a>柯西均值定理，使用洛尔定理证明</h2><p><img src="/2021/12/13/%E5%BE%AE%E7%A7%AF%E5%88%86/image-20220113230916610.png" alt="image-20220113230916610"></p><p><img src="/2021/12/13/%E5%BE%AE%E7%A7%AF%E5%88%86/image-20220113225049046.png" alt="image-20220113225049046"></p><h2 id="洛必达法则"><a href="#洛必达法则" class="headerlink" title="洛必达法则"></a>洛必达法则</h2><h3 id="右极限的证明"><a href="#右极限的证明" class="headerlink" title="右极限的证明"></a>右极限的证明</h3><p><img src="/2021/12/13/%E5%BE%AE%E7%A7%AF%E5%88%86/image-20220113230623253.png" alt="image-20220113230623253"></p><p><img src="/2021/12/13/%E5%BE%AE%E7%A7%AF%E5%88%86/image-20220113231503239.png" alt="image-20220113231503239"></p><h3 id="左极限同理。"><a href="#左极限同理。" class="headerlink" title="左极限同理。"></a>左极限同理。</h3>]]></content>
      
      
      <categories>
          
          <category> 数 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>欧式平面几何</title>
      <link href="/2021/12/08/%E6%AC%A7%E5%BC%8F%E5%B9%B3%E9%9D%A2%E5%87%A0%E4%BD%95/"/>
      <url>/2021/12/08/%E6%AC%A7%E5%BC%8F%E5%B9%B3%E9%9D%A2%E5%87%A0%E4%BD%95/</url>
      
        <content type="html"><![CDATA[<p>参考：</p><p>Youtube-&gt;万门好课——《五分钟数学漫谈》。</p><p>Youtube-&gt;<a href="https://www.youtube.com/watch?v=yYEMYP8u0sc">[高等微積分] 第1講、數學的本質 - YouTube</a></p><p>知乎——胖三sir的专栏《初中数学那些事》</p><p>CSDN——<a href="https://blog.csdn.net/yuanmeng001/article/details/88586679?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=几何基础英文&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-88586679.pc_search_es_clickV2&amp;spm=1018.2226.3001.4187">(44条消息) 希尔伯特及其《几何学基础》电子版（英文PDF），_袁萌专栏-CSDN博客</a></p><h1 id="数学的开始"><a href="#数学的开始" class="headerlink" title="数学的开始"></a>数学的开始</h1><p>相传，古希腊数学家泰勒斯引入了划时代的几何证明思想。数学家们开始不再满足于知其然了，而致力于知其所以然。通过公理或已证明命题(定理)推理出新的定理，在各定理之间建立起了联系，使数学逐步形成了一个严密的体系。</p><h1 id="物理和数学"><a href="#物理和数学" class="headerlink" title="物理和数学"></a>物理和数学</h1><p>物理的研究对象是真实世界中的东西或者说对象，研究其属性或行为。如一只猫的叫声，捕食；形状，颜色，长度，速度，重量等等。研究手段是简单化和理想化(如一个苹果，变成纸上的一个点)的真实对象——逻辑对象。逻辑对象有人为规定的一些属性。人的一切知识都是由已知的经验产生的。</p><p>数学研究逻辑世界中的东西，是物理学的研究手段，如符号，公理，推导规则，推论形成公理体系。逻辑世界是简单化和理想化后的真实世界。</p><h1 id="几何一词的由来，目的和发展"><a href="#几何一词的由来，目的和发展" class="headerlink" title="几何一词的由来，目的和发展"></a>几何一词的由来，目的和发展</h1><p>几何：长宽几何？面积几何？</p><p>代数：以符号代数，求数。</p><p>英文Geometry一词,是从希腊语演变而来的,其原意是土地测量、后被我国明朝大学士徐光启翻译成”几何学”。依据大量实证研究,创造几何学的是埃及人,几何学因土地测量而产生。</p><p>几何是研究形的科学,以人的视觉思维为主导,培养人的观察能力、空间想象能力和洞察力。</p><p>几何的发展首先是欧几里得的欧氏几何,其次是19世纪上半叶,非欧几何的诞生,再次是射影几何的繁荣,最后是几何学的统一。</p><h1 id="尺规作图"><a href="#尺规作图" class="headerlink" title="尺规作图"></a>尺规作图</h1><p>尺规作图是有2000多年历史的古老的数学游戏，在被古希腊人发明之后在全世界影响巨大，成为了科学与数学思想的源泉。</p><p><strong>阿基里德</strong>：</p><ul><li>给我一根杠杆，我能撬动地球。</li><li>浮力定律的发现者。</li><li>采用前人尺规作图的思想和朴素的极限思想，证明了球表面积公式和球体积公式。</li></ul><p><strong>牛顿</strong>：</p><ul><li>牛顿三定律</li><li>万有引力定律</li><li>微积分的发明人</li><li>《自然哲学的数学原理》，其创作灵感得益于之前的尺规作图训练，这本书中的很多命题都是由几何作图的方式证明的，与我们现在能看到的教科书上的处理方式有所不同。</li></ul><p><strong>高斯：</strong></p><ul><li>十九岁，探索出了正十七边形的尺规作图方法<a href="https://zhuanlan.zhihu.com/p/265906226">尺规作图正十七边形——高斯 - 知乎 (zhihu.com)</a></li><li>贡献繁多</li></ul><p>与尺规作图有关联的问题和数学分支简略示意图</p><p><img src="/2021/12/08/%E6%AC%A7%E5%BC%8F%E5%B9%B3%E9%9D%A2%E5%87%A0%E4%BD%95/image-20211208115244270.png" alt="image-20211208115244270"></p><h1 id="几何原本简介"><a href="#几何原本简介" class="headerlink" title="几何原本简介"></a>几何原本简介</h1><p>13卷，700多页，是对古希腊数学学派2个多世纪间研究的数学问题的收集、整理与完善。</p><p>内容不只涉及有关尺规作图的几何问题，还有很多算术问题，如素数无穷多的证明在书的第九章。故也称《原本》。</p><p>内容安排：</p><p>采用<strong>公理化体系</strong></p><p>一切开始于23条定义+5条公设+5条公理，推出了465个命题</p><p>ps：欧几里德是这样区分公理与公设的：<br>第一,公理适合于一切科学,而公设是几何所特有的；<br>第二,公理是无需证明的真理,公设没有公理那样显然,但也是不加证明而承认其真实性的.<br>时至今日,人们已不在区分公理与公设了,都用公理一词来表明.</p><h1 id="公理化体系"><a href="#公理化体系" class="headerlink" title="公理化体系"></a>公理化体系</h1><ol><li>公理要尽可能的少，而且要直观简洁</li><li>从不同的公理推理出来的同一个命题不能相互矛盾——一致</li><li>公理不能由其它公理推导出来，不然该公理毫无意义——独立</li><li>整个公理体系中的每个命题都能够由这些公理推理得到——完备</li></ol><h1 id="五大公理-common-notions-axioms"><a href="#五大公理-common-notions-axioms" class="headerlink" title="五大公理(common notions/axioms)"></a>五大公理(common notions/axioms)</h1><ol><li>等于同量的量彼此相等。Things which are equal to the same thing are also equal to one another</li><li>等量加等量，其和仍相等。If equals be added to equals, the wholes are equal</li><li>等量减等量，其差仍相等。 If equals be subtracted from equals, the remainders are equal</li><li>彼此能重合的物体是全等的。 Things which coincide with one another are equal to one another</li><li>整体大于部分之和。The whole is greater than the part</li></ol><h1 id="五大公设"><a href="#五大公设" class="headerlink" title="五大公设"></a>五大公设</h1><ol><li>两点可以连成一条直线</li><li>线段可以任意延长</li><li>绘定点o，及线段长r，可以以o为圆心，半径为r，可作一圆</li><li>凡直角皆相等 That all right angles are equal to one another<img src="/2021/12/08/%E6%AC%A7%E5%BC%8F%E5%B9%B3%E9%9D%A2%E5%87%A0%E4%BD%95/image-20211208102027448.png" alt="image-20211208102027448"></li><li>平行公理 同平面内一条直线和另外两条直线相交，若在某一侧的两个内角的和小于二直角的和，则这二直线经无限延长后在这一侧相交 That, if a straight line falling on two straight lines make the interior angles on the same side less than two right angles, the two straight lines, if produced indefinitely, meet on that that side on which are the angles less than the two right angles<img src="/2021/12/08/%E6%AC%A7%E5%BC%8F%E5%B9%B3%E9%9D%A2%E5%87%A0%E4%BD%95/image-20211208102340947.png" alt="image-20211208102340947"></li></ol><p>等价命题(从平行公设出发可以推出这个命题，从这个命题出发可以推出平行公设)：</p><p>过直线外一点可做唯一一条平行直线</p><p><img src="/2021/12/08/%E6%AC%A7%E5%BC%8F%E5%B9%B3%E9%9D%A2%E5%87%A0%E4%BD%95/image-20211208102611266.png" alt="image-20211208102611266"></p><p>三角形内角和为180度</p><p>存在一对相似但不全等的三角形</p><p>若两条直线都平行于第三条，那么这两条直线也平行</p><p>等等等…</p><h1 id="五大公设并不完备"><a href="#五大公设并不完备" class="headerlink" title="五大公设并不完备"></a>五大公设并不完备</h1><p>比如，不能解释求线段AB的中点，分别以A和B为圆心，画两个圆，为什么两圆必然相交，交于两点？<img src="/2021/12/08/%E6%AC%A7%E5%BC%8F%E5%B9%B3%E9%9D%A2%E5%87%A0%E4%BD%95/image-20211208102928499.png" alt="image-20211208102928499"></p><h1 id="几何原本中的一些定义和缺陷"><a href="#几何原本中的一些定义和缺陷" class="headerlink" title="几何原本中的一些定义和缺陷"></a>几何原本中的一些定义和缺陷</h1><p>Health的13卷及其陕西科学技术出版社2003年的译本。</p><p>内容取自Heath写的《The thirteen books of Euclid’s Elements》，及其陕西科学技术出版社2003年的译本。</p><h2 id="23条定义"><a href="#23条定义" class="headerlink" title="23条定义"></a>23条定义</h2><p>几何原本的定义只是对一些基本概念的并不精确的描述，如果我们以苛刻的眼光来看，原本中的定义是不严格的。</p><h3 id="Book1中的一些定义"><a href="#Book1中的一些定义" class="headerlink" title="Book1中的一些定义"></a>Book1中的一些定义</h3><ol><li>点是没有部分的 A point is that which has no part //<strong>什么是部分?</strong></li><li>线只有长度没有宽度 A line is breadthless length  //<strong>什么是宽度和长度?</strong></li><li>一线的两端是点 The extremities of a line are points</li><li>直线是它上面的点一样地平放着的线 A straight line is a line which lies evenly with the points on itself  //<strong>什么是平放</strong>、均匀放置的点？<strong>如果点没有部分，线怎么会有长度</strong>？</li><li>面只有长度和宽度 A surface is that which has length and breadth only. //<strong>如果线没有宽短，面的宽是从哪里来的？</strong></li><li>面的边缘是线 The extremities of a surface are lines</li><li>平面是它上面的直线一样地平放着的面 A plane surface is a surface which lies evenly with the straight lines on itself</li></ol><p>等等……</p><h3 id="Book-XI-13卷-中的一些定义"><a href="#Book-XI-13卷-中的一些定义" class="headerlink" title="Book XI(13卷)中的一些定义"></a>Book XI(13卷)中的一些定义</h3><ol><li>体有长、宽和高 A solid is that which has length, breadth and depth</li><li>体的边界是面 An extremity of a solid is a surface</li></ol><p>等等……</p><h3 id="Book1-中定义了的概念"><a href="#Book1-中定义了的概念" class="headerlink" title="Book1 中定义了的概念"></a>Book1 中定义了的概念</h3><p>点、线、直线、面、平面</p><p>平面角、直角、钝角、锐角</p><p>圆、圆心、直径、半圆</p><p>三角形、等边三角形、等腰三角形</p><p>四边形、正方形、长方形、菱形</p><p>平行直线</p><h1 id="尺规作图游戏规则"><a href="#尺规作图游戏规则" class="headerlink" title="尺规作图游戏规则"></a>尺规作图游戏规则</h1><h2 id="几点误区"><a href="#几点误区" class="headerlink" title="几点误区"></a>几点误区</h2><ol><li>直尺上有刻度</li><li>作图时，可以用圆规比好长度再去做另外一点</li><li>可以借助三角板作垂线</li><li>可以借助三角板加直尺做平行线</li></ol><h2 id="游戏规则-五大公设-postulates-假设-中的前三条"><a href="#游戏规则-五大公设-postulates-假设-中的前三条" class="headerlink" title="游戏规则-五大公设(postulates-假设)中的前三条"></a>游戏规则-五大公设(postulates-假设)中的前三条</h2><ol><li>两点可以连成一条直线 To draw a straight line from any point to any point</li><li>一条有限直线可以继续延长 to produce a straight line continuously in a straight line</li><li>以任一点为心及任意距离可以画圆 To describe a circle with any centre and distance</li></ol><p>简单的讲：过任意两点可以做唯一的直线，以任意两点可以做唯一的圆</p><h1 id="几何原本第一卷中的命题"><a href="#几何原本第一卷中的命题" class="headerlink" title="几何原本第一卷中的命题"></a>几何原本第一卷中的命题</h1><h2 id="命题1"><a href="#命题1" class="headerlink" title="命题1"></a>命题1</h2><p>在一个已知有限直线上作一个等边三角形</p><p><img src="/2021/12/08/%E6%AC%A7%E5%BC%8F%E5%B9%B3%E9%9D%A2%E5%87%A0%E4%BD%95/image-20211213145312403.png" alt="image-20211213145312403"></p><p>以A为圆心，AB为半径作圆A [公设3]</p><p>以B为圆心，BA为半径作圆B [公设3]</p><p>两圆交于点C //几何原本的公理体系实际上并不完善</p><p>连接AC与BC [公设1]</p><p>AC等于AB，并且BC等于BA [定义15]</p><p>AB等于BA</p><p>所以AC等于BC [公理1]</p><p>ABC为等边三角形 [定义20]</p><h2 id="命题2"><a href="#命题2" class="headerlink" title="命题2"></a>命题2</h2><p>由一已知点，作一线段等于已知线段</p><p><img src="/2021/12/08/%E6%AC%A7%E5%BC%8F%E5%B9%B3%E9%9D%A2%E5%87%A0%E4%BD%95/image-20211213152719314.png" alt="image-20211213152719314"></p><p>连接AB并作等边三角形ABD [公设1][命题1]</p><p>以B为圆心，BC为半径作圆B [公设3]</p><p>延长DB和DA [公设2]</p><p>DB交圆于E</p><p>以D为圆心，DE为半径作圆D [公设3]</p><p>DA交圆D于F</p><p>BC等于BE, DE等于DF [定义15]</p><p>DA等于DB [定义20]</p><p>AF等于BE, 从而等于BC [公理3][公理1]</p><p>AF为所求</p><h2 id="命题3"><a href="#命题3" class="headerlink" title="命题3"></a>命题3</h2><p>已知两条不相等的线段，试由大的上边截取一条线段使它等于另外一条</p><p><img src="/2021/12/08/%E6%AC%A7%E5%BC%8F%E5%B9%B3%E9%9D%A2%E5%87%A0%E4%BD%95/image-20211213153557987.png" alt="image-20211213153557987"></p><p>从A出发画出与BC相等的线段AE [命题2]</p><p>以A为圆心，AE为半径，画圆 [公设3]</p><p>圆A于AD交于点F</p><p>AF等于AE [定义15]</p><p>AF等于BC [公理1]</p><h2 id="命题4"><a href="#命题4" class="headerlink" title="命题4"></a>命题4</h2><p>若两个三角形的两边和夹角分别相等，则这两个三角形全等。江湖人称边角边或SAS(side angle side)</p><p>移动相等角的顶点，使角重合，由于两边相等，所以两边也重合，由于过两点只能做唯一一条直线，所以相等角的对边相等。另外两角的边都重合，故另外两角也相等。</p><h3 id="平移、旋转、镜面对称——保距变换"><a href="#平移、旋转、镜面对称——保距变换" class="headerlink" title="平移、旋转、镜面对称——保距变换"></a>平移、旋转、镜面对称——保距变换</h3><p>距离、角度、面积、体积等量在这些变换下保持不变。</p><p>保持距离的变换，称为保距变换，只有平移、旋转和镜面对称</p><h3 id="命题4能推出的命题"><a href="#命题4能推出的命题" class="headerlink" title="命题4能推出的命题"></a>命题4能推出的命题</h3><p><img src="/2021/12/08/%E6%AC%A7%E5%BC%8F%E5%B9%B3%E9%9D%A2%E5%87%A0%E4%BD%95/image-20211213155719661.png" alt="image-20211213155719661"></p><h2 id="第一卷命题内容梗概"><a href="#第一卷命题内容梗概" class="headerlink" title="第一卷命题内容梗概"></a>第一卷命题内容梗概</h2><p><img src="/2021/12/08/%E6%AC%A7%E5%BC%8F%E5%B9%B3%E9%9D%A2%E5%87%A0%E4%BD%95/image-20211213155827873.png" alt="image-20211213155827873"></p><h2 id="第一卷的高潮，命题47"><a href="#第一卷的高潮，命题47" class="headerlink" title="第一卷的高潮，命题47"></a>第一卷的高潮，命题47</h2><p>几何原本中对勾股定理的证明</p><p><img src="/2021/12/08/%E6%AC%A7%E5%BC%8F%E5%B9%B3%E9%9D%A2%E5%87%A0%E4%BD%95/image-20211213160528614.png" alt="image-20211213160528614"></p><h1 id="几何原本第二卷中的命题"><a href="#几何原本第二卷中的命题" class="headerlink" title="几何原本第二卷中的命题"></a>几何原本第二卷中的命题</h1><h2 id="第二卷命题内容梗概"><a href="#第二卷命题内容梗概" class="headerlink" title="第二卷命题内容梗概"></a>第二卷命题内容梗概</h2><p>第二卷也被称为 几何代数</p><p><img src="/2021/12/08/%E6%AC%A7%E5%BC%8F%E5%B9%B3%E9%9D%A2%E5%87%A0%E4%BD%95/image-20211213161218564.png" alt="image-20211213161218564"></p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ol><li>称两邻边夹直角的平行四边形为矩形 Any rectangular(矩形的) parallelogram(平行四边形) is said to be contained by the two straight lines containing the right angle</li><li>在任何平行四边形面片中，以此形的对角线为对角线的一个小平行四边形和两个相应的补形一起叫做拐尺形 And in any parallelogrammic area let anyone whatever of the parallelograms about its diameter(对角线) with the two complements(补形) be called a gnomon(拐尺形)<img src="/2021/12/08/%E6%AC%A7%E5%BC%8F%E5%B9%B3%E9%9D%A2%E5%87%A0%E4%BD%95/image-20211213161918524.png" alt="image-20211213161918524"></li></ol><h2 id="命题1-1"><a href="#命题1-1" class="headerlink" title="命题1"></a>命题1</h2><p><img src="/2021/12/08/%E6%AC%A7%E5%BC%8F%E5%B9%B3%E9%9D%A2%E5%87%A0%E4%BD%95/image-20211213162442737.png" alt="image-20211213162442737"></p><p><img src="/2021/12/08/%E6%AC%A7%E5%BC%8F%E5%B9%B3%E9%9D%A2%E5%87%A0%E4%BD%95/image-20211213162517943.png" alt="image-20211213162517943"></p><p><img src="/2021/12/08/%E6%AC%A7%E5%BC%8F%E5%B9%B3%E9%9D%A2%E5%87%A0%E4%BD%95/image-20211213162531972.png" alt="image-20211213162531972"></p><h2 id="命题4-1"><a href="#命题4-1" class="headerlink" title="命题4"></a>命题4</h2><p><img src="/2021/12/08/%E6%AC%A7%E5%BC%8F%E5%B9%B3%E9%9D%A2%E5%87%A0%E4%BD%95/image-20211213162618726.png" alt="image-20211213162618726"></p><p><img src="/2021/12/08/%E6%AC%A7%E5%BC%8F%E5%B9%B3%E9%9D%A2%E5%87%A0%E4%BD%95/image-20211213162633777.png" alt="image-20211213162633777"></p><p><img src="/2021/12/08/%E6%AC%A7%E5%BC%8F%E5%B9%B3%E9%9D%A2%E5%87%A0%E4%BD%95/image-20211213162646253.png" alt="image-20211213162646253"></p><h2 id="第二卷前10个命题的代数表达"><a href="#第二卷前10个命题的代数表达" class="headerlink" title="第二卷前10个命题的代数表达"></a>第二卷前10个命题的代数表达</h2><p><img src="/2021/12/08/%E6%AC%A7%E5%BC%8F%E5%B9%B3%E9%9D%A2%E5%87%A0%E4%BD%95/image-20211213162724739.png" alt="image-20211213162724739"></p><h1 id="几何原本第三卷"><a href="#几何原本第三卷" class="headerlink" title="几何原本第三卷"></a>几何原本第三卷</h1><p><img src="/2021/12/08/%E6%AC%A7%E5%BC%8F%E5%B9%B3%E9%9D%A2%E5%87%A0%E4%BD%95/image-20211213163331394.png" alt="image-20211213163331394"></p><p><img src="/2021/12/08/%E6%AC%A7%E5%BC%8F%E5%B9%B3%E9%9D%A2%E5%87%A0%E4%BD%95/image-20211213163355645.png" alt="image-20211213163355645"></p><h1 id="几何原本第四卷"><a href="#几何原本第四卷" class="headerlink" title="几何原本第四卷"></a>几何原本第四卷</h1><p><img src="/2021/12/08/%E6%AC%A7%E5%BC%8F%E5%B9%B3%E9%9D%A2%E5%87%A0%E4%BD%95/image-20211213163409643.png" alt="image-20211213163409643"></p><p><img src="/2021/12/08/%E6%AC%A7%E5%BC%8F%E5%B9%B3%E9%9D%A2%E5%87%A0%E4%BD%95/image-20211213163427145.png" alt="image-20211213163427145"></p><h1 id="几何原本第五卷：比例论"><a href="#几何原本第五卷：比例论" class="headerlink" title="几何原本第五卷：比例论"></a>几何原本第五卷：比例论</h1><p>提出者：欧多克索斯(Rudoxus)，柏拉图的学生和好友</p><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><ol><li>当一个较小的量能量尽一个较大的量时，我们把较小量叫做较大量的一部分 A magnitude is a part of a magnitude，the less of the greater，when it measures the greater</li><li>当一个较大量能被一个较小量量尽时，我们把较大的量叫做较小的量的倍量 The greater is a multiple of the less when it is measure by the less</li><li>两个同类量彼此之间的一种大小关系叫做比 A ratio is a sort of relation in respect of size between two magnitudes of the same kind</li><li>把一个量几倍以后能大于另外一个量时，则说这两个量彼此之间有一个比 Magnitudes are said to have a ratio to one another which are capable，when multipled，of exceeding one another</li><li>有四个量，第一量比第二量与第三辆比第四量叫做有相同比，如果对第一与第三个量取任何同倍数，又对第二与第四个量取任何同倍数，而第一与第二量之间依次有大于、等于或小于的关系，那么第三与第四倍量之间便有相应的关系 Magnitudes are said to be in the same ratio，the first to the second and the third to the fourth，when，if any equimultiples whatever be taken of the first and third，and any equimultiples whatever of the second and the fourth，the former equimultiples alike exceed，are alike equal to，or alike fall short of the latter equimultiples respectively taken in corresponding order</li></ol><p><img src="/2021/12/08/%E6%AC%A7%E5%BC%8F%E5%B9%B3%E9%9D%A2%E5%87%A0%E4%BD%95/image-20211213174945026.png" alt="image-20211213174945026"></p><p><img src="/2021/12/08/%E6%AC%A7%E5%BC%8F%E5%B9%B3%E9%9D%A2%E5%87%A0%E4%BD%95/image-20211213175405917.png" alt="image-20211213175405917"></p><p><img src="/2021/12/08/%E6%AC%A7%E5%BC%8F%E5%B9%B3%E9%9D%A2%E5%87%A0%E4%BD%95/image-20211213175418947.png" alt="image-20211213175418947"></p><h1 id="几何原本第六卷"><a href="#几何原本第六卷" class="headerlink" title="几何原本第六卷"></a>几何原本第六卷</h1><h1 id="什么是定义？"><a href="#什么是定义？" class="headerlink" title="什么是定义？"></a>什么是定义？</h1><h2 id="亚里士多德"><a href="#亚里士多德" class="headerlink" title="亚里士多德"></a>亚里士多德</h2><ul><li><p>下定义不过是给个新名字，在给出定义的时候，必须使用已有明确意思的事物。</p></li><li><p>一个理论中最基本的那些东西，是无法定义和证明的。</p></li></ul><p>对于几何中最基本的的点、线、面的概念，我们该怎么定义呢？这个问题困扰了世人很久，2000年后，希尔伯特横空出世。</p><h2 id="无法定义的基本概念"><a href="#无法定义的基本概念" class="headerlink" title="无法定义的基本概念"></a>无法定义的基本概念</h2><p>两千年中，数学家们不断尝试给”点、线、面”一个严谨的定义，然而始终做不到，欧几里得的几何学地基不牢，大厦将倾。</p><p>大家开始接受一个事实，就是在任何一组几何公理体系中，就像它必然存在某些无法证明的基本事实一样，它也必然会存在一些无法定义的概念，如点、线、面。它们无法用已知的事物定义，我们只能通过描述其性质，以描述这些基本存在。</p><h2 id="大卫·希尔伯特-David-Hilbert"><a href="#大卫·希尔伯特-David-Hilbert" class="headerlink" title="大卫·希尔伯特(David Hilbert)"></a>大卫·希尔伯特(David Hilbert)</h2><ul><li>对于几何中最基本的点、线、面作为不加定义的基础概念，称之为几何的基本元素，直接用符号来表示，正如希尔伯特所说“我们必定可以用‘桌子、椅子、啤酒杯’来代替‘点、线、面’ ”，它们不再是看得见摸得着的东西来定义了，它们成了纯粹的抽象符号。同时它避开了”线是由点构成的，面是由线构成的”这一设定，将点、线、面设定成了三个独立的元素个体。</li><li>那么如何描述它们的性质，以及它们之间的联系呢？这就需要在三者之间设定一些关系和公理了。</li><li>1899年出版了《几何基础》，在这部著作中，希尔伯特创立了一个新公理系统(史称“希尔伯特公理系统”)。他从叙述20条公理开始，其中涉及六个本原概念(作为元素的点、线、面和它们之间的三种关系“属于”、“介于”、“全等于”)和五类公理，分别描述关联、顺序、全等、平行和连续性。 </li><li>公理体系的标准也是希尔伯特提出来的：从不同的公理推理出来的同一个命题不能相互矛盾——一致；公理不能由其它公理推导出来，不然该公理毫无意义——独立；整个公理体系中的每个命题都能够由这些公理推理得到——完备。</li></ul><h1 id="希尔伯特的公理体系"><a href="#希尔伯特的公理体系" class="headerlink" title="希尔伯特的公理体系"></a>希尔伯特的公理体系</h1><h2 id="The-Elements：points-straight-lines-and-planes"><a href="#The-Elements：points-straight-lines-and-planes" class="headerlink" title="The Elements：points, straight lines and planes"></a>The Elements：points, straight lines and planes</h2><p>Let us consider three distinct systems of things. The things composing the ﬁrst system, we will call points and designate them by the letters A, B, C,…; those of the second, we will call straight lines and designate them by the letters a, b, c,…; and those of the third system, we will call planes and designate them by the Greek letters α, β, γ,…The points are called the elements of linear geometry; the points and straight lines, the elements of plane geometry; and the points, lines, and planes, the elements of the geometry of space or the elements of space. </p><h2 id="Mutual-relations"><a href="#Mutual-relations" class="headerlink" title="Mutual relations"></a>Mutual relations</h2><p>We think of these points, straight lines, and planes as having certain mutual relations, which we indicate by means of such words as “are situated(位于),” “between(介于),” “parallel(平行),” “congruent(全等),” “continuous(连续),” etc. The complete and exact description of these relations follows as a consequence of the axioms of geometry(公理描述关系). These axioms may be arranged in ﬁve groups. Each of these groups expresses, by itself, certain related fundamental facts of our intuition(每一个公理都与我们直接感受到的基本事实相关). We will name these groups as follows: I, 1–7. Axioms of connection. II, 1–5. Axioms of order. III. Axiom of parallels (Euclid’s axiom). IV, 1–6. Axioms of congruence. V. Axiom of continuity (Archimedes’s axiom).</p><h2 id="Axioms-of-connection"><a href="#Axioms-of-connection" class="headerlink" title="Axioms of connection"></a>Axioms of connection</h2><p>The axioms of this group establish a connection between the concepts indicated above(这组公理建立三元素的关联); namely, points, straight lines, and planes. These axioms are as follows:<br>I, 1. Two distinct points A and B always completely determine a straight line a. We write AB = a or BA = a. 两个不同的点A,B总是完全确定一条直线a(点A,B在直线a上)</p><p>I, 2. Any two distinct points of a straight line completely determine that line; that is, if AB = a and AC = a, where B≠ C, then is also BC = a. 直线上的任意不同两点确定这条直线，如果点A、B在直线a上，点A、C也在直线a上，且B、C是不同的点，那么点B、C也确定这条直线(在直线a上)。<br>I, 3. Three points A, B, C not situated in the same straight line always completely determine a plane α. We write ABC = a.三个不在同一条直线上的点总是完全确定一个平面α(点A,B,C在平面α上)</p><p>I, 4. Any three points A, B, C of a plane α, which do not lie in the same straight line,completely determine that plane. 位于平面α的任意三点A、B、C，若不位于同一条直线上，可以完全确定该平面 </p><p>I, 5. If two points A, B of a straight line a lie in a plane α, then every point of a lies in α. 如果直线a上的两点A、B位于平面α，那么直线上的所有点都位于α<br>In this case we say: “The straight line a lies in the plane α,” etc.<br>I, 6. If two planes α, β have a point A in common, then they have at least a second point B in common. 如果平面α、β都有点A，那么他们至少都有第二个点B</p><p>I, 7. Upon every straight line there exist at least two points, in every plane at least three points not lying in the same straight line, and in space there exist at least four points not lying in a plane. 每条直线上至少有2个电，每个平面内至少有3个不位于同一直线的点，每个空间内至少有4个不位于同一平面的点。</p><p>Axioms I, 1–2 contain statements concerning points and straight lines only; that is, concerning the elements of plane geometry. We will call them,therefore,the plane axioms of group I, in order to distinguish them from the axioms I, 3–7, which we will designate brieﬂy as the space axioms of this group. Of the theorems(定理) which follow from the axioms I, 3–7, we shall mention only the following:<br>Theorem 1. Two straight lines of a plane have either one point or no point in common; two planes have no point in common or a straight line in common; a plane and a straight line not lying in it have no point or one point in common. </p><p>Theorem 2. Through a straight line and a point not lying in it, or through two distinct straight lines having a common point, one and only one plane may be made to pass.</p><h2 id="Axioms-of-order"><a href="#Axioms-of-order" class="headerlink" title="Axioms of order"></a>Axioms of order</h2><p>The axioms of this group deﬁne the idea expressed by the word “between,”(这组公理定义“介于”这个词表达的含义) and make possible, upon the basis of this idea, an order of sequence of the points upon a straight line, in a plane, and in space. The points of a straight line have a certain relation to one another which the word “between” serves to describe. The axioms of this group are as follows:<br>II, 1. If A, B,C are points of a straight line and B lies between A and C,then B lies also between C and A. 如果点A、B、C位于一条直线上，并且B位于A和C之间，那么B也位于C和A之间。</p><p><img src="/2021/12/08/%E6%AC%A7%E5%BC%8F%E5%B9%B3%E9%9D%A2%E5%87%A0%E4%BD%95/image-20211212121018076.png" alt="image-20211212121018076"></p><p>II, 2. If A and C are two points of a straight line, then there exists at least one point B lying between A and C and at least one point D so situated that C lies between A and D. 如果A、C是一条直线上的两点，那么存在至少一个点B位于A和C之间，并且存在至少一个点D，点D如此位于直线，使得C位于A和D之间。<br>Fig. 2.<br>II, 3. Of any three points situated on a straight line, there is always one and only one which lies between the other two. 对于位于一条直线的任意三个点，总是只有一个点位于另外两点之间。 </p><p>II, 4. Any four points A, B, C, D of a straight line can always be so arranged that B shall lie between A and C and also between A and D, and, furthermore, that C shall lie between A and D and also between B and D. 任意四个位于一条直线的点A、B、C、D，总是能如此安排，B位于A和C、A和D之间，且C位于A和D、B和D之间</p><p>Definition. We will call the system of two points A and B, lying upon a straight line, a segment and denote it by AB or BA(由两点构成的，位于一条直线上的系统，称作线段). The points lying between A and B are called the points of the segment AB or the points lying within the segment AB. All other points of the straight line are referred to as the points lying outside the segment AB.(位于点A、B之间的点称作线段AB上的点，其他点称作线段AB外的点) The points A and B are called the extremities of the segment AB.(点A、B称作线段AB的边界)<br>II, 5. Let A, B, C be three points not lying in the same straight line and let a be a straight line lying in the plane ABC and not passing through any of the points A, B, C. Then, if the straight line a passes through a point of the segment AB, it will also pass through either a point of the segment BC or a point of the segment AC.  A、B、C是不位于同一条直线上的三点，直线a是位于平面ABC但是不经过A、B、C任何一点的直线。那么，如果a经过线段AB的一点，它也经过线段BC或线段AC的一点。</p><p><img src="/2021/12/08/%E6%AC%A7%E5%BC%8F%E5%B9%B3%E9%9D%A2%E5%87%A0%E4%BD%95/image-20211212122810552.png" alt="image-20211212122810552"></p><p>Axioms II, 1–4 contain statements concerning the points of a straight line only, and, hence, we will call them the linear axioms of group II. Axiom II, 5 relates to the elements of plane geometry and, consequently, shall be called the plane axiom of group II.</p><h2 id="Axioms-of-parallels-EUCLID’S-AXIOM"><a href="#Axioms-of-parallels-EUCLID’S-AXIOM" class="headerlink" title="Axioms of parallels (EUCLID’S AXIOM)"></a>Axioms of parallels (EUCLID’S AXIOM)</h2><p>The introduction(使用) of this axiom simpliﬁes greatly the fundamental principles of geometry and facilitates in no small degree(不小程度的) its development. This axiom may be expressed as follows: </p><p>III. In a plane α there can be drawn through any point A, lying outside of a straight line a, one and only one straight line which does not intersect the line a. This straight line is called the parallel to a through the given point A. 在平面α中，可以经过在直线a外的一点A，画出一条且只有一条直线与直线a不相交。这个直线叫做经过给定点A的a的平行直线。</p><h2 id="Axioms-of-congruence"><a href="#Axioms-of-congruence" class="headerlink" title="Axioms of congruence"></a>Axioms of congruence</h2><p>The axioms of this group deﬁne the idea of congruence or displacement. Segments stand in a certain relation to one another which is described by the word “congruent.”<br> IV, I. If A, B are two points on a straight line a, and if A0 is a point upon the same or another straight line a0,then,upon a given side of A0 on the straight line a0,we can always ﬁnd one and only one point B0 so that the segment AB(or BA) is congruent to the segment A0B0. We indicate this relation by writing AB≡ A0B0. Every segment is congruent to itself; that is, we always have AB≡ AB. We can state the above axiom brieﬂy by saying that every segment can be laid off upon a given side of a given point of a given straight line in one and and only one way.  如果A、B是直线a的两点，A0是同一或另一直线a0的一点，那么，在A0给定的一侧，我们总能找到一个且仅有一个点B0，使得线段AB全等于线段B0. 我们用AB≡ A0B0表示这种关系。我们可以简介地表述上述公理：每一个线段可以布置在给定直线给定点的给定侧，以一种且仅一种方式。</p><p>IV, 2. If a segment AB is congruent to the segment A0B0 and also to the segment A00B00, then the segment A0B0 is congruent to the segment A00B00; that is, if AB ≡ A0B and AB≡ A00B00, then A0B0 ≡ A00B00.  线段AB与A0B0全等，线段AB与A00B00全等，则线段A0B0与A00B00全等。</p><p>IV,3. Let AB and BC be two segments of a straight line a which have no points in common aside from the point B, and, furthermore, let A0B0 and B0C0 be two segments of the same or of another straight line a0 having, likewise, no point other than B0 in common. Then, if AB≡ A0B0 and BC ≡ B0C0, we have AC ≡ A0C0. 线段AB和BC是直线a的两个线段，AB和BC只有公共点B，线段A0B0和B0C0是同一或另一直线a0的两个线段，同样只有公共点B0，那么，AB≡ A0B0且BC≡ B0C0，就有AC≡ A0C0</p><p><img src="/2021/12/08/%E6%AC%A7%E5%BC%8F%E5%B9%B3%E9%9D%A2%E5%87%A0%E4%BD%95/image-20211212181906062.png" alt="image-20211212181906062"></p><p>Definitions. Let α be any arbitrary plane and h, k any two distinct half-rays(射线) lying in α and emanating(产生自) from the point O so as to form a part of two different straight lines. We call the system formed by these two half-rays h, k an angle(角) and represent it by the symbol ∠(h,k) or ∠(k,h). From axioms II, 1–5, it follows readily that the half-rays h and k, taken together with the point O, divide the remaining points of the plane α into two regions having the following property: If A is a point of one region and B a point of the other, then every broken line(虚线) joining(连接) A and B either passes through O or has a point in common with one of the half-rays h, k. If, however, A, A0 both lie within the same region, then it is always possible to join these two points by a broken line which neither passes through O nor has a point in common with either of the half-rays h, k. One of these two regions is distinguished from the other in that the segment joining any two points of this region lies entirely within the region. The region so characterised is called the interior(内部) of the angle (h,k). To distinguish the other region from this, we call it the exterior(外部) of the angle (h,k). The half rays h and k are called the sides of the angle, and the point O is called the (顶点)vertex of the angle. </p><p>IV, 4. Let an angle (h,k) be given in the plane α and let a straight line a0 be given in a plane α0. Suppose also that, in the plane α0, a deﬁnite side of the straight line a0 be assigned. Denote by h0 a half-ray of the straight line a0 emanating from a point O0 of this line. Then in the plane α0 there is one and only one half-ray k0 such that the angle (h,k), or (k,h), is congruent to the angle (h0,k0) and at the same time all interior points of the angle (h0,k0) lie upon the given side of a0. We express this relation by means of the notation ∠(h,k)≡∠(h0,k0) Every angle is congruent to itself; that is, ∠(h,k)≡∠(h,k) or ∠(h,k)≡∠(k,h) We say, brieﬂy, that every angle in a given plane can be laid off upon a given side of a given half-ray in one and only one way. 角(h,k)在平面α上，直线a0在平面α0上。在平面α上，指定直线a0的一侧，由a0上一点00产生的属于a0的射线标记为h0.在平面α0上有且只有一条射线k0，使得角(h,k)与角(h0,k0)全等<br>IV, 5. If the angle (h,k) is congruent to the angle (h0,k0) and to the angle (h00,k00), then the angle (h0,k0) is congruent to the angle (h00,k00); that is to say, if ∠(h,k) ≡∠(h0,k0) and ∠(h,k)≡∠(h00,k00), then∠(h0,k0)≡∠(h00,k00). 此时所有角(h0,k0)内部的点都位于直线a0指定的一侧。我们用标记 ∠(h,k)≡∠(h0,k0)表达这种关系，每个角都全等它自己, 即∠(h,k)≡∠(h,k) 或 ∠(h,k)≡∠(k,h)。我们简单的说，在给定平面上的每个角可以被转移到指定射线的指定一侧，有且仅有一种方式。</p><p>Suppose we have given a triangle ABC. Denote by h, k the two half-rays emanating from A and passing respectively through B and C. The angle (h,k) is then said to be the angle included by the sides AB and AC, or the one opposite to the side BC in the triangle ABC. It contains all of the interior points of the triangle ABC and is represented by the symbol ∠BAC, or by ∠A. </p><p>IV, 6. If, in the two triangles ABC and A0B0C0 the congruences AB≡ A0B0, AC ≡ A0C0, ∠BAC ≡∠B0A0C0 hold, then the congruences ∠ABC ≡∠A0B0C0and∠ACB≡∠A0C0B0 also hold. 如果再两个三角形中，两边全等，其夹角也全等，那么另外两个角也全等</p><p>Axioms IV, 1–3 contain statements concerning the congruence of segments of a straight line only. They may, therefore, be called the linear axioms of group IV. Axioms IV, 4, 5 contain statements relating to the congruence of angles. Axiom IV, 6 gives the connection between the congruence of segments and the congruence of angles. Axioms IV, 4–6 contain statements regarding the elements of plane geometry and may be called the plane axioms of group IV.</p><h2 id="Axioms-of-continuity-To-Do"><a href="#Axioms-of-continuity-To-Do" class="headerlink" title="Axioms of continuity To Do"></a>Axioms of continuity To Do</h2><p>姑且不谈，先看实数的连续型，即可比数和不可比数在数轴上的分布情况。</p><h2 id="希尔伯特怎么证明其几何公理体系的一致性，独立性，完备性-To-Do"><a href="#希尔伯特怎么证明其几何公理体系的一致性，独立性，完备性-To-Do" class="headerlink" title="希尔伯特怎么证明其几何公理体系的一致性，独立性，完备性 To Do"></a>希尔伯特怎么证明其几何公理体系的一致性，独立性，完备性 To Do</h2><p>坑待填</p><h1 id="哥德尔不完备性定理-To-Do"><a href="#哥德尔不完备性定理-To-Do" class="headerlink" title="哥德尔不完备性定理 To Do"></a>哥德尔不完备性定理 To Do</h1><p>那一年是1931年，希尔伯特的几何公理体系面世三十年之际，<a href="https://www.zhihu.com/search?q=奥地利&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;article&quot;%2C&quot;sourceId&quot;%3A384485261}">奥地利</a>数学家、逻辑学家、哲学家库尔特∙哥德尔（Kurt Gödel，1906—1978）发表了一篇论文，这一篇论文中的定理就是数学和逻辑学中<strong>具有划时代意义的定理——哥德尔不完备性定理</strong>.</p><p>在这个定理中，哥德尔证明了<strong>任何一个形式系统(希尔伯特的几何公理体系正是一个几何的形式化系统)，只要包括了简单的<a href="https://www.zhihu.com/search?q=初等数论&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;article&quot;%2C&quot;sourceId&quot;%3A384485261}">初等数论</a>描述，而且是自洽的，它必定包含某些系统内所允许的方法既不能证明真也不能证伪的命题.</strong></p><p>呃，有点绕，我们说得再直白点，前面我们说到，希尔伯特所建立的几何公理体系有三大基本标准：相容性，独立性，完备性. 而哥德尔不完备定理则证明了这三个标准无法同时具备，即<strong>如果公理体系满足相容性，那么它就不可能是完备的.</strong> 换句话说，在一个不存在矛盾的公理体系中，必然存在某些命题没办法证明其是真的还是假的.(当然这些命题只是在这个公理体系中无法证明，并不代表它们在其它公理体系中也不能证明.)</p><p>至于哥德尔怎么证的，尚且不知，坑待填</p><h1 id="非欧几何-球面几何，双曲几何"><a href="#非欧几何-球面几何，双曲几何" class="headerlink" title="非欧几何-球面几何，双曲几何"></a>非欧几何-球面几何，双曲几何</h1><p>再说回到欧几里得几何，在欧几里得的几何公理体系中，那个更致命的问题是什么？</p><p>答案是：<strong><a href="https://www.zhihu.com/search?q=平行公设&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;article&quot;%2C&quot;sourceId&quot;%3A384485261}">平行公设</a>.</strong></p><p>我们来看欧几里得的公理体系中的五条公设：</p><blockquote><p>★ 1.过两点能作且只能作一直线； 2.线段(有限直线)可以无限地延长； 3.以任一点为圆心,任意长为半径,可作一圆； 4.凡是直角都相等； 5.同平面内一条直线和另外两条直线相交，若在直线同侧的两个<a href="https://www.zhihu.com/search?q=内角&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;article&quot;%2C&quot;sourceId&quot;%3A384485261}">内角</a>之和小于180°，则这两条直线经无限延长后在这一侧一定相交.<br>”</p></blockquote><p>仔细观察会发现，<strong>前面四条讲的都是在有限范围内的图形，我们是可以直观上观测并验证的基本事实</strong>，然而第五条就不一样了，“经过无限延长后在这一侧相交”，<strong>无限延长？你能看见尽头？你怎么验证其是否真的相交了？</strong></p><p>这条<a href="https://www.zhihu.com/search?q=公设&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;article&quot;%2C&quot;sourceId&quot;%3A384485261}">公设</a>引起了无数数学家们的注意，既然无法验证，那么，是否可以由其它几条推出这条呢？如果可以的话，就说明这条公设并不具备独立性，我们就可以把它拿下来，不再作为公理了. 于是数学家们前赴后继，想要证明这一条，却屡屡失败. 终于，数学家们开始意识到，这个公设确实是独立的.</p><p>那么，既然它是独立的，我们就可以尝试建立一个相似的公理体系，其它公设都依然成立，<strong>唯独不满足平行公设</strong>，1830年Lobachevsky和Bolyai给出了两个不同的几何模型。</p><p><strong>非欧几何诞生了.</strong></p><p>至此，<a href="https://www.zhihu.com/search?q=几何学&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;article&quot;%2C&quot;sourceId&quot;%3A384485261}">几何学</a>开始分裂了，也开始蓬勃发展了.</p><p>非欧几何我们陌生吗？并不陌生，它和我们生活息息相关. 举个简单例子，拿个地球仪观察一下，南北极之间有几条<a href="https://www.zhihu.com/search?q=平行线&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;article&quot;%2C&quot;sourceId&quot;%3A384485261}">平行线</a>？</p><p>答：无数条. 每一条经度线都平行. 这就是不满足平行公设的<a href="https://www.zhihu.com/search?q=球面几何&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;article&quot;%2C&quot;sourceId&quot;%3A384485261}">球面几何</a>，也是非欧几何的一种</p><ul><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数学危机</title>
      <link href="/2021/12/06/%E6%95%B0%E5%AD%A6%E5%8D%B1%E6%9C%BA/"/>
      <url>/2021/12/06/%E6%95%B0%E5%AD%A6%E5%8D%B1%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.youtube.com/watch?v=yYEMYP8u0sc">[高等微積分] 第1講、數學的本質 - YouTube</a>  数学的本质：公理-&gt;定理-&gt;定理-&gt;…-&gt;定理。公理是这个世界的真理，是人所观察到的，这个世界中不变的东西——律。</p><h1 id="第一次数学危机"><a href="#第一次数学危机" class="headerlink" title="第一次数学危机"></a>第一次数学危机</h1><p>毕达哥拉斯是希腊的主要数学家</p><p>他的主要观点是万物皆数-有理数(rational翻译错误，应为可比，以后都称有理数为可比数，无理数为不可比数)</p><p>可比数可以表示成整数之比，分为三类</p><ul><li>整数：1,2,3</li><li>有限小数 0.5=1/2  0.25=1/4</li><li>无限循环小数 0.333…=3/9  0.806806…=806/999</li></ul><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>无限循环小数转换成分数</span></div>    <div class="hide-content"><p><img src="/2021/12/06/%E6%95%B0%E5%AD%A6%E5%8D%B1%E6%9C%BA/image-20211208090323580.png" alt="image-20211208090323580"></p><p>分母：小数点后循环部分有几位，分母开头就有几个9，小数点后不循环部分有几位，分母结尾就有几个0。</p><p>分子：去掉小数点后的整数，减去去除循环部分的整数。</p><p>原理：<a href="https://www.youtube.com/watch?v=YRHUvbT7Dog">循環小數化成分數有公式嗎為什麼公式這樣教學 - YouTube</a></p><p>令x=不循环小数，根据小数的不循环部分(假设1位)和循环部分(假设2位)，得到等式如1000x-10x=整数相减，去掉循环部分，最终得到如x=整数/990的分数。</p></div></div><p>希帕索斯：如果有一个直角三角形，x=1，y=1，z=根号2，根号2是个啥？毕达哥拉斯把希帕索斯绑到大石头上扔到爱琴海里了。</p><p>实际上，实数=可比数+不可比数</p><h1 id="第二次数学危机"><a href="#第二次数学危机" class="headerlink" title="第二次数学危机"></a>第二次数学危机</h1><h2 id="芝诺：阿基里斯追乌龟"><a href="#芝诺：阿基里斯追乌龟" class="headerlink" title="芝诺：阿基里斯追乌龟"></a>芝诺：阿基里斯追乌龟</h2><p>其实在古希腊时代就已经有了，古希腊有一个数学家叫芝诺，他研究了很多的悖论。</p><p>阿基里斯A与乌龟B相距L，阿基里斯从a1跑到乌龟原来的位置a2，乌龟向前走一段到了a3；阿基里斯从a2跑到a3，乌龟又往前走了一段到a4，所以阿基里斯永远追不上乌龟。</p><p>设阿基里斯的速度为VA=2VB。则阿基里斯跑的路程和花费的时间为</p><script type="math/tex; mode=display">S_A=L+{1\over2}L+{1\over4}L+{1\over8}L+...=2L-{1\over2^n}L</script><script type="math/tex; mode=display">t_A=t+{1\over2}t+{1\over4}t+{1\over8}t+...=2t-{1\over2^n}t</script><p>n-&gt;∞的时候，两个公式的最后一项无穷小。</p><p>芝诺的问题在于，它把一个有限的长度分割成了无限多份，但是这些份加起来并不是一个无穷长的时间和路程。</p><h2 id="牛顿、莱布尼兹"><a href="#牛顿、莱布尼兹" class="headerlink" title="牛顿、莱布尼兹"></a>牛顿、莱布尼兹</h2><p>各自独立发明了微积分</p><p>微积分中有一个重要的概念，是导数</p><p>假如有一个function y=f(x)，在二维坐标轴上表示为曲线，取点A和点B，这两个点就会有一个横坐标的差△x和纵坐标的差△y，如果△x-&gt;0，B点就会非常非常接近于A点，B点非常接近于A点的时候，△y/△x=f(x)在A点的导数。</p><p>人们通过导数以及微积分解决了很多数学和物理上的问题，所以人们觉得这是很正确的。直到有一天，英国的大主教提出了问题。</p><p>贝克莱：△x(无穷小)是否为0，若是，△x凭什么做分母，若不是，凭什么说B点与A点重合成一个点呢？所以微积分的基础是有问题的。</p><p>第二次数学危机持续了150年。直到像阿贝尔、柯西、康托尔等人对无穷小进行了严格的定义，从而使微积分具有了坚实的基础。</p><h1 id="第三次数学危机"><a href="#第三次数学危机" class="headerlink" title="第三次数学危机"></a>第三次数学危机</h1><h2 id="罗素：理发师悖论"><a href="#罗素：理发师悖论" class="headerlink" title="罗素：理发师悖论"></a>罗素：理发师悖论</h2><p>理发师：“我给且仅给自己不刮胡子的人刮胡子”。</p><p>那么理发师该不该给自己刮胡子呢？</p><p>如果他给自己刮胡子，他自己就刮胡子，他就不该给自己刮胡子，矛盾。</p><p>如果他不给自己刮胡子，他就应该给自己刮胡子，矛盾。</p><p>悖论就是怎么说都矛盾。</p><p>罗素为什么提出这么一个奇怪的问题呢？是要诘难德国数学家康托尔。</p><h2 id="康托尔：集合论"><a href="#康托尔：集合论" class="headerlink" title="康托尔：集合论"></a>康托尔：集合论</h2><p>康托尔提出了集合理论，集合理论被认为是现代数学的基础。用集合去解释现代数学中的一些问题，这个理论后来被人们称为人类纯智力活动的最高成就。</p><p>集合有瑕疵。他不说，罗素就问他。</p><p>集合有3个特点</p><ol><li>确定性：每一个元素必须是确定的</li><li>互异性：每两个元素都不能相同</li><li>无序性：这些元素没有什么排列的顺序</li></ol><p>美女不能构成集合，因为美女，有人觉得美，有人觉得不美，这是不确定的，不符合集合的确定性。</p><p>定义A={x|x∉A}</p><p>若A∈A=&gt;A∉A</p><p>若A∉A=&gt;A∈A</p><p>这件事情到目前为止，还没有被完美地解决，所以这件事被称为第三次数学危机。</p><p>康托尔一次一次经受着罗素的诘难，他又解释不了，他就疯掉了，最后死在自己工作的哈勒大学精神病院里面。</p>]]></content>
      
      
      <categories>
          
          <category> 数 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>勾股定理</title>
      <link href="/2021/11/25/%E5%8B%BE%E8%82%A1%E5%AE%9A%E7%90%86/"/>
      <url>/2021/11/25/%E5%8B%BE%E8%82%A1%E5%AE%9A%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>参考李永乐的视频</p><h1 id="勾股定理"><a href="#勾股定理" class="headerlink" title="勾股定理"></a>勾股定理</h1><p>直角三角形的两条直角边的平方和等于斜边的平方</p><p><img src="/2021/11/25/%E5%8B%BE%E8%82%A1%E5%AE%9A%E7%90%86/image-20211125210939617.png" alt="image-20211125210939617"></p><p>在中国，《周髀算经》给出了结论。三国时期吴国的赵爽在《周髀算经注》中给出了证明。</p><p>在古希腊，毕达哥拉斯提出了这个定理，但是证明失传了。欧几里得在《几何原本》中给出了证明，现在所学的几何内容与《几何原本》几乎一样。</p><h1 id="三国时期吴国赵爽的证明"><a href="#三国时期吴国赵爽的证明" class="headerlink" title="三国时期吴国赵爽的证明"></a>三国时期吴国赵爽的证明</h1><p>勾股圆方图：勾股各自乘，并之，为弦实，开方除之为弦。</p><p><img src="/2021/11/25/%E5%8B%BE%E8%82%A1%E5%AE%9A%E7%90%86/image-20211125211419763.png" alt="image-20211125211419763"></p><h1 id="爱因斯坦十一岁时的证明"><a href="#爱因斯坦十一岁时的证明" class="headerlink" title="爱因斯坦十一岁时的证明"></a>爱因斯坦十一岁时的证明</h1><p>一个直角三角线，可以分割成2个与原直角三角形相似的直角三角形。</p><p><img src="/2021/11/25/%E5%8B%BE%E8%82%A1%E5%AE%9A%E7%90%86/image-20211125211503772.png" alt="image-20211125211503772"></p><p>相似图形的面积之比等于边长的平方比</p><p>故S1+S2=S3即a^2+b^2=c^2</p><h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><p>勾股定理将几何和代数联系在一起。</p><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>几何问题：直角三角形的三条边的边长都是正整数，能画出多少种？</p><p>等价于代数问题：满足a^2+b^2=c^2的正整数组(a,b,c)有多少组呢？</p><p>答：无穷组，因为(3n)^2 + (4n)^2 = (5n)^2</p><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p>那符合上述条件的互素正整数数组有多少组？</p><p>【To Do】x^2+y^2=z^2的正整数解通式：x=2mn，y=m^2-n^2，z=m^2+n^2，m＞n＞0，mn互素且一奇一偶。</p><h2 id="公元两百多年的代数之父丢番图"><a href="#公元两百多年的代数之父丢番图" class="headerlink" title="公元两百多年的代数之父丢番图"></a>公元两百多年的代数之父丢番图</h2><p>曾经写过一本书叫做《算术》，一个正整数的平方可否由另外两个正整数的平方和表示。</p><h2 id="拓展指数——折磨数学家将近400年的费马大定理"><a href="#拓展指数——折磨数学家将近400年的费马大定理" class="headerlink" title="拓展指数——折磨数学家将近400年的费马大定理"></a>拓展指数——折磨数学家将近400年的费马大定理</h2><p>1621年法国巴黎有一位20岁的律师买了一本《算术》看。突发奇想，写下一个整数的三次方不能拆分成两个整数的三次方和，一个整数的四次方不能拆分成两个整数的四次方和，以此类推，地方太小，证明过程我就不写了。</p><p>欧拉只证明了费马的前两句话是对的。1995年数学家怀尔斯给出了全部证明。</p><h2 id="拓展项数——某点到原点的距离"><a href="#拓展项数——某点到原点的距离" class="headerlink" title="拓展项数——某点到原点的距离"></a>拓展项数——某点到原点的距离</h2><p>三元组可以求二维直角坐标系中某点到原点的距离，四元组可以求三维直角坐标系中某点到原点的距离。</p><h2 id="放宽等式的右边为一个整数——四平方和定理"><a href="#放宽等式的右边为一个整数——四平方和定理" class="headerlink" title="放宽等式的右边为一个整数——四平方和定理"></a>放宽等式的右边为一个整数——四平方和定理</h2><p>任意的一个正整数都可以写成不超过四个正整数的平方和</p><p>丢番图一笔带过没给证明；费马说地方太小证明写不了；欧拉的学生拉格朗日用欧拉的四平方恒等式在1770年证明了四平方和定理，因此四平方和定理也叫作拉格朗日四平方定理；三年后欧拉也独立给出了证明。</p><h2 id="一个正整数用正整数的更高次方的和来表示需要多少个——华林问题"><a href="#一个正整数用正整数的更高次方的和来表示需要多少个——华林问题" class="headerlink" title="一个正整数用正整数的更高次方的和来表示需要多少个——华林问题"></a>一个正整数用正整数的更高次方的和来表示需要多少个——华林问题</h2><p>1770年，英国数学家华林提出猜想，存在一个正整数g(k)（k表示k次方，g(k)是关于k的函数，如g(2)=4）使得每个正整数可以表示为至多g(k)个k次方数之和。</p><p>1909年，希尔伯特证明了华林猜想是正确的，但仅仅证明了存在g(k)。1909年证明了g(3)=9，1986年g(4)=19，1964年我国数学家陈景润证明了g(5)=37，那年陈景润31岁。</p><p>欧拉的小儿子给出了一个经验公式 g(k)=2^k + [(3/2)^k] - 2（中括号表示向下取整）。人们通过计算机验证，发现大概在1亿以下都是正确的。目前人们还不知道为啥它长这样，也困扰数学家几百年了。</p><h2 id="给四平方和的每个项加一个系数，还能表示所有的正整数呢？"><a href="#给四平方和的每个项加一个系数，还能表示所有的正整数呢？" class="headerlink" title="给四平方和的每个项加一个系数，还能表示所有的正整数呢？"></a>给四平方和的每个项加一个系数，还能表示所有的正整数呢？</h2><p>1916年印度神童拉马努金宣城他找到了所有的系数组合，只有这55组系数的平方数才能表示所有的正整数。其人自学成才，本职会计，33岁因病早逝，一生发现了3900多条数学公式和命题。</p><p>1993年英国数学家康威证明，康威发现拉姆努金给出的55组系数里，除了1、2、5、5不对，其他的54组都对，而且只有这54组。康威的这个证明叫15定理，因为他发现，所有系数的组合你任选一种，只要这个多项式能表示1-15之间的所有数，它就能表示所有的正整数。</p>]]></content>
      
      
      <categories>
          
          <category> 数 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>圆</title>
      <link href="/2021/11/25/%E5%9C%86/"/>
      <url>/2021/11/25/%E5%9C%86/</url>
      
        <content type="html"><![CDATA[<p>参考妈咪说、李永乐的视频</p><p>无论圆的直径是多长，圆的周长比直径似乎都是一个定值，称其为圆周率π</p><h1 id="圆面积"><a href="#圆面积" class="headerlink" title="圆面积"></a>圆面积</h1><p>先把一个圆平均分成若干份，然后将其拼成近似的长方形，最后根据长方形与圆的关系推导出圆的面积公式为πr^2</p><p><img src="/2021/11/25/%E5%9C%86/image-20211125204336403.png" alt="image-20211125204336403"></p><h1 id="角度"><a href="#角度" class="headerlink" title="角度"></a>角度</h1><p>两条直线的夹角，有大有小，用角度来衡量夹角大小。</p><p>设定全角为360°，全角的1/360为1°，1°的1/60是1‘，1’的1/60是1’‘。</p><h1 id="弧度"><a href="#弧度" class="headerlink" title="弧度"></a>弧度</h1><p>欧拉，把长度等于半径长的弧所对的圆心角称为1弧度。</p><p><img src="/2021/11/25/%E5%9C%86/image-20211201192045291.png" alt="image-20211201192045291"></p><h1 id="sin，cos"><a href="#sin，cos" class="headerlink" title="sin，cos"></a>sin，cos</h1><p>从某个角度推一个箱子，力可以被分解为水平和垂直两个方向，其数值符合直角三角形的勾股数。直观感觉：sin，cos是用来分解力的工具。sin公式告诉你水平方向的分力与合力的比值，cos告诉你竖直方向的分力与合力的比值。</p><p>希望你看到公式能立刻想到</p><p>sinθ 是y方向的分解作用，5sinθ表示将合力5分解到y方向</p><p>cosθ 是x方向的分解作用，5cosθ表示将合力5分解到x方向</p><p>tanθ=sinθ/cosθ，是y方向分力与x方向分力的比值</p><h2 id="和差角公式"><a href="#和差角公式" class="headerlink" title="和差角公式"></a>和差角公式</h2><h3 id="巧妙的证明一"><a href="#巧妙的证明一" class="headerlink" title="巧妙的证明一"></a>巧妙的证明一</h3><p><img src="/2021/11/25/%E5%9C%86/image-20211201210031872.png" alt="image-20211201210031872"></p><p><img src="/2021/11/25/%E5%9C%86/image-20211201210424406.png" alt="image-20211201210424406"></p><h3 id="严谨的证明二"><a href="#严谨的证明二" class="headerlink" title="严谨的证明二"></a>严谨的证明二</h3><p>首先给出余弦定律</p><p><img src="/2021/11/25/%E5%9C%86/image-20211201211308352.png" alt="image-20211201211308352"></p><p>通过边长的两种求法，得出cos(α-β)</p><p><img src="/2021/11/25/%E5%9C%86/image-20211201211831165.png" alt="image-20211201211831165"></p><p><img src="/2021/11/25/%E5%9C%86/image-20211201211906135.png" alt="image-20211201211906135"></p><p>我们可以观察到cos(-α)=cosα，sin(-α)=-sinα</p><p>故cos(α+β)=cos(α-(-β))=cosαsinα-sinαsinβ</p><p><img src="/2021/11/25/%E5%9C%86/image-20211201212231554.png" alt="image-20211201212231554"></p><p>我们可以观察到sinα=cos(π/2 - α)</p><p>故sin(α+β)=cos(π/2-(α+β))=cos((π/2-α)-β)=cos(π/2-α)cosβ+sin(π/2-α)sinβ=sinαcosβ+cosαsinβ</p><p><img src="/2021/11/25/%E5%9C%86/image-20211201212602156.png" alt="image-20211201212602156"></p><p>sin(α-β)=sin(α-(-β))=sinαcos(-β)+cosαsin(-β)=sinαcosβ-cosαsinβ</p><h1 id="圆周率"><a href="#圆周率" class="headerlink" title="圆周率"></a>圆周率</h1><h2 id="古代方法-几何逼近"><a href="#古代方法-几何逼近" class="headerlink" title="古代方法-几何逼近"></a>古代方法-几何逼近</h2><h3 id="阿基米德-周长夹逼"><a href="#阿基米德-周长夹逼" class="headerlink" title="阿基米德-周长夹逼"></a>阿基米德-周长夹逼</h3><p>第一个有严谨计算过程记录的圆周率算法，由公元前250年古希腊的阿基米德发明：内切正多边形与外切正多边形夹逼圆的周长。阿基米德一共计算到正96边形，得到223/71＞π&gt;22/7。</p><h3 id="刘徽-面积夹逼"><a href="#刘徽-面积夹逼" class="headerlink" title="刘徽-面积夹逼"></a>刘徽-面积夹逼</h3><p>公元263年左右，三国时期魏国的数学家刘徽使用割圆术：用正多边形的面积夹逼</p><p><img src="/2021/11/25/%E5%9C%86/image-20211125212635164.png" alt="image-20211125212635164"></p><h2 id="现代方法"><a href="#现代方法" class="headerlink" title="现代方法"></a>现代方法</h2><p>法国数学家韦达，提出了第一个π的无穷项公式</p><h3 id="园的内切正多边形的面积"><a href="#园的内切正多边形的面积" class="headerlink" title="园的内切正多边形的面积"></a>园的内切正多边形的面积</h3><p><img src="/2021/11/25/%E5%9C%86/image-20211202111415475.png" alt="image-20211202111415475"></p><h3 id="韦达π公式"><a href="#韦达π公式" class="headerlink" title="韦达π公式"></a>韦达π公式</h3><p>圆的半径为1，内切正四边形面积/圆面积=2/π。</p><p><img src="/2021/11/25/%E5%9C%86/image-20211202111821291.png" alt="image-20211202111821291"></p><h3 id="沃利斯乘积公式"><a href="#沃利斯乘积公式" class="headerlink" title="沃利斯乘积公式"></a>沃利斯乘积公式</h3><p><img src="/2021/11/25/%E5%9C%86/image-20211202113243085.png" alt="image-20211202113243085"></p><p>蒙特卡洛算法：冯诺依曼和乌拉姆发明，因为吾拉姆的叔叔经常去蒙特卡罗赌场，蒙特卡罗是以赌场闻名于世的地方，赌场与概率有关，就叫做蒙特卡罗算法了。</p><h3 id="欧拉-巴塞尔问题"><a href="#欧拉-巴塞尔问题" class="headerlink" title="欧拉-巴塞尔问题"></a>欧拉-巴塞尔问题</h3><h3 id="π的莱布尼兹公式"><a href="#π的莱布尼兹公式" class="headerlink" title="π的莱布尼兹公式"></a>π的莱布尼兹公式</h3><h3 id="高斯-梅钦类公式"><a href="#高斯-梅钦类公式" class="headerlink" title="高斯-梅钦类公式"></a>高斯-梅钦类公式</h3><h3 id="拉马努金"><a href="#拉马努金" class="headerlink" title="拉马努金"></a>拉马努金</h3><p>收敛速度更快</p><h3 id="楚德诺夫斯基兄弟"><a href="#楚德诺夫斯基兄弟" class="headerlink" title="楚德诺夫斯基兄弟"></a>楚德诺夫斯基兄弟</h3><h3 id="蒙特卡洛方法"><a href="#蒙特卡洛方法" class="headerlink" title="蒙特卡洛方法"></a>蒙特卡洛方法</h3><p>落点在圆中的概率=圆面积/正方形比</p><h3 id="布丰的针"><a href="#布丰的针" class="headerlink" title="布丰的针"></a>布丰的针</h3><p><img src="/2021/11/25/%E5%9C%86/image-20211202115148731.png" alt="image-20211202115148731"></p><h3 id="布丰的面条"><a href="#布丰的面条" class="headerlink" title="布丰的面条"></a>布丰的面条</h3>]]></content>
      
      
      <categories>
          
          <category> 数 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>线性变换</title>
      <link href="/2021/11/24/%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2/"/>
      <url>/2021/11/24/%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h1><p>线性代数解决线性问题，把复杂问题线性化是别的学科的内容，比如《微积分》、《信号与系统》。</p><h1 id="线性变换"><a href="#线性变换" class="headerlink" title="线性变换"></a>线性变换</h1><p>线性变换从几何直观有三个要点：</p><ul><li>变换前是直线的，变换后依然是直线的</li><li>直线比例保持不变</li><li>变换前中心是原点的，变换后依然是原点</li></ul><p>比如说旋转：</p><p><img src="/2021/11/24/%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2/image-20211125102736099.png" alt="image-20211125102736099"></p><p><img src="/2021/11/24/%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2/image-20211125102811182.png" alt="image-20211125102811182"></p><p>比如说推移：</p><p><img src="/2021/11/24/%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2/image-20211125102847052.png" alt="image-20211125102847052"></p><p>推移+旋转也是线性变换：</p><p><img src="/2021/11/24/%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2/image-20211125102927298.png" alt="image-20211125102927298"></p><h2 id="代数"><a href="#代数" class="headerlink" title="代数"></a>代数</h2><p>简答讲一下旋转是怎么实现的，可以让我们进一步了解代数是怎么描述线性变换的。</p><p><img src="/2021/11/24/%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2/image-20211125103142346.png" alt="image-20211125103142346"></p><p><img src="/2021/11/24/%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2/image-20211125103220030.png" alt="image-20211125103220030"></p><p><img src="/2021/11/24/%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2/image-20211125103311771.png" alt="image-20211125103311771"></p><p><img src="/2021/11/24/%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2/image-20211125103324199.png" alt="image-20211125103324199"></p><h1 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a>仿射变换</h1><ul><li>变换前是直线的，变换后依然是直线</li><li>直线比例保持不变</li></ul><p>少了原点保持不变这一条。</p><p>比如平移：</p><p><img src="/2021/11/24/%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2/image-20211125103706242.png" alt="image-20211125103706242"></p><p>因此，平移不再是线性变化了，而是仿射变化</p><h2 id="代数-1"><a href="#代数-1" class="headerlink" title="代数"></a>代数</h2><p>线性变换是通过矩阵乘法来实现的，仿射变换不能光通过矩阵乘法来实现，还得有加法。</p><p><img src="/2021/11/24/%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2/image-20211125103837145.png" alt="image-20211125103837145"></p><p><img src="/2021/11/24/%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2/image-20211125103929863.png" alt="image-20211125103929863"></p><p><img src="/2021/11/24/%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2/image-20211125103948702.png" alt="image-20211125103948702"></p><h2 id="通过矩阵乘法来完成仿射"><a href="#通过矩阵乘法来完成仿射" class="headerlink" title="通过矩阵乘法来完成仿射"></a>通过矩阵乘法来完成仿射</h2><p><img src="/2021/11/24/%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2/image-20211125104037280.png" alt="image-20211125104037280"></p>]]></content>
      
      
      <categories>
          
          <category> 数 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>导数</title>
      <link href="/2021/11/22/%E5%AF%BC%E6%95%B0/"/>
      <url>/2021/11/22/%E5%AF%BC%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>参考马同学的众多知乎回答</p><h1 id="导数"><a href="#导数" class="headerlink" title="导数"></a>导数</h1><h2 id="积分的历史背景"><a href="#积分的历史背景" class="headerlink" title="积分的历史背景"></a>积分的历史背景</h2><p>17世纪，当时很重要的问题是天文学问题，其中，开普勒三定律中的第二定律：在相等时间内，太阳和运动着的行星的连线扫过的面积都是相等的。</p><p><img src="/2021/11/22/%E5%AF%BC%E6%95%B0/image-20211124093407128.png" alt="image-20211124093407128"></p><p>既然有计算不规则曲线面积的需求，那么数学家就得去研究，所谓积分就是求曲线下的面积(17世纪，英文中积分”quadrature”的含义就是求面积的意思)：</p><p><img src="/2021/11/22/%E5%AF%BC%E6%95%B0/image-20211124093535271.png" alt="image-20211124093535271"></p><h2 id="积分的思想"><a href="#积分的思想" class="headerlink" title="积分的思想"></a>积分的思想</h2><p><img src="/2021/11/22/%E5%AF%BC%E6%95%B0/image-20211124093705769.png" alt="image-20211124093705769"></p><p><img src="/2021/11/22/%E5%AF%BC%E6%95%B0/image-20211124093729171.png" alt="image-20211124093729171"></p><h2 id="微积分：以直代曲，线性逼近"><a href="#微积分：以直代曲，线性逼近" class="headerlink" title="微积分：以直代曲，线性逼近"></a>微积分：以直代曲，线性逼近</h2><p><img src="/2021/11/22/%E5%AF%BC%E6%95%B0/3c7eb94341181775449815dddb9a6d51_r.jpg" alt="preview"></p><p>微分：无穷小量</p><p>从上图得出导数的定义，f’(x)=dy/dx, 而dx和dy被称为x和y的微分，都为无穷小量。所以导数也被莱布尼兹称为微商(微分之商)</p><h3 id="无穷小量引发第二次数学危机"><a href="#无穷小量引发第二次数学危机" class="headerlink" title="无穷小量引发第二次数学危机"></a>无穷小量引发第二次数学危机</h3><p><img src="/2021/11/22/%E5%AF%BC%E6%95%B0/61ecf4ae56111a5aece4888318c231fc_720w.jpg" alt="img"></p><p>所以就切线的定义而言，微积分的基础是不牢靠的。</p><p>无穷小量的麻烦远不止这一些</p><p><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D++%5Cfrac%7Bd%7D%7Bdx%7D%28x%5E2%29+%26++%3D+%5Cfrac%7Bf%28x%2Bdx%29-f%28x%29%7D%7Bdx%7D+%5C%5C+%26++%3D+%5Cfrac%7B%28x%2Bdx%29%5E2-x%5E2%7D%7Bdx%7D+%5C%5C+%26++%3D+%5Cfrac%7Bx%5E2%2B2xdx%2Bdx%5E2-x%5E2%7D%7Bdx%7D+%5C%5C+%26++%3D+%5Cfrac%7B2xdx%2Bdx%5E2%7D%7Bdx%7D+%5C%5C+%26++%3D+2x%2Bdx+%5C%5C+%26++%3D+2x+%5Cend%7Balign%7D" alt="[公式]"></p><p><img src="/2021/11/22/%E5%AF%BC%E6%95%B0/image-20211124084906806.png" alt="image-20211124084906806"></p><h3 id="基于极限重建微积分"><a href="#基于极限重建微积分" class="headerlink" title="基于极限重建微积分"></a>基于极限重建微积分</h3><p>莱布尼兹、欧拉等人都认识到无穷小量导致的麻烦，一直想要修补。但是这个问题等到200年后，19世界极限的概念清晰之后才得到解决。</p><h4 id="极限"><a href="#极限" class="headerlink" title="极限"></a>极限</h4><p>如何描述△x无限接近于0？</p><p>△x无限接近于0，但不能为0，否则以0为底边长的矩形面积为0，无穷多个0相加仍然为0.</p><p>△x无限接近于0，但不可能是最小的正实数，因为没有最小的正实数（实数0的下一个实数是什么？没有。假设0的下一个实数是a，我们永远可以找到a/2比0大，比a小。）</p><p>现在都是用epsilon-delta语言来描述极限</p><script type="math/tex; mode=display">\epsilon-\delta</script><p><img src="/2021/11/22/%E5%AF%BC%E6%95%B0/0afe3d0aafd33781261c35f90f085a07_r.jpg" alt="preview"></p><p>可以看到，极限的描述并没有用到什么无穷小量</p><p><img src="/2021/11/22/%E5%AF%BC%E6%95%B0/image-20211124095854402.png" alt="image-20211124095854402"></p><h4 id="导数的极限定义"><a href="#导数的极限定义" class="headerlink" title="导数的极限定义"></a>导数的极限定义</h4><p>在点x0的去心邻域内，△x=x-x0，lim(x-&gt;x0)，即lim(△x-&gt;0)。0&lt;△x&lt;delta是一个小范围中某个极小的差值或者说增量。</p><p><img src="/2021/11/22/%E5%AF%BC%E6%95%B0/image-20211124091239643.png" alt="image-20211124091239643"></p><p>如此定义了导数，可以去定义微分</p><p><img src="/2021/11/22/%E5%AF%BC%E6%95%B0/image-20211124090512297.png" alt="image-20211124090512297"></p><p><img src="/2021/11/22/%E5%AF%BC%E6%95%B0/image-20211124090555160.png" alt="image-20211124090555160"></p><p>dy=f’(x)△x，这是dy的定义。我们是在用函数dy(几何上的切线)逼近原函数。</p><h1 id="导数-1"><a href="#导数-1" class="headerlink" title="导数"></a>导数</h1><ul><li>导数是速度、是加速度、是变化率、是切线的斜率。</li><li>导数是用来找到“线性近似的数学工具”</li><li>导数是线性变换</li></ul><h1 id="导数是速度、是加速度、是变化率、是切线的斜率"><a href="#导数是速度、是加速度、是变化率、是切线的斜率" class="headerlink" title="导数是速度、是加速度、是变化率、是切线的斜率"></a>导数是速度、是加速度、是变化率、是切线的斜率</h1><h2 id="物理中的变化率"><a href="#物理中的变化率" class="headerlink" title="物理中的变化率"></a>物理中的变化率</h2><p>一段时间的平均速度是位移/一段时间</p><p><img src="/2021/11/22/%E5%AF%BC%E6%95%B0/image-20211122154918243.png" alt="image-20211122154918243"></p><p>某一时间点的瞬时速度</p><p><img src="/2021/11/22/%E5%AF%BC%E6%95%B0/image-20211122155319038.png" alt="image-20211122155319038"></p><p>速度vt1就是t1点附近，位移增加值△s与时间增加值△t的比值，称这个比值为变化率，描述了t1点附近，时间增加值对位移增加值的影响程度。</p><p><img src="/2021/11/22/%E5%AF%BC%E6%95%B0/image-20211122155447221.png" alt="image-20211122155447221"></p><p>同理，加速度就是速度对于时间的变化率。</p><h2 id="几何的斜率"><a href="#几何的斜率" class="headerlink" title="几何的斜率"></a>几何的斜率</h2><p><img src="/2021/11/22/%E5%AF%BC%E6%95%B0/image-20211122155918858.png" alt="image-20211122155918858"></p><h2 id="但是"><a href="#但是" class="headerlink" title="但是"></a>但是</h2><p>在二元函数中，比如这样一个曲面上的一点α</p><p><img src="/2021/11/22/%E5%AF%BC%E6%95%B0/image-20211124082933644.png" alt="image-20211124082933644"></p><p>在曲面上可以做无数条过α点的曲线</p><p><img src="/2021/11/22/%E5%AF%BC%E6%95%B0/image-20211124083222750.png" alt="image-20211124083222750"></p><p>每根曲线都可能有切线，那么哪根切线的斜率是导数？</p><h1 id="从一元函数到二元函数"><a href="#从一元函数到二元函数" class="headerlink" title="从一元函数到二元函数"></a>从一元函数到二元函数</h1><p>所以我们认为，导数是某一点处，因变量增加值与自变量增加值的比值。导数是瞬时速度，是加速度，是切线的斜率。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>makefile</title>
      <link href="/2021/11/20/makefile/"/>
      <url>/2021/11/20/makefile/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>活动结果非等可能的单个体活动的概率，该如何理解？</title>
      <link href="/2021/11/14/%E4%BD%95%E4%B8%BA%E6%A6%82%E7%8E%87/"/>
      <url>/2021/11/14/%E4%BD%95%E4%B8%BA%E6%A6%82%E7%8E%87/</url>
      
        <content type="html"><![CDATA[<h1 id="试验与活动"><a href="#试验与活动" class="headerlink" title="试验与活动"></a>试验与活动</h1><p>&emsp;&emsp;首先理解这一点，<strong>活动</strong>是每天事件上所发生的一切事，活动必然有参与<strong>活动的单位或称个体</strong>与<strong>活动内容</strong>，经活动内容的作用，活动单位出现某种状态，称为<strong>事件</strong>。活动单位如一条鱼，一个网络包，一个骰子。活动内容是作用在活动单位上的动作，如养一条鱼，发一个网络包，投一个骰子。事件如鱼死，鱼活，网络包丢了，骰子为1。<strong>试验</strong>是被人类观测的，用于总结规律的活动。其试验单位称为<strong>样本点</strong>。</p><p>&emsp;&emsp;人类从<strong>多次大样本的试验</strong>中总结出，<strong>符合某事件的样本点数/样本点总数</strong>为一个<strong>稳定的比例</strong>。称为<strong>该试验中某事件发生的概率</strong>。同时这个经验得出的<strong>概率可以用于推测于类似的活动中，符合某事件的样本点数目</strong>，我们认定概率就是类似活动中某事件发生的比例，已知样本点总数，从而推测出类似活动中，符合某事件样本点的数目。</p><p>&emsp;&emsp;所以说，概率是从大样本试验中来，作用到多个体活动上去。但是，如果作用到单个体活动上呢？为此我们为单个体活动开辟一个活动结果空间。对于硬币类，骰子类活动，它们的活动结果等可能，活动结果空间具有实际意义，如{正，反}，{1,2,3,4,5,6}。可是对发一个网络包，养一条鱼这样的但个体活动而言，活动结果不是等可能的，它们的活动结果空间包含的是虚构出来的等可能活动结果。</p><h1 id="多样本试验得到概率"><a href="#多样本试验得到概率" class="headerlink" title="多样本试验得到概率"></a>多样本试验得到概率</h1><p>&emsp;&emsp;有一个养鱼人的人，发现三种味道鲜美的新鱼群，分别是白鱼，红鱼，黑鱼。一开始都有100条，养鱼人开始养鱼。</p><ul><li>第一季度，白鱼死了2条，红鱼死了3条，黑鱼死了5条。</li><li>第二季度，白鱼死了3条，红鱼死了4条，黑鱼死了10条。</li><li>第三季度，白鱼死了3条，红鱼死了4条，黑鱼死了5条。</li><li>第四季度，白鱼死了4条，红鱼死了4条，黑鱼死了7条。</li></ul><p>&emsp;&emsp;最后，白鱼还剩88条，红鱼还剩85条，黑鱼还剩73条。这一年的成活率为如下表格所示。比例只是单纯的数值比，可以任意缩放，但最好分子分母都要是整数，看着最为亲切。此时，这些比例仅仅就是比例，从事实中诞生，用于优雅地描述今年的一个事实。</p><div class="table-container"><table><thead><tr><th style="text-align:center">白鱼</th><th style="text-align:center">红鱼</th><th style="text-align:center">黑鱼</th></tr></thead><tbody><tr><td style="text-align:center">88/100</td><td style="text-align:center">85/100</td><td style="text-align:center">73/100</td></tr></tbody></table></div><p>&emsp;&emsp;10年里，养鱼人勤勉地记录了10次三种鱼的成活率，对每一种鱼10年的10个比例求平均值。结果为：</p><div class="table-container"><table><thead><tr><th style="text-align:center">白鱼</th><th style="text-align:center">红鱼</th><th style="text-align:center">黑鱼</th></tr></thead><tbody><tr><td style="text-align:center">87/100</td><td style="text-align:center">86/100</td><td style="text-align:center">81/100</td></tr></tbody></table></div><p>&emsp;&emsp;1000年过去了，养鱼人的孩子还在养这三种鱼，并且传承了1000年的三种鱼的成活率数据，对每一种鱼1000年的1000个比例求平均值。结果为：</p><div class="table-container"><table><thead><tr><th style="text-align:center">白鱼</th><th style="text-align:center">红鱼</th><th style="text-align:center">黑鱼</th></tr></thead><tbody><tr><td style="text-align:center">88/100</td><td style="text-align:center">84/100</td><td style="text-align:center">78/100</td></tr></tbody></table></div><p>&emsp;&emsp;<strong>活动和试验</strong>：这份数据是对事实的勤勉记录，养鱼本来只是一种自然<strong>活动</strong>，但是作为人类总结规律的对象时，这些活动可被称为<strong>试验</strong>，试验是一种特殊的活动。从试验中总结出的规律，又能推测未来活动的情况。</p><p>​        <strong>个体空间和个体</strong>：活动中所有个体的集合称为个体空间，活动中的一个单位称为个体。</p><p>&emsp;&emsp;<strong>样本空间和样本点</strong>：试验中的观测单位的集合称为样本空间，一个观测单位称为样本点。</p><p>&emsp;&emsp;<strong>某种事件</strong>：某个个体或样本点出现可能的状态，称为某种事件。比如人踩人事件，鱼活着事件。</p><p>&emsp;&emsp;<strong>试验得出活动中出现某种事件概率</strong>：我们称<strong>经过多次大样本试验得出的，出现某种状态的样本数与样本总数的，稳定的比率</strong>为<strong>该类活动某种事件发生的概率</strong>。可能是在观察了100亿条鱼后，人们发现88亿条鱼活了下来，符合鱼活着事件。由88亿/100亿缩放，得到88/100这个比率，我们称88/100为养鱼活动鱼存活事件发生的概率。这种稳定的比率是某种<strong>稳定的事实</strong>导致的，比如白鱼的基因最好，捕食能力最强，只有少量天敌，而且生存环境没有什么变动，所以在养鱼活动中能稳定地以88/100的比例存活。<strong>小结：活动中某事件出现的概率=符合事件的样本点数/所有样本点数</strong></p><p>&emsp;&emsp;<strong>概率推测活动的某种事件的个体数</strong>：养鱼人的后代，将这一概率(多次大样本试验得到的稳定比率)当做传家宝一样代代相传着，为他们的养鱼活动提供推测。而比例是不看分母分子的规模的，对于10000条鱼，这个概率告诉他们估摸8800条能活。对于100条鱼，这个概率告诉它们，估摸88条能活。<strong>小结：活动中符合某事件的个体数=活动中某事件出现的概率*所有个体数</strong></p><p>&emsp;&emsp;<strong>得出概率的试验，从分母到分子全是整数</strong>：那么对于1条鱼呢？这个概率告诉他们0.88条鱼能活？这听着怪难受的对吗？可是按照比例，这说法还真没错。但是由于概率是我们从先前的大样本试验中总结的，那些观测单位-样本，作为比例分母分子的样本数都是整数。你养100条鱼，我根据先前的经验猜测你会收获88条活鱼吃；你养1000条鱼，我根据先前的经验猜测你会收获880条活鱼吃。你养1条鱼，按照比例缩放是你会收获0.88条活鱼吃？但是对不起，0.88不是个整数，现实生活中没有0.88个鱼的概念。你也不会在某活动中观测到0.88个样本符合某事件。</p><h1 id="单样本多次试验得到概率"><a href="#单样本多次试验得到概率" class="headerlink" title="单样本多次试验得到概率"></a>单样本多次试验得到概率</h1><p>&emsp;&emsp;目前有一种通用的说法，养一条鱼，鱼存活的概率为88/100。</p><p>&emsp;&emsp;这是通过进行多次单样本试验得到的概率。<strong>多次单样本试验相当于一次多样本试验</strong>。养一条鱼100次，相当于养100条鱼1次。</p><p>&emsp;&emsp;我们知道养一条鱼的活动结果只有2个，这鱼活着或者这鱼死了。而且如果重复多次这种活动，我们会发现鱼活着的情况比鱼死要多一些，这两种活动结果是不均等出现的。从多样本试验我们可以推测，养100条鱼，估摸能活88条。养100条鱼，就相当于进行100次养一条鱼的活动，得到100次活动结果，出现88次鱼活着结果，12次鱼死了结果。鱼活着的结果和鱼死了的结果，数量比为88:12。我们因此虚构一个养一条鱼活动的活动结果空间，称有100种结果，88种活结果，12种死结果，我们只关心这两种活动结果的数量比，而不关心88种结果到底都是啥，因为这是一个虚构的活动结果空间。</p><p><img src="/2021/11/14/%E4%BD%95%E4%B8%BA%E6%A6%82%E7%8E%87/image-20211115041338938.png" alt="image-20211115041338938"></p><p>&emsp;&emsp;实际上，我们将100个样本的样本空间映射到了一个样本的虚构结果空间。通过这个虚构的有100个活动结果的活动结果空间，使用养鱼活动中鱼活事件的概率，推测养一条鱼活动的符合事件个体数变得有意义了，概率88/100告诉我们，养一条鱼有100种结果(此时个体变成了结果)，估摸着有88种结果符合事件鱼活着，有12种结果符合事件鱼死了。</p><p>&emsp;&emsp;<strong>用概率推测出来的活动结果，不是事实，完全可以看做是一次完美的试验，我们还能用这种虚构结果空间，去得到多个单样本活动的某种关系事件的概率</strong></p><p>&emsp;&emsp;这样，我们如果想知道进行两次养一条鱼活动，两条鱼同时存活这一事件的概率。就可以虚构两个独立的100种结果的结果空间。两条鱼的结果空间就有100<em>100=10000种结果(鱼1的每一种结果都对应鱼2的100种结果)。符合活着事件的结果有88\</em>88种(鱼1的每一个活着结果都对应鱼2的88种活着结果)。将虚构结果空间看做试验样本空间，所有结果数就是样本总数，符合活着事件的结果数就是符合该事件的样本数，两一条鱼两次，两条鱼都活着的概率就是88*88/100*100。**此时，不可再用多样本试验的角度看待这个概率，因为此时事件已经是某种两次活动中单样本的关系(二元式)了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&emsp;&emsp;不同于抛硬币，投色子这种，天然具有多种等可能活动结果的单个体活动。对于这种天然具有多种等可能活动结果的单个体活动，它们有一个实际有意义的等可能结果空间，如{正，反}，{1,2,3,4,5,6}。</p><p>&emsp;&emsp;对于发送一个网络包，养一条鱼这种，不具有多种等可能活动结果的单个体活动，依据某事件的概率开辟一个活动结果空间，活动结果总数为分母，符合事件的活动结果数位分子。这个活动结果空间虽然是虚构的，但是有意义的，相当于描述了一个样本点总数为概率分母的多样本试验的情况。在虚构活动结果空间的帮助下，某事件的概率能对单个体活动中符合某事件的试验结果数做推测了。并且还可以在此之上研究多个单个体活动某种关系事件发生的概率。</p>]]></content>
      
      
      <categories>
          
          <category> 数 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机中的数值</title>
      <link href="/2021/11/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E6%95%B0%E5%80%BC/"/>
      <url>/2021/11/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E6%95%B0%E5%80%BC/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>套接字网络编程</title>
      <link href="/2021/11/12/%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
      <url>/2021/11/12/%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>主要参考UNIX网络编程卷1: 套接字联网API(第三版)</p><h1 id="套接字对"><a href="#套接字对" class="headerlink" title="套接字对"></a>套接字对</h1><p>发送端的IP地址和端口号与目的端的IP地址和端口号，组成一个套接字对，对应唯一的一个TCP链接</p><p><img src="/2021/11/12/%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20211118171739791.png" alt="image-20211118171739791"></p><h1 id="套接字地址结构"><a href="#套接字地址结构" class="headerlink" title="套接字地址结构"></a>套接字地址结构</h1><h2 id="套接字地址结构-1"><a href="#套接字地址结构-1" class="headerlink" title="套接字地址结构"></a>套接字地址结构</h2><p>大多数套接字函数都需要一个指向套接字地址结构的指针作为参数。</p><p>每个协议族都定义它的套接字地址结构。这些结构的名字均以sockaddr_开头，并以对应每个协议族的唯一后缀结尾，如IPv4套接字地址结构struct sockaddr_in，IPv6套接字地址结构struct sockaddr_in6</p><h3 id="IPV4-sockaddr-in"><a href="#IPV4-sockaddr-in" class="headerlink" title="IPV4 sockaddr_in"></a>IPV4 sockaddr_in</h3><p>通常也被称为”网际套接字地址结构”，它以sockaddr_in命名，定义在<netinet in.h>头文件中。</netinet></p><p><img src="/2021/11/12/%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20211118172548113.png" alt="image-20211118172548113"></p><p><img src="/2021/11/12/%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20211118172732549.png" alt="image-20211118172732549"></p><h3 id="传递套接字地址结构的函数"><a href="#传递套接字地址结构的函数" class="headerlink" title="传递套接字地址结构的函数"></a>传递套接字地址结构的函数</h3><h4 id="从进程传到内核"><a href="#从进程传到内核" class="headerlink" title="从进程传到内核"></a>从进程传到内核</h4><p>bind，connect，sendto</p><p><img src="/2021/11/12/%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20211118173036348.png" alt="image-20211118173036348"></p><h4 id="从内核传到进程"><a href="#从内核传到进程" class="headerlink" title="从内核传到进程"></a>从内核传到进程</h4><p>accept，recvfrom，getsockname，getpeername</p><p><img src="/2021/11/12/%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20211118173043752.png" alt="image-20211118173043752"></p><h3 id="字节排序函数"><a href="#字节排序函数" class="headerlink" title="字节排序函数"></a>字节排序函数</h3><p>网络字节序(network byte order)是大端字节序</p><h4 id="大端小端字节序"><a href="#大端小端字节序" class="headerlink" title="大端小端字节序"></a>大端小端字节序</h4><p>&emsp;&emsp;同时参考了博客<a href="https://www.cnblogs.com/folm/p/12004711.html">大端(Big Endian)/小端(Little Endian)字节序 - Folm - 博客园 (cnblogs.com)</a>。文章写得好，背景也养眼。</p><p>&emsp;&emsp;术语大端小端表示多个字节值(如int, long)的哪一端字节存储在虚拟主存中该值的起始地址。其中MSB表示most significant bit最高位，LSB表示least significant bit最低位。</p><p>&emsp;&emsp;注意！字节序是以字节为单位的，不要考虑单个字节的顺序。</p><p><img src="/2021/11/12/%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20211118173256919.png" alt="image-20211118173256919"></p><p>&emsp;&emsp;看一下虚拟机的字节序：程序中令int a=127，64位系统中，int是4字节。gdb二进制查看内存，4表示看4个字节，t表示以二进制显示，b表示间隔1字节。我们发现内存的低位存放低位，是小端字节序。对于一个字节的8位来讲，并不需要我们去考虑实际存放的顺序。</p><p><img src="/2021/11/12/%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20211119164701545.png" alt="image-20211119164701545" style="zoom:200%;"></p><p>&emsp;&emsp;而网络字节序是大端字节序。int a=127按照主机的小端字节序，一个4字节大小的值在内存中(地址由低到高)依次为0x 8f 00 00 00。在TCP,IP协议看来，高位放在起始地址，这是127左移24位的大小。 </p><p>&emsp;&emsp;为了TCP,IP能正确认出我们填写的服务器ip地址和端口地址，需要将按主机字节序存放的多字节数值，转换成按网络字节序存放的多字节数值。</p><p>&emsp;然而对于网络间用write，read传递的值，强制转换成了const void* buf，所以全是单字节值，不需要考虑字节序。</p><h4 id="主机字节序和网络字节序的转换函数"><a href="#主机字节序和网络字节序的转换函数" class="headerlink" title="主机字节序和网络字节序的转换函数"></a>主机字节序和网络字节序的转换函数</h4><p>其中h表示host，n表示network，s表示short，l表示long</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">htons</span><span class="params">(<span class="keyword">uint16_t</span> host16bitvalue)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">htonl</span><span class="params">(<span class="keyword">uint32_t</span> host32bitvalue)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">ntohs</span><span class="params">(<span class="keyword">uint16_t</span> net16bitvalue)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">ntohl</span><span class="params">(<span class="keyword">uint32_t</span> net32bitvalue)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="字节操纵函数"><a href="#字节操纵函数" class="headerlink" title="字节操纵函数"></a>字节操纵函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bzero</span><span class="params">(<span class="keyword">void</span>* dest, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bcopy</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* src, <span class="keyword">void</span>* dest, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *ptr1, <span class="keyword">const</span> <span class="keyword">void</span>* ptr2, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br></pre></td></tr></table></figure><p>bzero把目标字节串中的指定数目的字节置为0；</p><p>bcopy把指定数目的字节从源字节串移到目标字节串；</p><p>bcmp比较两个任意字节串，相同返回0，不同返回非0.</p><h4 id="IPV4的地址转换函数"><a href="#IPV4的地址转换函数" class="headerlink" title="IPV4的地址转换函数"></a>IPV4的地址转换函数</h4><p>在ASCII字符串(点分十进制数串)与网络字节序的二进制值之间转换网际地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_aton</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* strptr, struct in_addr *addrptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">inet_ntoa</span><span class="params">(struct in_addr inaddr)</span></span>;</span><br></pre></td></tr></table></figure><p>inet_aton将strptr所指C字符串转换成一个32位的网络字节序二进制值，并通过指针addrptr来存储，成功返回1，否则返回0。</p><p>inet_ntoa将一个32位网络字节序的二进制IPv4地址转换成相应的点分十进制数串。</p><h1 id="基本套接字函数"><a href="#基本套接字函数" class="headerlink" title="基本套接字函数"></a>基本套接字函数</h1><p><img src="/2021/11/12/%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20211118175340842.png" alt="image-20211118175340842" style="zoom:150%;"></p><h2 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h2><p>指定期望的通信协议类型，获得一个套接字描述符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> family, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line"><span class="comment">//若成功则为非负描述符，若出错则为-1</span></span><br></pre></td></tr></table></figure><h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><p>把一个本地协议地址(IP地址和端口号)赋予一个套接字描述符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *myaddr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"><span class="comment">//成功返回0，失败返回-1</span></span><br></pre></td></tr></table></figure><h2 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h2><p>TCP客户建立与TCP服务器的连接</p><p><img src="/2021/11/12/%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20211130105238429.png" alt="image-20211130105238429"></p><ol><li>服务器必须准备好接受外来的连接。这通常通过调用socket、bind和listen这3个函数来完成，我们称之为被动打开(passive open)。</li><li>客户通过调用connect发起主动打开(active open)。这导致客户TCP发送一个SYN(同步)分节，它告诉服务器客户将在(待建立的)连接中发送的数据的初始序列号。通常SYN分节不携带数据，其所在的IP数据报只含有一个IP首部、一个TCP首部及可能有的TCP选项。</li><li>服务器必须确认(ACK)客户的SYN,同时自己也得发送一个SYN分节，它还有服务器将在同一连接中发送的数据的初始序列号。服务器在单个分节中发送SYN和对客户SYN的ACK(确认)。</li><li>客户必须确认服务器的SYN。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr* servaddr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"><span class="comment">//成功返回0，出错返回-1</span></span><br></pre></td></tr></table></figure><p>激发三路握手，仅在连接建立成功或出错时才返回：SYN分节无响应，返回ETIMEDOUT错误；响应RST，返回ECONNREFUSED错误；ICMP不可达错误报文，返回EHOSTUNREACH或ENETUNREACH错误。</p><p>若connect失败则套接字不可再用，必须关闭并重新调用socket</p><h2 id="close"><a href="#close" class="headerlink" title="close"></a>close</h2><p>关闭一个套接字描述符</p><p><img src="/2021/11/12/%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20211130110745392.png" alt="image-20211130110745392"></p><ol><li>某个应用进程首先调用close，我们称该端执行主动关闭(active close)。该端的TCP于是发送一个FIN分节，表示数据发送完毕。</li><li>接收到这个FIN的对端执行被动关闭(passive close)。这个FIN由TCP确认。它的接收也作为一个文件结束符(end-of-file)传递给接收端应用进程(放在已排队等候该应用进程接收的任何其他数据之后)，因为FIN的接收意味着接收端应用进程在相应连接上再无额外数据可接收。</li><li>一段时间后，接收到这个文件结束符的应用进程将调用close关闭它的套接字。这导致它的TCP也发送一个FIN。</li><li>接收这个最终FIN的原发送端TCP(即执行主动关闭的那一端)确认这个FIN。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span>;</span><br><span class="line"><span class="comment">//成功返回0，出错返回-1</span></span><br></pre></td></tr></table></figure><h2 id="listen"><a href="#listen" class="headerlink" title="listen"></a>listen</h2><p>由TCP服务器调用，做两件事</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br><span class="line"><span class="comment">//成功返回0，失败返回-1</span></span><br></pre></td></tr></table></figure><ul><li>listen函数指示内核应该接收指向该套接字描述符的连接请求。</li><li>backlog参数规定了内核应该为该套接字描述符排队的最大连接个数。</li></ul><p>监听套接字描述符的两个队列：</p><p><img src="/2021/11/12/%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20211118180647106.png" alt="image-20211118180647106"></p><p><img src="/2021/11/12/%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20211118180652448.png" alt="image-20211118180652448"></p><h2 id="accept"><a href="#accept" class="headerlink" title="accept"></a>accept</h2><p>由TCP服务器调用，用于从已完成连接队列队头取一个已完成连接。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr* cliaddr, <span class="keyword">socklen_t</span>* addrlen)</span></span>;</span><br></pre></td></tr></table></figure><p>内核为每个由服务器进程接受的客户连接创建一个已连接描述符。accept返回已连接描述符，填写客户的套接字地址。</p><h2 id="fork和exec"><a href="#fork和exec" class="headerlink" title="fork和exec"></a>fork和exec</h2><h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><p>fork函数是Unix中派生进程的唯一方法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">//返回：在子进程中为0，在父进程中为子进程ID,若出错则为-1</span></span><br></pre></td></tr></table></figure><p>子进程分享父进程调用fork之前打开的所有描述符，网络服务器利用这个特性让子进程分享已连接套接字，而父进程则关闭这个已连接套接字，子进程则关闭监听套接字。</p><h3 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h3><p>在fork创建新进程后可以调用exec把自身替换成新的程序</p><h3 id="典型的并发服务器程序轮廓"><a href="#典型的并发服务器程序轮廓" class="headerlink" title="典型的并发服务器程序轮廓"></a>典型的并发服务器程序轮廓</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line"><span class="keyword">int</span> listenfd, connfd;</span><br><span class="line">listenfd = socket( ... ); <span class="comment">//fill in sockaddr_in&#123;&#125; with server&#x27;s well-known port</span></span><br><span class="line">listen(listenfd, listenq);</span><br><span class="line"><span class="keyword">for</span> ( ; ; )&#123;</span><br><span class="line">    connfd = accept(listenfd, ... ); <span class="comment">//probably blocks</span></span><br><span class="line">    <span class="keyword">if</span> ( (pid = fork()) == <span class="number">0</span> )&#123;</span><br><span class="line">        close(listenfd);  <span class="comment">//child closes listening socket file descriptor</span></span><br><span class="line">        doit(connfd);  <span class="comment">//process the request</span></span><br><span class="line">        close(connfd);  <span class="comment">//done with this client</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//child terminates</span></span><br><span class="line">    &#125;</span><br><span class="line">    close(connfd);  <span class="comment">//parent closes connected socket fd, and continue listen</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="getsockname和getpeername"><a href="#getsockname和getpeername" class="headerlink" title="getsockname和getpeername"></a>getsockname和getpeername</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockname</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr* lockaddr, <span class="keyword">socklen_t</span>* addrlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getpeername</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr* peeraddr, <span class="keyword">socklen_t</span>* addrlen)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="getsockname返回本地协议地址"><a href="#getsockname返回本地协议地址" class="headerlink" title="getsockname返回本地协议地址"></a>getsockname返回本地协议地址</h3><p>在一个没有调用bind的TCP客户上，connect成功返回后，getsockname用于返回由内核赋予该连接的本地IP地址和本地端口号。</p><p>在以端口号0调用bind(告知内核去选择本地端口号)后，getsockname用于返回由内核赋予的本地端口号</p><p>getpeername返回外地协议地址</p><h3 id="getpeername返回外地协议地址"><a href="#getpeername返回外地协议地址" class="headerlink" title="getpeername返回外地协议地址"></a>getpeername返回外地协议地址</h3><p>服务器调用过accept后再调用fork时，外地套接字地址结构丢失，只能知道已连接套接字描述符，使用getpeername获取客户的套接字地址结构(IP地址和端口号)。</p><h1 id="简易Remote-Procedure-Call"><a href="#简易Remote-Procedure-Call" class="headerlink" title="简易Remote Procedure Call"></a>简易Remote Procedure Call</h1><p>阻塞式/非阻塞式/复用 读写，多进程，多线程的细节将在各个版本迭代中呈现。由于数据都很小，所以read，write一次就行。</p><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>编写一个简易RPC框架：YA-RPC，支持 At-least-once 语义。</p><p>使用YA-RPC编写一个demo程序，实现如下API：</p><p>1）远程调用 float sum(float a, float b)</p><p>2）远程调用 string uppercase(str)</p><p>3）不少于2个客户端，1个服务端 </p><h2 id="版本1-挨个服务，无读写，客户使用本地函数"><a href="#版本1-挨个服务，无读写，客户使用本地函数" class="headerlink" title="版本1 挨个服务，无读写，客户使用本地函数"></a>版本1 挨个服务，无读写，客户使用本地函数</h2><p>YA_RPC框架由YA_PRC.h和YA_RPC.c构成</p><p>YA_RPC.h包含所有需要的库文件和服务器参数。</p><h3 id="希望达到的效果"><a href="#希望达到的效果" class="headerlink" title="希望达到的效果"></a>希望达到的效果</h3><p>client.c，创建一个RPC_Client类的对象cli，调用cli提供的sum和uppercase方法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;YA_RPC.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">RPC_Client cli;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> a = <span class="number">1.1</span>;</span><br><span class="line"><span class="keyword">float</span> b = <span class="number">2.2</span> ;</span><br><span class="line"><span class="keyword">float</span> c = cli.sum(a, b);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;c=&quot;</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> s1 = <span class="string">&quot;it is a test&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> s2 = cli.uppercase(s1);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;s2=&quot;</span>&lt;&lt;s2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>server.c，创建一个RPC_Server类的对象srv，执行srv提供的Do方法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;YA_RPC.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">RPC_Server srv;</span><br><span class="line">srv.Do();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="YA-RPC实现"><a href="#YA-RPC实现" class="headerlink" title="YA_RPC实现"></a>YA_RPC实现</h3><p>YA_RPC.h包含了所有库和宏，客户类和服务器类。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> YA_RPC</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> YA_RPC</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span> <span class="comment">//sockaddr</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;strings.h&gt;</span><span class="comment">//bzero</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span><span class="comment">//inet_aton</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span> <span class="comment">//socket</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span><span class="comment">//close</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span><span class="comment">//strerror</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVADDR <span class="meta-string">&quot;192.168.1.103&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVPORT 9999</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LISTENQ 20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RPC_Client</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">RPC_Client();</span><br><span class="line">~RPC_Client();</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">sum</span><span class="params">(<span class="keyword">float</span> a, <span class="keyword">float</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">uppercase</span><span class="params">(<span class="built_in">string</span> s1)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span><span class="comment">//server&#x27;s sockaddr</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span><span class="comment">//client&#x27;s sockaddr  </span></span><br><span class="line"><span class="keyword">socklen_t</span> clisocklen = <span class="keyword">sizeof</span>(client_addr);<span class="comment">//clent&#x27;s sockaddr length</span></span><br><span class="line"><span class="keyword">int</span> sockfd;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RPC_Server</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">RPC_Server();</span><br><span class="line">~RPC_Server();</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Do</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span><span class="comment">//server&#x27;s sockaddr</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span><span class="comment">//client&#x27;s sockaddr  </span></span><br><span class="line"><span class="keyword">socklen_t</span> clisocklen = <span class="keyword">sizeof</span>(client_addr);<span class="comment">//clent&#x27;s sockaddr length</span></span><br><span class="line"><span class="keyword">int</span> listenfd, connfd;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>YA_RPC.c给出了客户类和服务器类的具体实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;YA_RPC.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Client</span></span><br><span class="line">RPC_Client::RPC_Client()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// user fill in server&#x27;s information (struct sockaddr_in) </span></span><br><span class="line">bzero(&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">server_addr.sin_family = AF_INET;</span><br><span class="line">server_addr.sin_port = htons(SERVPORT);</span><br><span class="line">inet_aton(SERVADDR, &amp;(server_addr.sin_addr));</span><br><span class="line"></span><br><span class="line"><span class="comment">//create sockfd</span></span><br><span class="line"><span class="keyword">int</span> sockfd;</span><br><span class="line"><span class="keyword">if</span>( (sockfd=socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) == <span class="number">-1</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Socket Error:&quot;</span>&lt;&lt; strerror(errno)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//connect</span></span><br><span class="line">connect(sockfd, (struct sockaddr*)(&amp;server_addr), <span class="keyword">sizeof</span>(struct sockaddr));</span><br><span class="line"><span class="comment">//print client&#x27;s sockaddr information</span></span><br><span class="line">getsockname(sockfd, (struct sockaddr*)&amp;client_addr, &amp;clisocklen);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;connect success! &quot;</span>&lt;&lt;<span class="string">&quot;server&#x27;s ip: &quot;</span>&lt;&lt;inet_ntoa(client_addr.sin_addr)&lt;&lt;<span class="string">&quot; port: &quot;</span>&lt;&lt;ntohs(client_addr.sin_port)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RPC_Client::~RPC_Client()</span><br><span class="line">&#123;</span><br><span class="line">close(sockfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">RPC_Client::sum</span><span class="params">(<span class="keyword">float</span> a, <span class="keyword">float</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">float</span> c = a+b;</span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">RPC_Client::uppercase</span><span class="params">(<span class="built_in">string</span> s1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">transform(s1.begin(), s1.end(), s1.begin(), ::<span class="built_in">toupper</span>);</span><br><span class="line"><span class="keyword">return</span> s1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Server</span></span><br><span class="line">RPC_Server::RPC_Server()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//create a socket</span></span><br><span class="line">listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//fill in server&#x27;s sockaddr information</span></span><br><span class="line">bzero(&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">server_addr.sin_family = AF_INET;</span><br><span class="line">inet_aton(SERVADDR,&amp;(server_addr.sin_addr)); <span class="comment">//ip</span></span><br><span class="line">server_addr.sin_port = htons(SERVPORT); <span class="comment">//port</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//bind server&#x27;s sockaddr with socket</span></span><br><span class="line">bind(listenfd,(sockaddr *)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line"></span><br><span class="line"><span class="comment">//change the socket as listen socket</span></span><br><span class="line">listen(listenfd, LISTENQ); <span class="comment">//LISTENQ sets number of 2 listen array (connecting and conneted);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RPC_Server::Do</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//accept and do</span></span><br><span class="line"><span class="keyword">for</span>( ; ; )&#123;</span><br><span class="line">connfd = accept(listenfd,(sockaddr*)&amp;client_addr, &amp;clisocklen);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;client&#x27;s ip: &quot;</span>&lt;&lt;inet_ntoa(client_addr.sin_addr)&lt;&lt;<span class="string">&quot; port: &quot;</span>&lt;&lt;ntohs(client_addr.sin_port)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//here we wait user to close the tcp link</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RPC_Server::~RPC_Server()</span><br><span class="line">&#123;</span><br><span class="line">close(listenfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="版本2-挨个服务，阻塞式读写，客户接收服务器的结果"><a href="#版本2-挨个服务，阻塞式读写，客户接收服务器的结果" class="headerlink" title="版本2 挨个服务，阻塞式读写，客户接收服务器的结果"></a>版本2 挨个服务，阻塞式读写，客户接收服务器的结果</h2><p>修改YA_RPC.c中客户类的sum和uppercase方法，修改服务器类的Do方法，新增sum和uppercase方法。</p><p>后面的版本客户都是接收服务器返回的结果了。</p><h3 id="套接字的发送缓冲区"><a href="#套接字的发送缓冲区" class="headerlink" title="套接字的发送缓冲区"></a>套接字的发送缓冲区</h3><p>&emsp;&emsp;每一个socket都有一个发送缓冲区，当某个应用进程写数据到一个套接字中时，内核从该应用进程的缓冲区(这里用虚拟主存感觉比缓冲区要好)中复制所有数据到所写套接字的发送缓冲区。如果该套接字的发送缓冲区容不下该应用进程的所有数据(或是应用进程的缓冲区大于套接字的发送缓冲区，或是套接字的发送缓冲区中已有其他数据)，该应用程序将被投入睡眠。</p><p>&emsp;&emsp;可以用SO_SNDBUF套接字选项来更改缓冲区大小。MSS (Maximum Segment Szie)最大报文大小是网络层报文的最大字节数，MTU(Maximum Ttransmission Unit)最大传输单位是链路层帧的最大字节数。</p><p><img src="/2021/11/12/%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20211119142148537.png" alt="image-20211119142148537"></p><p>&emsp;&emsp;这一端的TCP提取套接字发送缓冲区中的数据把它发送给对端TCP。对端TCP必须确认收到的数据，伴随来自对打的ACK不断到达，本段TCP才能从套接字发送缓冲区丢弃已确认的数据。TCP必须为已发送的数据保留一个副本，直到它被对端确认为止。</p><p>&emsp;&emsp;每个套接字一个的发送缓冲区中的数据经过TCP,IP协议的处理，变成一个一个的分组传到数据链路的输出队列，如果队列已满，新到的分组将被丢弃，并沿着协议栈向上返回一个错误。TCP将注意到这个错误，并在以后某个时刻重传相应的分节。应用进程并不知道这种暂时的情况。</p><h3 id="套接字的接收缓冲区"><a href="#套接字的接收缓冲区" class="headerlink" title="套接字的接收缓冲区"></a>套接字的接收缓冲区</h3><p>&emsp;&emsp;相应的，每一个套接字除了有一个发送缓冲区，还有一个接收缓冲区。对端发来的数据会被缓存入套接字的接收缓冲区，应用进程一直没有读取的话，此数据会一直缓存在相应socket的接收缓冲区内。</p><h3 id="阻塞式写接收缓冲区"><a href="#阻塞式写接收缓冲区" class="headerlink" title="阻塞式写接收缓冲区"></a>阻塞式写接收缓冲区</h3><p>&emsp;&emsp;write不一定写入你希望它写的字节数，因为发送缓冲区可能不够，成功时它返回实际写入的字节数；</p><p>&emsp;&emsp;如果失败返回-1，错误码放入errno(在errno.h中定义)中；具体错误和对应的errno如下：</p><ul><li>阻塞时被中断，进程被信号唤醒，由内核态返回用户态。（The call was interrupted by a signal before any data was written），errno为EINTR</li></ul><p>&emsp;&emsp;缓冲区满时阻塞。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>;</span><br><span class="line"> </span><br><span class="line">如果顺利write()会返回实际写入的字节数。当有错误发生时则返回<span class="number">-1</span>，错误代码存入errno中。</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;为了尽可能一次写n个字节，构造writen函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">writen</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span>* vptr, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> nleft;<span class="comment">//left bytes to write</span></span><br><span class="line">    <span class="keyword">ssize_t</span> nwritten;<span class="comment">//bytes have written</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* ptr;</span><br><span class="line">    </span><br><span class="line">    ptr = vptr;</span><br><span class="line">    nleft = n;</span><br><span class="line">    <span class="keyword">while</span> (nleft&gt;<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>( ( nwritten = write(fd, ptr, nleft) ) &lt;= <span class="number">0</span> )&#123;</span><br><span class="line">              <span class="keyword">if</span>(nwritten&lt;<span class="number">0</span> &amp;&amp; errno==EINTR)</span><br><span class="line">                  nwritten = <span class="number">0</span>;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          nleft -= nwritten;</span><br><span class="line">          ptr += nwritten;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="阻塞式读接收缓冲区"><a href="#阻塞式读接收缓冲区" class="headerlink" title="阻塞式读接收缓冲区"></a>阻塞式读接收缓冲区</h3><p>&emsp;&emsp;read不一定读取你希望它读的字节数，因为数据可能没有全部赋值到接收缓冲区中，成功时它返回实际读取的字节数；</p><p>&emsp;&emsp;如果失败返回-1并设置errno；</p><p>&emsp;&emsp;接收缓冲区空时阻塞。</p><p>&emsp;&emsp;如果返回0，表示链接关闭。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>;</span><br><span class="line"> </span><br><span class="line">成功返回读取的字节数，出错返回<span class="number">-1</span>并设置errno，如果在调read之前已到达文件末尾，则这次read返回<span class="number">0</span>。</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;为了尽可能读n个字节，构造readn函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">readn</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span>* vptr, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> nleft;<span class="comment">//left bytes to read</span></span><br><span class="line">    <span class="keyword">ssize_t</span> nread;<span class="comment">//bytes have read</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* ptr;</span><br><span class="line">    </span><br><span class="line">    ptr = vptr;</span><br><span class="line">    nleft = n;</span><br><span class="line">    <span class="keyword">while</span> (nleft&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>( ( nread = read(fd, ptr, nleft) ) &lt; <span class="number">0</span> )&#123;</span><br><span class="line">              <span class="keyword">if</span>(errno==EINTR)</span><br><span class="line">                  nread = <span class="number">0</span>;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>)</span><br><span class="line">              <span class="keyword">break</span>;<span class="comment">/*EOF*/</span></span><br><span class="line">          nleft -= nread;</span><br><span class="line">          ptr += nread;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (n-nleft);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从一个套接字接收缓冲区中读文本行，一次1字节</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">readline</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span>* vptr, <span class="keyword">size_t</span> maxlen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">ssize_t</span> n, readnum;</span><br><span class="line">    <span class="keyword">char</span> c, *ptr;</span><br><span class="line">    </span><br><span class="line">    ptr = vptr;</span><br><span class="line">    <span class="keyword">for</span> (n=<span class="number">1</span>; n&lt;maxlen; n++)&#123;</span><br><span class="line">        again:</span><br><span class="line">        <span class="keyword">if</span>( (readnum = read(fd, &amp;c, <span class="number">1</span>)) == <span class="number">1</span> )&#123;</span><br><span class="line">            *ptr++ = c;<span class="comment">/* equals ptr=c ptr+=1 */</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">/*new line is stored*/</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (readnum == <span class="number">0</span>)&#123;</span><br><span class="line">            *ptr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> (n<span class="number">-1</span>);<span class="comment">/* EOF, n-1 bytes were read*/</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">                <span class="keyword">goto</span> again;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">/* error */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *ptr = <span class="number">0</span>;<span class="comment">/* null terminate */</span></span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;每读一字节就调用一次系统的read函数，PAINFULLY SLOW!(极端痛苦的慢)。我们可以一次读很多字节到应用进程的缓存，再挨个读缓存中的字节，就这样改写readline。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> read_cnt;<span class="comment">//bytes in readbuf</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span>* read_ptr;<span class="comment">//address of readbuf</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> readbuf[MAXLINE];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">my_read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span>* ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (read_cnt &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        again:</span><br><span class="line">        <span class="keyword">if</span> ( (read_cnt = read(fd, read_buf, <span class="keyword">sizeof</span>(read_buf))) &lt; <span class="number">0</span> )&#123;<span class="comment">//try to read read_buf bytes</span></span><br><span class="line">            <span class="keyword">if</span>(errno == EINTR)<span class="comment">/* interrupt */</span></span><br><span class="line">                <span class="keyword">goto</span> again;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(read_cnt == <span class="number">0</span>)<span class="comment">/* EOF */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        read_ptr = read_buf;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    read_cnt--;</span><br><span class="line">    *ptr = *read_ptr++;<span class="comment">//return char to c and readptr+=1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">readline</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span>* vptr, <span class="keyword">size_t</span> maxlen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">ssize_t</span> n, readnum;</span><br><span class="line">    <span class="keyword">char</span> c, *ptr;</span><br><span class="line">    </span><br><span class="line">    ptr = vptr;</span><br><span class="line">    <span class="keyword">for</span> (n=<span class="number">1</span>; n&lt;maxlen; n++)&#123;</span><br><span class="line">        again:</span><br><span class="line">        <span class="keyword">if</span>( (readnum = my_read(fd, &amp;c)) == <span class="number">1</span> )&#123;</span><br><span class="line">            *ptr++ = c;<span class="comment">/* equals ptr=c ptr+=1 */</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">/*new line is stored*/</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (readnum == <span class="number">0</span>)&#123;</span><br><span class="line">            *ptr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> (n<span class="number">-1</span>);<span class="comment">/* EOF, n-1 bytes were read*/</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">/* error */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *ptr = <span class="number">0</span>;<span class="comment">/* null terminate */</span></span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">readlinebuf</span><span class="params">(<span class="keyword">void</span>** vptrptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (read_cnt)</span><br><span class="line">        *vptrptr = read_ptr;</span><br><span class="line">    <span class="keyword">return</span> read_cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;my_read每次最多读MAXLINE个字符，然后每次返回一个字符。readlinebuf函数可以展示应用进程虚拟主存中的缓冲区是什么状态(还剩多少字符，剩余字符的起始位置)，便于调用者查看当前文本行之后是否收到了新的数据。</p><h3 id="改写版本1至版本2时，出现的bug"><a href="#改写版本1至版本2时，出现的bug" class="headerlink" title="改写版本1至版本2时，出现的bug"></a>改写版本1至版本2时，出现的bug</h3><h4 id="1-sockfd没用类的成员变量，用了局部变量"><a href="#1-sockfd没用类的成员变量，用了局部变量" class="headerlink" title="1. sockfd没用类的成员变量，用了局部变量"></a>1. sockfd没用类的成员变量，用了局部变量</h4><p>&emsp;&emsp;DEBUG半天，发现自己在客户类的构造函数中用了局部变量sockfd，而没用类的成员变量sockfd，导致退出构造函数后，sockfd的值3丢失，变成了1。我还纳闷为什么我write东西给服务器，本地却显示一些奇怪的字符呢。原来套接字描述符变了。我在茫然地debug2个小时候，gdb打印sockfd发现是0。实在是印象深刻。</p><p><img src="/2021/11/12/%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20211119194223391.png" alt="image-20211119194223391"></p><p><img src="/2021/11/12/%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20211119194311326.png" alt="image-20211119194311326"></p><h4 id="2-char-s-”it-is-a-test”是常量，地址不可访问，故不可修改"><a href="#2-char-s-”it-is-a-test”是常量，地址不可访问，故不可修改" class="headerlink" title="2. char* s=”it is a test”是常量，地址不可访问，故不可修改"></a>2. char* s=”it is a test”是常量，地址不可访问，故不可修改</h4><p>&emsp;&emsp;用char s[] = “it is a test”就可以了。或者在客户端的uppercase函数里再申请一个新数组，就不麻烦用户了。</p><h3 id="版本2的具体实现"><a href="#版本2的具体实现" class="headerlink" title="版本2的具体实现"></a>版本2的具体实现</h3><h3 id="RPC-Server-Do监听客户想调用什么函数"><a href="#RPC-Server-Do监听客户想调用什么函数" class="headerlink" title="RPC_Server::Do监听客户想调用什么函数"></a>RPC_Server::Do监听客户想调用什么函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RPC_Server::Do</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> require; <span class="comment">// 1-sum; 2-uppercase</span></span><br><span class="line"><span class="comment">//accept and do</span></span><br><span class="line"><span class="keyword">for</span>( ; ; )&#123;</span><br><span class="line">connfd = accept(listenfd,(sockaddr*)&amp;client_addr, &amp;clisocklen);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;client&#x27;s ip: &quot;</span>&lt;&lt;inet_ntoa(client_addr.sin_addr)&lt;&lt;<span class="string">&quot; port: &quot;</span>&lt;&lt;ntohs(client_addr.sin_port)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>( ; ; )&#123;<span class="comment">//read the require</span></span><br><span class="line"><span class="keyword">ssize_t</span> r;</span><br><span class="line"><span class="keyword">if</span> ( ( r = read(connfd, &amp;require, <span class="keyword">sizeof</span>(<span class="keyword">char</span>))) &lt;= <span class="number">0</span> )&#123;</span><br><span class="line"><span class="keyword">break</span>;<span class="comment">//link terminate</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>( require == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;sum();</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>( require == <span class="string">&#x27;2&#x27;</span>)&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;uppercase();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;require error!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//wait user close the tcp link</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="服务器和客户端的sum"><a href="#服务器和客户端的sum" class="headerlink" title="服务器和客户端的sum"></a>服务器和客户端的sum</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RPC_Server::sum</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">float</span> a, b;</span><br><span class="line">read(connfd, &amp;a, <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">read(connfd, &amp;b, <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line"><span class="keyword">float</span> c = a+b;</span><br><span class="line">    write(connfd, &amp;c, <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">RPC_Client::sum</span><span class="params">(<span class="keyword">float</span> a, <span class="keyword">float</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> require = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"><span class="keyword">float</span> c;</span><br><span class="line">write(sockfd, &amp;require, <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">write(sockfd, &amp;a, <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">write(sockfd, &amp;b, <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">read(sockfd, &amp;c, <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务器和客户端的uppercase"><a href="#服务器和客户端的uppercase" class="headerlink" title="服务器和客户端的uppercase"></a>服务器和客户端的uppercase</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RPC_Server::uppercase</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> size;</span><br><span class="line">    read(connfd, &amp;size, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* s = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(size); <span class="comment">//require mem</span></span><br><span class="line">read(connfd, s, size);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size<span class="number">-1</span>; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(s[i]&gt;=<span class="string">&#x27;a&#x27;</span> &amp;&amp; s[i]&lt;=<span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">s[i] += (<span class="string">&#x27;A&#x27;</span>-<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">write(connfd, s, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">RPC_Client::uppercase</span><span class="params">(<span class="keyword">char</span>* s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> require = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">write(sockfd, &amp;require, <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line"><span class="keyword">int</span> size = <span class="built_in">strlen</span>(s) + <span class="number">1</span>;<span class="comment">//contain &#x27;\0&#x27;</span></span><br><span class="line">write(sockfd, &amp;size, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">write(sockfd, s, size);</span><br><span class="line"><span class="keyword">char</span>* s1 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(size);</span><br><span class="line">read(sockfd, s1, size);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> s1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="版本3-多进程服务，阻塞式读写"><a href="#版本3-多进程服务，阻塞式读写" class="headerlink" title="版本3 多进程服务，阻塞式读写"></a>版本3 多进程服务，阻塞式读写</h2><h3 id="把要写的内容放在一起"><a href="#把要写的内容放在一起" class="headerlink" title="把要写的内容放在一起"></a>把要写的内容放在一起</h3><p>&emsp;&emsp;客户类的sum函数先后调用系统write三次发送请求标志和两个参数，可以把它们放到一个结构体中中，仅调用一次write。服务器类在Do函数中读一次请求标志选择执行的函数，在sum函数中读出2个剩余的float。由于uppercase函数传递长度未知的字符串，所以仍然需要先读size，再在堆上申请一块空间来存放字符串。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SumData</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> require;</span><br><span class="line"><span class="keyword">float</span> a;</span><br><span class="line"><span class="keyword">float</span> b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">RPC_Client::sum</span><span class="params">(<span class="keyword">float</span> a, <span class="keyword">float</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SumData</span> <span class="title">sumdata</span>;</span></span><br><span class="line">sumdata.require = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">sumdata.a = a;</span><br><span class="line">sumdata.b = b; </span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> c;</span><br><span class="line">write(sockfd, &amp;sumdata, <span class="keyword">sizeof</span>(sumdata));</span><br><span class="line">read(sockfd, &amp;c, <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RPC_Server::sum</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SumData</span> <span class="title">sumdata</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SumData</span>* <span class="title">p</span> =</span> &amp;sumdata;</span><br><span class="line">(connfd, (<span class="keyword">char</span>*)p+<span class="number">1</span>, <span class="keyword">sizeof</span>(sumdata)<span class="number">-1</span>);<span class="comment">//char require has read by Do()</span></span><br><span class="line"><span class="keyword">float</span> c = sumdata.a+sumdata.b;</span><br><span class="line">write(connfd, &amp;c, <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="fork-1"><a href="#fork-1" class="headerlink" title="fork"></a>fork</h3><p>服务器改写Do函数：子进程分享父进程调用fork之前打开的所有描述符，网络服务器利用这个特性让子进程分享已连接套接字，而父进程则关闭这个已连接套接字，子进程则关闭监听套接字。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RPC_Server::Do</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pid_t</span> childpid;</span><br><span class="line"><span class="keyword">char</span> require; <span class="comment">// 1-sum; 2-uppercase</span></span><br><span class="line"><span class="comment">//accept and do</span></span><br><span class="line"><span class="keyword">for</span>( ; ; )&#123;</span><br><span class="line">connfd = accept(listenfd,(sockaddr*)&amp;client_addr, &amp;clisocklen);</span><br><span class="line"><span class="keyword">if</span>( (childpid = fork()) == <span class="number">0</span> )&#123;</span><br><span class="line">close(listenfd); <span class="comment">/* child closes listen socketfd */</span></span><br><span class="line"><span class="comment">//read the require</span></span><br><span class="line"><span class="keyword">for</span>( ; ; )&#123;</span><br><span class="line"><span class="keyword">if</span> ( ( read(connfd, &amp;require, <span class="keyword">sizeof</span>(<span class="keyword">char</span>))) &lt;= <span class="number">0</span> )&#123;</span><br><span class="line"><span class="keyword">break</span>;<span class="comment">//link terminate</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>( require == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;sum();</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>( require == <span class="string">&#x27;2&#x27;</span>)&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;uppercase();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;require error!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">close(connfd); <span class="comment">/* parent closes connected socketfd */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端也改成多进程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;YA_RPC.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=<span class="number">100</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;int process &quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot; :&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">pid_t</span> childpid;</span><br><span class="line"><span class="keyword">if</span>( (childpid = fork()) == <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">RPC_Client cli;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> a = <span class="number">1.1</span>;</span><br><span class="line"><span class="keyword">float</span> b = <span class="number">2.2</span> ;</span><br><span class="line"><span class="keyword">float</span> c = cli.sum(a, b);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;c=&quot;</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* s1 = <span class="string">&quot;it is a test&quot;</span>;</span><br><span class="line"><span class="keyword">char</span>* s2 = cli.uppercase(s1);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;s2=&quot;</span>&lt;&lt;s2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="版本4-多线程服务，阻塞式读写"><a href="#版本4-多线程服务，阻塞式读写" class="headerlink" title="版本4 多线程服务，阻塞式读写"></a>版本4 多线程服务，阻塞式读写</h2><h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3><p>fork是昂贵的，线程的创建比进程快10-100倍，线程间通信也更容易。</p><p>线程共享：全局变量，进程指令，大多数数据，打开的文件(即描述符)，信号处理函数和信号处置，当前工作目录，用户ID和组ID。</p><p>线程独有：线程ID，寄存器集合包括程序计数器和栈指针，栈(用于存放局部变量和返回地址)，errno，信号掩码，优先级。</p><p>现在在主线程中accept已连接套接字，创建线程服务该已连接套接字</p><h3 id="线程的创建和终止"><a href="#线程的创建和终止" class="headerlink" title="线程的创建和终止"></a>线程的创建和终止</h3><h4 id="pthread-create创建一个线程"><a href="#pthread-create创建一个线程" class="headerlink" title="pthread_create创建一个线程"></a>pthread_create创建一个线程</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span> *tid, <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">void</span> *(*func)(<span class="keyword">void</span> *), <span class="keyword">void</span> *arg)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>pthread_t *tid：一个进程内的每个线程都由线程ID标识，数据类型是pthread_t(往往是unsigned int)。如果新的线程成功创建，其ID就通过tid指针返回。</li><li>pthread_attr_t *attr：每个线程有许多属性：优先级、初始栈大小、是否该成为一个守护线程，等等。可以在创建线程时初始化一个取代默认设置的pthread_attr_t变量指定这些属性。空指针即采纳默认设置</li><li>void<em> (</em>func)(void <em>)，void </em>arg：func所指函数作为参数接受一个通用指针(void <em>),又作为返回值返回一个通用指针(void </em>)。该函数的唯一调用参数是指针arg，如果我们需要给该函数传递多个参数，我们就得把它们打包成一个结构。</li><li>返回值：成功返回0，出错返回某个非0值，与套接字函数及大多数系统调用出错时返回-1并设置errno为某个正直的做法不同的是：Pthread函数出错时作为函数返回值返回正值错误指示。Pthread函数不设置errno</li></ul><h4 id="pthread-join等待某个线程终止"><a href="#pthread-join等待某个线程终止" class="headerlink" title="pthread_join等待某个线程终止"></a>pthread_join等待某个线程终止</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> *tid, <span class="keyword">void</span> **status)</span></span>;</span><br></pre></td></tr></table></figure><p>如果status指针非空，来自所等待线程的返回值(一个指向某个对象的指针)将存入由status指向的位置。</p><h4 id="pthread-self获取自身线程ID"><a href="#pthread-self获取自身线程ID" class="headerlink" title="pthread_self获取自身线程ID"></a>pthread_self获取自身线程ID</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pthread_t</span> <span class="title">pthread_self</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br></pre></td></tr></table></figure><h4 id="pthread-detach将指定线程变成脱离状态"><a href="#pthread-detach将指定线程变成脱离状态" class="headerlink" title="pthread_detach将指定线程变成脱离状态"></a>pthread_detach将指定线程变成脱离状态</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="keyword">pthread_t</span> tid)</span></span>;</span><br></pre></td></tr></table></figure><p>一个线程是可汇合的(joinable,默认值)，或者是脱离的(detached)。当一个可汇合的线程终止时，它的线程ID和退出状态将留存到另一个线程对它调用pthread_join。脱离的线程却像守护进程，当它们终止时，所有相关资源都被释放。本函数通常由想让自己脱离的线程调用，就如该语句pthread_detach(pthread_self());</p><h4 id="pthread-exit退出线程"><a href="#pthread-exit退出线程" class="headerlink" title="pthread_exit退出线程"></a>pthread_exit退出线程</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span> *status)</span></span>;</span><br></pre></td></tr></table></figure><p>如果线程未曾脱离，它的线程ID和退出状态将一直留存到调用进程内的某个其他线程对它调用pthread_join。指针status不能指向局部于调用线程的对象，因为线程终止时这样的对象也消失。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>客户类没有变动，服务器类发生改变</p><p>Do函数现在为每一个accept的已连接套接字创建一个线程，传递套接字去执行doit函数。</p><p>考虑到线程切换引起的内核态和用户态的切换，可能导致系统调用中断，所以用版本2中提到的相对可靠的readn和writen取代read和write。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RPC_Server::Do</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//accept and create thread to handle</span></span><br><span class="line"><span class="keyword">for</span>( ; ; )&#123;</span><br><span class="line">connfd = accept(listenfd,(sockaddr*)&amp;client_addr, &amp;clisocklen);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;client&#x27;s ip: &quot;</span>&lt;&lt;inet_ntoa(client_addr.sin_addr)&lt;&lt;<span class="string">&quot; port: &quot;</span>&lt;&lt;ntohs(client_addr.sin_port)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">pthread_t</span> tid;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;new connfd is &quot;</span>&lt;&lt;connfd&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">pthread_create(&amp;tid, <span class="literal">NULL</span>, &amp;doit, (<span class="keyword">void</span>*) connfd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">RPC_Server::doit</span><span class="params">(<span class="keyword">void</span>* connfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> tconnfd = (<span class="keyword">int</span>)connfd;</span><br><span class="line">pthread_detach(pthread_self());</span><br><span class="line"><span class="keyword">ssize_t</span> r;</span><br><span class="line"><span class="keyword">char</span> require;</span><br><span class="line"><span class="keyword">for</span>( ; ; )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ( ( r = readn(tconnfd, &amp;require, <span class="keyword">sizeof</span>(<span class="keyword">char</span>))) &lt;= <span class="number">0</span> )&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;pthread_self()&lt;&lt;<span class="string">&quot; doit connfd &quot;</span>&lt;&lt;tconnfd&lt;&lt;<span class="string">&quot; r=&quot;</span>&lt;&lt;r&lt;&lt;<span class="string">&quot;,require=&quot;</span>&lt;&lt;require&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span>( require == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">sum(tconnfd);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>( require == <span class="string">&#x27;2&#x27;</span>)&#123;</span><br><span class="line">uppercase(tconnfd);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;pthread_self()&lt;&lt;<span class="string">&quot; doit connfd &quot;</span>&lt;&lt;tconnfd&lt;&lt;<span class="string">&quot; require error!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">close(tconnfd); <span class="comment">/* done with connected socket */</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将服务器类的sum和uppercase成员函数改成static函数，因为只传递了connfd给线程(原因见下面的错误3)，为了让线程在没有服务器类对象的this指针的情况下，可以调用该对象的方法，才将sum和uppercase成员函数改成static函数。</p><h3 id="犯的错误"><a href="#犯的错误" class="headerlink" title="犯的错误"></a>犯的错误</h3><ol><li>在服务器每个线程执行的doit函数中，没有for循环监听客户的require，导致服务完一个函数sum后，链接关闭，不再服务uppercase</li><li>每个线程都根据客户的require字节调用sum或uppercase函数处理之后客户传来的参数，在sum和uppercase中用的是成员变量connfd，多进程中，每个进程都有一个不同的connfd并没有问题，然而多线程中，线程共用一个connfd，就会出错，需要给sum和uppercase传递已连接套接字描述符作为参数。</li><li>仅仅观察三个线程，发现第三个线程和第二个线程的文件描述符相同。原因是我传参给线程的时候，传递了地址，因为void*只能传8字节的数据或者地址。而我想传递connfd和对象指针，传递connfd是为了区分链接，传递对象指针是为了调用sum和uppercase，看来只能用键或者不传递this指针了，我选择不传this。这个错误最为致命，我打印了所有的线程id和connfd才看出问题来。</li></ol><h2 id="版本5-线程池服务，阻塞式读写"><a href="#版本5-线程池服务，阻塞式读写" class="headerlink" title="版本5 线程池服务，阻塞式读写"></a>版本5 线程池服务，阻塞式读写</h2><p>网络编程卷1：联网套接字API中，第三十章客户/服务器程序设计范式中给出的图：</p><p><img src="/2021/11/12/%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20211129221657131.png" alt="image-20211129221657131"></p><p>每个线程各自accept取listen套接字维护的的队列中的已连接套接字，进行服务，不停重复这一过程。或者由主线程统一accept再分配给线程进行服务。</p><p>前者比后者更快，所以让每个线程各自accept。每个线程中用互斥锁保护一个accept函数，因为如果使用无锁版本，可能同时有多个accept函数阻塞，当listenfd监听套接字的已连接套接字队列中有已连接套接字时，还要内核花时间决定分给哪个accept，花费一些用户时间来决定哪个accept接收已连接套接字将节省更多内核时间。</p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p> 在YA_PRC.h文件中增加NTHREADS宏为线程数量，线程数组(线程池)的组成结构，其中包含线程ID和已服务链接的计数器，在YA_RPC.h中的Server类中加一个线程数组指针和互斥锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NTHREADS 20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">pthread_t</span> thread_tid;<span class="comment">/* thread ID */</span></span><br><span class="line">    <span class="keyword">long</span> thread_count;<span class="comment">/* # connections handled */</span></span><br><span class="line">&#125; Thread;</span><br><span class="line"></span><br><span class="line">Thread *tptr;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mlock;</span><br></pre></td></tr></table></figure><p>在Do中初始化互斥锁，初始化NTHREADS个线程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_mutex_t</span> mlock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line">tptr = Calloc(NTHREADS, <span class="keyword">sizeof</span>(Thread));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;NTHREADS; i++)</span><br><span class="line">&#123;</span><br><span class="line">    pthread_create(&amp;tptr[i].thread_tid, <span class="literal">NULL</span>, &amp;doit, (<span class="keyword">void</span>*)i);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>每个线程执行的doit函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_lock(&amp;mlock);</span><br><span class="line">connfd = Accept(listennfd, cliaddr, &amp;clilen)</span><br><span class="line">pthread_mutex_unlock(&amp;mlock);</span><br><span class="line">tptr[(<span class="keyword">int</span>) arg].thread_count++;</span><br></pre></td></tr></table></figure><h3 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h3><p> error: invalid use of member ‘RPC_Server::listenfd’ in static member function。在doit静态函数中使用了成员变量，因为doit函数是void<em> func (void</em>)类型的函数，所以它没有对象指针this。这次我们没传connfd而是传递了Thread结构在线程数组中的位置，因为connfd线程自己accept，不用从主线程中传参进来了，而为了给每个线程的服务链接计数，要传递i，即Thread结构在线程池中的位置。</p><p>所以我先尝试把listenfd和tptr改成静态成员变量。由于静态的意图是只在一个源文件中生效，会导致链接器报undefend reference问题，所以直接改成全局变量。结果由于YA_RPC.c和server.c都应用了YA_RPC.h导致编译生成的两个.o文件都有全局变量，链接器报错multiple definition。所以我把listenfd，tptr和mlock都扔到YA_RPC.c中了。另一种解决办法是在.h中使用extern关键字声明全局变量，在YA_RPC.c中定义这些全局变量。</p><h2 id="版本6-IO复用之epoll监听事件与非阻塞式读写"><a href="#版本6-IO复用之epoll监听事件与非阻塞式读写" class="headerlink" title="版本6 IO复用之epoll监听事件与非阻塞式读写"></a>版本6 IO复用之epoll监听事件与非阻塞式读写</h2><h3 id="非阻塞套接字"><a href="#非阻塞套接字" class="headerlink" title="非阻塞套接字"></a>非阻塞套接字</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将套接字设置为非阻塞模式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setnonblock</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> flags;</span><br><span class="line">  flags = fcntl(fd, F_GETFL);</span><br><span class="line">  flags |= O_NONBLOCK;</span><br><span class="line">  fcntl(fd, F_SETFL, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>套接字的默认状态是阻塞的。这就意味着当发出一个不能立即完成的套接字调用时，其进程将被投入睡眠，等待相应操作的完成。</p><h4 id="输入操作"><a href="#输入操作" class="headerlink" title="输入操作"></a>输入操作</h4><ul><li>包括read，readv，recv，recvfrom和recvmsg共5个函数。</li><li>阻塞条件：该套接字阻塞，接收缓冲区中没有数据可读</li><li>唤醒条件：TCP是字节流协议，只要有一些数据到达，这些数据既可能是单个字节，也可以是一个完整的TCP分节中的数据。如果想等到某个固定数目的数据可读为止，那么可以调用我们的readn函数，或指定MSG_WAITALL标志。</li><li>非阻塞：如果输入操作不能被满足(对于TCP套接字即至少有一个字节的数据可读，对于UDP套接字即有一个完整的数据报可读)，相应调用将立即返回一个EWOULDBLOCK错误。</li></ul><h4 id="输出操作"><a href="#输出操作" class="headerlink" title="输出操作"></a>输出操作</h4><ul><li>包括write、writev、send、sendto和sendmsg共5个函数</li><li>阻塞条件：如果其发送缓冲区中没有空间，进程将被投入睡眠，直到有空间为止。</li><li>唤醒条件：发送缓冲区有空间</li><li>非阻塞：如果其发送缓冲区中没有空间，输出函数调用将立即返回一个EWOULDBLOCK错误。如果其发送缓冲区中有一些空间，返回值将是能够复制到该缓冲区中的字节数(不足计数 short count)</li></ul><h4 id="接收外来链接"><a href="#接收外来链接" class="headerlink" title="接收外来链接"></a>接收外来链接</h4><p>对于一个阻塞的套接字调用accept函数，并且尚无新的连接到达，accept调用将立即返回一个EWOULDBLOCK错误。</p><h4 id="发起外出链接"><a href="#发起外出链接" class="headerlink" title="发起外出链接"></a>发起外出链接</h4><p>connect函数一直要等到客户收到对于自己的SYN的ACK为止才返回。这意味着TCP的每个connect总会阻塞其调用进程至少一个服务器的RTT时间。</p><p>如果对于一个非阻塞的TCP套接字调用connect，并且连接不能立即建立，那么连接的建立能照样发起，不过会返回一个EINPROGRESS错误。(立即建立的连接通常发生在服务器和客户处于同一个主机的情况下)</p><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>可以监听建立连接、读、写事件。</p><h4 id="epoll-create，创建一个epoll句柄"><a href="#epoll-create，创建一个epoll句柄" class="headerlink" title="epoll_create，创建一个epoll句柄"></a>epoll_create，创建一个epoll句柄</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"><span class="comment">//返回值为一个文件描述符</span></span><br></pre></td></tr></table></figure><p>size为最大可监听的描述符个数</p><h4 id="epoll-ctl，注册要监听的描述符和事件"><a href="#epoll-ctl，注册要监听的描述符和事件" class="headerlink" title="epoll_ctl，注册要监听的描述符和事件"></a>epoll_ctl，注册要监听的描述符和事件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span></span><br></pre></td></tr></table></figure><ul><li>int epfd：是epoll_create()的返回值</li><li>int op：EPOLL_CTL_ADD，注册新的fd到epfd中；EPOLL_CTL_MOD，修改已经注册的fd的监听事件；EPOLL_CTL_DEL，从epfd中删除一个fd。</li><li>int fd：需要监听的描述符</li><li>struct epoll_event *event</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span>&#123;</span></span><br><span class="line">  <span class="keyword">void</span> *ptr;</span><br><span class="line">  <span class="keyword">int</span> fd;</span><br><span class="line">  <span class="keyword">__uint32_t</span> u32;</span><br><span class="line">  <span class="keyword">__uint64_t</span> u64;</span><br><span class="line">&#125;<span class="keyword">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span>&#123;</span></span><br><span class="line">  <span class="keyword">__uint32_t</span> events; <span class="comment">/*Epoll events*/</span></span><br><span class="line">  <span class="keyword">epoll_data_t</span> data; <span class="comment">/*User data variable*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>events代表事件：EPOLLIN表示对应的文件描述符可读(包括对端socket正常关闭)；EPOLLOUT表示对应的文件描述符可以写；EPOLLPRI表示对应的文件描述符有紧急的数据可读(带外数据)；EPOLLERR表示对应的文件描述符发生错误；EPOLLHUP表示对应的文件描述符被挂断；EPOLLET将EPOLL设为边缘触发(Edge Triggered)，处理完事件后才会再收到事件</p><h4 id="epoll-wait"><a href="#epoll-wait" class="headerlink" title="epoll_wait"></a>epoll_wait</h4><p>events里存储所有读写事件，函数返回需要处理的事件数目，如返回0表示已超时</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span></span><br></pre></td></tr></table></figure><ul><li>int epfd：epfd为epoll_create()创建的描述符</li><li>struct epoll_event *events：从内核得到事件的集合</li><li>int maxevents：返回描述符事件的最大数目</li><li>int timeout：超时时间，0立刻返回，-1一直等下去</li></ul><h3 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h3><p>epoll监听建立链接，读，写事件并分别处理，可能会出现读到EOF，链接关闭， 然而还有一些本该处理的写事件没处理完</p><p>close把描述符的引用计数减1，仅在该计数变为0时才关闭套接字。使用shutdown可以不管引用计数就激发TCP的正常连接终止序列。</p><p>close终止读和写两个方向的数据传递。shutdown可以关闭一半TCP链接。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#inlcude <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> howto)</span></span>;</span><br></pre></td></tr></table></figure><p>该函数的行为依赖于howto参数的值。</p><ul><li>SHUT_RD：关闭链接的读一半——套接字中不再有数据可接收，而且套接字接收缓冲区中的现有数据都被丢弃。进程不能再对这样的套接字调用任何读函数。对一个TCP套接字这样调用shutdown函数后，由该套接字接收的来自对端的任何数据都被确认，然后丢弃。</li><li>SHUT_WR：关闭链接的写一半——当前留在套接字发送缓冲区中的数据将被发送掉，后跟TCP的正常连接中止序列。进程不能再对这样的套接字调用任何写函数。</li></ul><p>然而在本次实现中，客户端通过客户类，在构造函数中建立连接，完成所有任务后在析构函数中关闭连接，所以不用使用shutdown，只使用close就好。</p><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><p>首先创建一个epoll实例</p><p>注册listenfd和EPOLLIN，监听建立链接的事件，如果有已建立的链接，服务器accept然后注册connfd和读事件到epoll中。</p><p>循环接收已发生的事件，如果有某已链接套接字的可读事件，就读该套接字，如果链接结束就删除，如果要写，就注册该套接字的写事件到epoll中。</p><p>如果有某已链接套接字的可写事件，就写该套接字。</p><p>在服务器类的构造函数中，创建epoll实例并注册listenfd的EPOLLIN事件，以accept链接。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//create epoll</span></span><br><span class="line">epfd = epoll_create(MAXFDS);</span><br><span class="line"></span><br><span class="line"><span class="comment">//regit listenfd and accept event</span></span><br><span class="line">ev.data.fd = listenfd;</span><br><span class="line">ev.events = EPOLLIN;</span><br><span class="line">epoll_ctl(epfd, EPOLL_CTL_ADD, listenfd, &amp;ev);</span><br></pre></td></tr></table></figure><p>在Do中循环接收监听到的事件</p><p>此时发现，epoll监听注册的套接字的读写事件，将读写分离开来，没有连续地处理客户请求。比较复杂。所以咕咕咕。</p><p>目前就实现到线程池。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何用电存储和传输数据</title>
      <link href="/2021/11/10/%E5%A6%82%E4%BD%95%E7%94%A8%E7%94%B5%E5%AD%98%E5%82%A8%E5%92%8C%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE/"/>
      <url>/2021/11/10/%E5%A6%82%E4%BD%95%E7%94%A8%E7%94%B5%E5%AD%98%E5%82%A8%E5%92%8C%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 电 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>自然常数e</title>
      <link href="/2021/11/08/%E8%87%AA%E7%84%B6%E5%B8%B8%E6%95%B0e/"/>
      <url>/2021/11/08/%E8%87%AA%E7%84%B6%E5%B8%B8%E6%95%B0e/</url>
      
        <content type="html"><![CDATA[<h1 id="泰勒级数"><a href="#泰勒级数" class="headerlink" title="泰勒级数"></a>泰勒级数</h1><p>参考妈咪说视频，两个函数，起点一样，各阶导数(函数关于自变量的变化率，函数关于自变量的变化率的变化率…)都一样，就认为这两个函数一样。</p><h2 id="亲民的函数如多项式函数"><a href="#亲民的函数如多项式函数" class="headerlink" title="亲民的函数如多项式函数"></a>亲民的函数如多项式函数</h2><p>y=x</p><p>y=x^3+x^2+5x+6</p><p>给一个x值，很快能算出对应的y值</p><p>多项式：自变量和常数通过加减乘以及自然数的幂次方运算得到的代数表达式</p><h2 id="不亲民的函数如三角函数和e-x"><a href="#不亲民的函数如三角函数和e-x" class="headerlink" title="不亲民的函数如三角函数和e^x"></a>不亲民的函数如三角函数和e^x</h2><p>y=sinx</p><p>y=cosx</p><p>y=e^x</p><p>这类函数你就不能很快的得到函数值，不能够快速求值，就比较讨厌</p><p>根据泰勒级数可知，两个函数f(x)，g(x)的各阶导数相等的越多，那么这两个函数越相似。</p><h2 id="不亲民的函数能否用多项式进行表达呢？"><a href="#不亲民的函数能否用多项式进行表达呢？" class="headerlink" title="不亲民的函数能否用多项式进行表达呢？"></a>不亲民的函数能否用多项式进行表达呢？</h2><h3 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h3><p>速度是路程关于时间的变化率，加速度是速度关于时间的变化率，加速度的加速度是加速度关于时间的变化率，…, 变化率也叫导数。</p><p>两个小人从同一起点沿同一直线，如果想走的一模一样，其初始速度，加速度，加速度的加速度, … 也就是n阶导数都要一样。</p><h3 id="用多项式拟合不亲民的函数，如果无穷项，那就是一模一样"><a href="#用多项式拟合不亲民的函数，如果无穷项，那就是一模一样" class="headerlink" title="用多项式拟合不亲民的函数，如果无穷项，那就是一模一样"></a>用多项式拟合不亲民的函数，如果无穷项，那就是一模一样</h3><p>假设f(x)=e^x 或 sinx 或 cosx</p><p>g(x)=a0+a1x+a2x^2+…+anx^n</p><p>要求f(0)=g(0)=1 =&gt; a0=1，使得起点和各阶导数都相等</p><p>f’(0) = g’(0)</p><p>f’’(0)=g’’(0)</p><p>…</p><p>fn(0)=gn(0)=n!an</p><p><img src="/2021/11/08/%E8%87%AA%E7%84%B6%E5%B8%B8%E6%95%B0e/image-20211228204518236.png" alt="image-20211228204518236"></p><h1 id="自然常数e，诞生自指数函数求导"><a href="#自然常数e，诞生自指数函数求导" class="headerlink" title="自然常数e，诞生自指数函数求导"></a>自然常数e，诞生自指数函数求导</h1><p>参考MIT课程 highlights of calculus</p><p>参考youtube视频</p><p><a href="https://www.youtube.com/watch?v=m2MIpDrF7Es">https://www.youtube.com/watch?v=m2MIpDrF7Es</a></p><h2 id="e的产生"><a href="#e的产生" class="headerlink" title="e的产生"></a>e的产生</h2><p>人们用极限对指数函数求导发现</p><p><img src="/2021/11/08/%E8%87%AA%E7%84%B6%E5%B8%B8%E6%95%B0e/image-20220102004032483.png" alt="image-20220102004032483"></p><p><img src="/2021/11/08/%E8%87%AA%E7%84%B6%E5%B8%B8%E6%95%B0e/image-20220102004027381.png" alt="image-20220102004027381"></p><p><img src="/2021/11/08/%E8%87%AA%E7%84%B6%E5%B8%B8%E6%95%B0e/image-20220102004051266.png" alt="image-20220102004051266"></p><p><img src="/2021/11/08/%E8%87%AA%E7%84%B6%E5%B8%B8%E6%95%B0e/image-20220102004153400.png" alt="image-20220102004153400"></p><p>M(t)=2^t的导数，与其本身成正比，比值为一个神秘的数字0.693…</p><p><img src="/2021/11/08/%E8%87%AA%E7%84%B6%E5%B8%B8%E6%95%B0e/image-20220102004300478.png" alt="image-20220102004300478"></p><p>M(t)=3^t的导数，与其本身成正比，比值为一个神秘的数字1.098…</p><p><img src="/2021/11/08/%E8%87%AA%E7%84%B6%E5%B8%B8%E6%95%B0e/image-20220102004457923.png" alt="image-20220102004457923"></p><p>M(t)=8^t的导数，与其本身成正比，比值为一个神秘的数字2.079…</p><p>是否有一个底数，使得其指数函数的导数与自身相等？定义其为e</p><h2 id="根据e-t的导数等于自身的性质，求e"><a href="#根据e-t的导数等于自身的性质，求e" class="headerlink" title="根据e^t的导数等于自身的性质，求e"></a>根据e^t的导数等于自身的性质，求e</h2><p>根据性质，直接用泰勒级数逼近e^x</p><script type="math/tex; mode=display">e^x=1+x+{x^2\over2!}+{x^3\over3!}+{x^4\over4!}+...+{x^n\over n!}</script><p>当x=1时，就产生了e</p><p>微分方程：dy/dx=y 即求导数等于自身的y，y=e^x</p><h2 id="自然对数的使用，结合链式求导规则"><a href="#自然对数的使用，结合链式求导规则" class="headerlink" title="自然对数的使用，结合链式求导规则"></a>自然对数的使用，结合链式求导规则</h2><p>链式求导规则：</p><p>代数，以符号代数：</p><script type="math/tex; mode=display">{△z\over△y}{△y\over△x}={△z\over△x}</script><p>极限，△(距离)趋近无穷小</p><script type="math/tex; mode=display">{dz\over dy} {dy\over dx} = {dz\over dx}</script><p>使用自然对数换底：</p><p>如2换成e^ln(2), 2^t求导后为ln(2)e^ln(2)t = ln(2)2^t</p><p><img src="/2021/11/08/%E8%87%AA%E7%84%B6%E5%B8%B8%E6%95%B0e/image-20220102005643853.png" alt="image-20220102005643853"></p><p><img src="/2021/11/08/%E8%87%AA%E7%84%B6%E5%B8%B8%E6%95%B0e/image-20220102010052376.png" alt="image-20220102010052376"></p><p>现在，指数函数求导得到的神秘系数，就是以其底数为真值的自然对数。</p><h1 id="证明复利公式的极限是e-用到洛必达法则"><a href="#证明复利公式的极限是e-用到洛必达法则" class="headerlink" title="证明复利公式的极限是e,用到洛必达法则"></a>证明复利公式的极限是e,用到洛必达法则</h1><script type="math/tex; mode=display">证明：y=f(n)=\lim_{n->\infty}(1+{1\over n})^n=e</script><p>两边经自然对数函数作用，利用对数函数的规则作变形</p><script type="math/tex; mode=display">lny=\lim_{n->\infty}ln[(1+{1\over n})^n]=\lim_{n->\infty}nln(1+{1\over n})</script><p>令n=1/x，因为n-&gt;∞，所以x-&gt;0</p><script type="math/tex; mode=display">lny=\lim_{x->0}{ln(1+x)\over x}</script><p>根据反函数性质，结合链式求导法则，得到lny的导数:</p><p>反函数的性质：</p><script type="math/tex; mode=display">ln(e^x)=x</script><p>两边求导：</p><script type="math/tex; mode=display">{dlny\over dy}{de^x\over dx}=1</script><script type="math/tex; mode=display">{dlny\over dy}={1\over e^x}={1\over y}</script><script type="math/tex; mode=display">故 lnx的导数为{1\over x}</script><p>使用洛必达法则</p><script type="math/tex; mode=display">{lny}=\lim_{x->0}{\ {1\over 1+x}\over 1\ }=1</script><p>故y=e，即：</p><script type="math/tex; mode=display">\lim_{n->\infty}(1+{1\over n})^n=e</script>]]></content>
      
      
      <categories>
          
          <category> 数 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>随机变量的矩</title>
      <link href="/2021/11/08/%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E7%9F%A9/"/>
      <url>/2021/11/08/%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E7%9F%A9/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 数 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>映射</title>
      <link href="/2021/11/08/%E6%98%A0%E5%B0%84/"/>
      <url>/2021/11/08/%E6%98%A0%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h1 id="从定义域到值域"><a href="#从定义域到值域" class="headerlink" title="从定义域到值域"></a>从定义域到值域</h1><p><strong>定义域</strong>：原始值的集合，比如几个学生的姓名{小明，小王，小张}</p><p><strong>值域</strong>：目标值的集合，比如几个学生的学号{1,2,3}</p><p><strong>映射</strong>：(原始值,目标值)对的集合，反映从定义域的某个值变成某个值的对应关系，比如学生和学号的对应关系{(1,小明)，(2,小王)，(3,小张)}</p><p><strong>函数</strong>：一个函数，是从一个映射(对应关系)产生的一种作用，称学生姓名小王在函数<strong>学号=将学生姓名变成学号作用(姓名)</strong>(简称函数f)的作用下，变成了2。称在这种作用中，学生姓名为自变量(因)，称学号为因变量(果)。</p><p>&emsp;&emsp;函数一词的由来(老实说，改成作用更好)：函数，最早由中国清朝数学家李善兰翻译，出于其著作《代数学》。之所以这么翻译，他给出的原因是“凡此变数中函彼变数者，则此为彼之函数”，也即函数指一个量随着另一个量的变化而变化，或者说一个量中包含另一个量。<strong>从中可以看出，函数是指代因变量，表示因变量是含有自变量的变数，故而我们常称在作用y=5x中，y是x的一个函数</strong>。</p><p>&emsp;&emsp;比较美的表述：我们说，自变量x经过f()映射作用后得到函数y，即y=f(x)。</p><h1 id="作用-fuction-的严格定义"><a href="#作用-fuction-的严格定义" class="headerlink" title="作用(fuction)的严格定义"></a>作用(fuction)的严格定义</h1><p><img src="/2021/11/08/%E6%98%A0%E5%B0%84/image-20211215165737479.png" alt="image-20211215165737479"></p><p>集合A中的每一个元素x都有y对应</p><p>集合A中的每一个元素x，都恰有一个y与之对应</p><p><img src="/2021/11/08/%E6%98%A0%E5%B0%84/image-20211215165850772.png" alt="image-20211215165850772"></p><p>从定义域domain出发，在对应域codomain中，对应出值域Range</p><h1 id="一些名词"><a href="#一些名词" class="headerlink" title="一些名词"></a>一些名词</h1><h2 id="实-实值函数"><a href="#实-实值函数" class="headerlink" title="实\实值函数"></a>实\实值函数</h2><p>值域元素都是实数的函数</p><h2 id="集函数"><a href="#集函数" class="headerlink" title="集函数"></a>集函数</h2><p>定义域元素为集合的函数</p><h2 id="单值函数"><a href="#单值函数" class="headerlink" title="单值函数"></a>单值函数</h2><p>若对定义域每一个自变量x，其对应的函数值f(x)是唯一的，则称f(x)是单值函数。这也是函数的定义</p>]]></content>
      
      
      <categories>
          
          <category> 数 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>加减乘除</title>
      <link href="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/"/>
      <url>/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="1-9"><a href="#1-9" class="headerlink" title="1-9"></a>1-9</h1><div style="float:left;border:solid 1px 000;margin:2px;height:30;width:30;"><img src="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/001EFA2D.png" width="48" height="48"></div><p>记为符号1，</p><p><br></p><div style="float:left;border:solid 1px 000;margin:2px;height:30;width:30;"><img src="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/001EFA2D.png" width="48" height="48"></div><div style="float:left;border:solid 1px 000;margin:2px;height:30;width:30;"><img src="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/001EFA2D.png" width="48" height="48"></div><p>记为符号2，</p><p><br></p><div style="float:left;border:solid 1px 000;margin:2px;height:30;width:30;"><img src="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/001EFA2D.png" width="48" height="48"></div><div style="float:left;border:solid 1px 000;margin:2px;height:30;width:30;"><img src="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/001EFA2D.png" width="48" height="48"></div><div style="float:left;border:solid 1px 000;margin:2px;height:30;width:30;"><img src="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/001EFA2D.png" width="48" height="48"></div><p>记为符号3,</p><p><br></p><p><strong>…</strong></p><div style="float:left;border:solid 1px 000;margin:2px;height:30;width:30;"><img src="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/001EFA2D.png" width="48" height="48"></div><div style="float:left;border:solid 1px 000;margin:2px;height:30;width:30;"><img src="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/001EFA2D.png" width="48" height="48"></div><div style="float:left;border:solid 1px 000;margin:2px;height:30;width:30;"><img src="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/001EFA2D.png" width="48" height="48"></div><div style="float:left;border:solid 1px 000;margin:2px;height:30;width:30;"><img src="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/001EFA2D.png" width="48" height="48"></div><div style="float:left;border:solid 1px 000;margin:2px;height:30;width:30;"><img src="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/001EFA2D.png" width="48" height="48"></div><div style="float:left;border:solid 1px 000;margin:2px;height:30;width:30;"><img src="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/001EFA2D.png" width="48" height="48"></div><div style="float:left;border:solid 1px 000;margin:2px;height:30;width:30;"><img src="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/001EFA2D.png" width="48" height="48"></div><div style="float:left;border:solid 1px 000;margin:2px;height:30;width:30;"><img src="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/001EFA2D.png" width="48" height="48"></div><div style="float:left;border:solid 1px 000;margin:2px;height:30;width:30;"><img src="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/001EFA2D.png" width="48" height="48"></div><p>记为符号9</p><p><br></p><p><strong>十进制，天才的发明，不然要创造超级多符号表示数量。当有十个苹果时，进1到高位：</strong></p><div style="float:left;border:solid 1px 000;margin:2px;height:30;width:30;"><img src="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/001EFA2D.png" width="48" height="48"></div><div style="float:left;border:solid 1px 000;margin:2px;height:30;width:30;"><img src="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/001EFA2D.png" width="48" height="48"></div><div style="float:left;border:solid 1px 000;margin:2px;height:30;width:30;"><img src="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/001EFA2D.png" width="48" height="48"></div><div style="float:left;border:solid 1px 000;margin:2px;height:30;width:30;"><img src="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/001EFA2D.png" width="48" height="48"></div><div style="float:left;border:solid 1px 000;margin:2px;height:30;width:30;"><img src="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/001EFA2D.png" width="48" height="48"></div><div style="float:left;border:solid 1px 000;margin:2px;height:30;width:30;"><img src="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/001EFA2D.png" width="48" height="48"></div><div style="float:left;border:solid 1px 000;margin:2px;height:30;width:30;"><img src="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/001EFA2D.png" width="48" height="48"></div><div style="float:left;border:solid 1px 000;margin:2px;height:30;width:30;"><img src="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/001EFA2D.png" width="48" height="48"></div><div style="float:left;border:solid 1px 000;margin:2px;height:30;width:30;"><img src="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/001EFA2D.png" width="48" height="48"></div><div style="float:left;border:solid 1px 000;margin:2px;height:30;width:30;"><img src="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/001EFA2D.png" width="48" height="48"></div><p>记为符号10</p><p><br></p><div style="float:left;border:solid 1px 000;margin:2px;height:30;width:30;"><img src="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/001EFA2D.png" width="48" height="48"></div><div style="float:left;border:solid 1px 000;margin:2px;height:30;width:30;"><img src="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/001EFA2D.png" width="48" height="48"></div><div style="float:left;border:solid 1px 000;margin:2px;height:30;width:30;"><img src="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/001EFA2D.png" width="48" height="48"></div><div style="float:left;border:solid 1px 000;margin:2px;height:30;width:30;"><img src="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/001EFA2D.png" width="48" height="48"></div><div style="float:left;border:solid 1px 000;margin:2px;height:30;width:30;"><img src="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/001EFA2D.png" width="48" height="48"></div><div style="float:left;border:solid 1px 000;margin:2px;height:30;width:30;"><img src="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/001EFA2D.png" width="48" height="48"></div><div style="float:left;border:solid 1px 000;margin:2px;height:30;width:30;"><img src="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/001EFA2D.png" width="48" height="48"></div><div style="float:left;border:solid 1px 000;margin:2px;height:30;width:30;"><img src="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/001EFA2D.png" width="48" height="48"></div><div style="float:left;border:solid 1px 000;margin:2px;height:30;width:30;"><img src="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/001EFA2D.png" width="48" height="48"></div><div style="float:left;border:solid 1px 000;margin:2px;height:30;width:30;"><img src="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/001EFA2D.png" width="48" height="48"></div><div style="float:left;border:solid 1px 000;margin:2px;height:30;width:30;"><img src="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/001EFA2D.png" width="48" height="48"></div><p>记为符号11</p><p><br><strong>…</strong></p><p><strong>数字简化了有关数量的表述</strong></p><h1 id="加"><a href="#加" class="headerlink" title="加+"></a>加+</h1><p>1个苹果+1个苹果= 2个苹果</p><p>1个苹果+9个苹果 = 10个苹果</p><p>5个苹果+6个苹果 = 11个苹果</p><p><strong>加法规则可以对两批已知数量的苹果，计算总数</strong></p><h1 id="减"><a href="#减" class="headerlink" title="减-"></a>减-</h1><p>1个苹果-1个苹果 = 0个苹果</p><p>12个苹果-2个苹果 = 10个苹果</p><p><strong>减法规则是加法规则的变形，可以将一批苹果，分成两批</strong></p><h1 id="乘×"><a href="#乘×" class="headerlink" title="乘×"></a>乘×</h1><p>2个苹果×3份 = 2+2+2个苹果 = 6个苹果</p><p>4个苹果×11份 = 4+4+4+4+4+4+4+4+4+4+4个苹果 = 44个苹果</p><p><strong>乘法规则基于加法规则得来，可以快速计算多批等数量苹果的总数</strong></p><h1 id="除÷"><a href="#除÷" class="headerlink" title="除÷"></a>除÷</h1><p>6个苹果÷3份 = 2个苹果</p><p>44个苹果÷4个苹果 = 11份</p><p><strong>除法规则是乘法规则的变形，可以快速将一批苹果分成多批等数量的苹果</strong></p>]]></content>
      
      
      <categories>
          
          <category> 数 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>眼睛是怎么看到东西的？</title>
      <link href="/2021/11/08/%E7%9C%BC%E7%9D%9B%E6%98%AF%E6%80%8E%E4%B9%88%E7%9C%8B%E5%88%B0%E4%B8%9C%E8%A5%BF%E7%9A%84%EF%BC%9F/"/>
      <url>/2021/11/08/%E7%9C%BC%E7%9D%9B%E6%98%AF%E6%80%8E%E4%B9%88%E7%9C%8B%E5%88%B0%E4%B8%9C%E8%A5%BF%E7%9A%84%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 光 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>malloc</title>
      <link href="/2021/11/08/malloc/"/>
      <url>/2021/11/08/malloc/</url>
      
        <content type="html"><![CDATA[<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>Randal E. Bryant, David R. O’Hallaron. Computer Systems A Programmer’s Perspective. ISBN: 978-1-488-67207-1. 第十章 虚拟存储器</p><h1 id="背景知识-虚拟主存"><a href="#背景知识-虚拟主存" class="headerlink" title="背景知识 虚拟主存"></a>背景知识 虚拟主存</h1><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>前言</span></div>    <div class="hide-content"><p>&emsp;&emsp;<strong>时钟信号在不停地产生，CPU在不停地执行指令，总线在不停的传递数据，内核也只是从一开始就执行的程序，中断也只是改了rip让CPU执行中断处理程序</strong>。</p><p>&emsp;&emsp;<strong>磁盘-&gt;进程的虚拟主存-&gt;物理主存。主存映射mmap将磁盘文件和虚拟页关联起来，地址翻译硬件和页表将虚拟页放入到物理主存中，交换文件将页在物理主存和磁盘之间换来换去</strong></p><p>&emsp;&emsp;<strong>使用主存时遇到的问题：</strong>系统中的所有进程都共享主存(memory)资源，如果太多的进程需要太多的主存，就会有一些倒霉蛋进程因为<strong>主存空间不够</strong>而无法继续运行。此外，如果某个进程不小心<strong>写了另一个进程正在使用的主存空间</strong>，另一个进程可能以非常迷惑的方式失败。</p><p>&emsp;&emsp;<strong>虚拟主存的意义：</strong>为了有效地管理主存，并且少出错，现代系统提供了一种对主存的抽象概念，叫做虚拟主存(virtual memory)。虚拟主存为每个进程提供了一个大的、一致的、私有的地址空间。虚拟主存提供了三个重要的能力：①它将主存看成是一个高速缓存，缓存磁盘上的空间。②在主存中保存进程的活动区域。③并根据需要在磁盘和主存之间来回传送数据。通过这种方式，它高效使用了主存；为每个进程提供了一致的地址空间，从而简化了存储器管理；它保护了每个进程的地址空间不被其他进程破坏。虚拟主存是硬件异常，硬件地址翻译，主存，磁盘文件和内核的完美交互。</p><p>&emsp;&emsp;虚拟主存是计算机系统中最重要的概念之一。为什么程序员要理解它？</p><ul><li>虚拟主存是中心的。虚拟主存涉及计算机的所有层面，在硬件机场、汇编器、链接器、加载器、共享对象、文件和进程的设计中扮演着重要角色。理解虚拟存储器将帮助你更好地理解系统通常是如何工作的。</li></ul><ul><li>虚拟主存是强大的。虚拟主存给予应用程序强大的能力，可以创建和删除主存块，将主存块映射到磁盘文件的某个部分，以及与其他进程共享主存。比如，你知道你可以通过读写主存位置读或者修改一个磁盘文件的内容吗？或者是你可以加在一个文件的内容到主存中，而不需要进行任何显示地拷贝吗？</li></ul><ul><li>虚拟主存是危险的。每次应用程序引用一个变量、间接引用一个指针，或者调用一个诸如malloc这样的动态分配包程序时，它就会和虚拟主存发生交互。</li></ul><p>&emsp;&emsp;这一章从两个角度来讨论虚拟主存。前一部分描述虚拟主存是如何工作的，后一部分描述应用程序如何使用和管理虚拟主存。</p></div></div><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>10.1 物理和虚拟寻址</span></div>    <div class="hide-content"><p>&emsp;&emsp;<strong>主存的物理结构和物理寻址：</strong>计算机系统的主存被组织成一个由M个连续的字节大小的单元组成的数组。每字节都有一个唯一的物理地址(physical address, PA)。对于这种主存结构，CPU访问主存最自然的方式就是使用物理地址，我们称这种方式为物理寻址(physical addressing)。下图展示了一个物理寻址的例子，此时CPU正在执行一条加载指令，读取从物理地址4处开始的字。</p><p><img src="/2021/11/08/malloc/image-20211109183726847.png" alt="image-20211109183726847"></p><p>&emsp;&emsp;当CPU执行这条加载指令时，它会生成一个有效的物理地址，通过存储器总线，把它传递给主存。主存取出从物理地址4处开始的4字节的字，返回给CPU, CPU会将它存放在一个就差你器里。</p><p>&emsp;&emsp;<strong>虚拟寻址：</strong>早期的PC使用物理寻址，而且诸如数字信号处理器、嵌入式微控制器以及Cray超级计算机这样的系统仍然继续使用这种寻址方式。然而，为通用计算设计的现代处理器使用的是虚拟寻址(virtual addressing)。</p><p><img src="/2021/11/08/malloc/image-20211109184247542.png" alt="image-20211109184247542"></p><p>&emsp;&emsp;根据虚拟寻址，CPU通过生成一个虚拟地址(virtual address, VA)访问主存，这个虚拟地址在被送到主存之前被转换成物理地址。将一个虚拟地址转换为物理地址的任务叫做地址翻译(address translation)。CPU芯片上叫做MMU(memory management unit，主存管理单元)的专用硬件，利用存放在主存中的查询表来动态翻译虚拟地址，该表的内容由操作系统管理。</p></div></div><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>10.2 地址空间</span></div>    <div class="hide-content"><p>&emsp;&emsp; <strong>地址空间</strong>(address space)是一个非负整数地址的有序集合:{0, 1, 2, … }</p><p>&emsp;&emsp;如果地址空间中的整数是连续的，那么我们说它是一个<strong>线性地址空间</strong>(linear address space)。</p><p>&emsp;&emsp;在一个带虚拟主存的系统中，CPU从一个有N=2^n个地址的地址空间中生成虚拟地址，这个地址空间称为<strong>虚拟地址空间</strong>(virtual address space): {0, 1, 2, …, N-1}</p><p>&emsp;&emsp;一个地址空间，可以由表示最大地址所需要的位数来描述。例如，一个包含N=2^n个地址的虚拟地址空间就叫做一个n位地址空间。现代系统一般都支持32位或64位虚拟地址空间。</p><p>&emsp;&emsp;一个系统中海油一个<strong>物理地址空间</strong>(physical address space)，它与系统中物理主存的M个字节相对应: {0, 1, 2, …, M-1}</p><p>&emsp;&emsp;如此，我们能够清楚地区分数据对象(字节)和它们的属性(地址)，在使用虚拟主存的系统中，每个数据对象既有一个选自虚拟地址空间的虚拟地址，还有一个选自物理地址空间的物理地址。</p></div></div><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>10.3 主存作为虚拟主存的缓存</span></div>    <div class="hide-content"><p>&emsp;&emsp;<strong>虚拟主存</strong>被组织为存放在磁盘上的N个连续的字节大小的单元组成的数组。每个字节都有一个唯一的虚拟地址。磁盘上数组的内容被缓存在主存中。和存储器层次结构中其他缓存一样，磁盘(较低层)上的数据被分割成块，这些块作为磁盘和主存(较高层)之间的传输单元。虚拟主存系统将虚拟主存分割为称为<strong>虚拟页</strong>(virtual page,VP)的大小固定的块，物理主存被分割为<strong>物理页</strong>(physical page,PP)。页的大小一般为4KB。</p><p>&emsp;&emsp;任意时间点，虚拟页由3部分不相交的子集构成：</p><ul><li><strong>未分配的虚拟页</strong>：虚拟主存系统还未分配的页。未分配的页不与任何数据关联，不占用任何磁盘空间。</li><li><strong>已分配未缓存的虚拟页</strong>：没有缓存在物理主存中的已分配页。</li><li><strong>已缓存的虚拟页</strong>：当前缓存在物理主存中的已分配页。</li></ul><p>&emsp;&emsp;下图展示了一个有8个虚拟页的虚拟主存。虚拟页0、3还没有分配，磁盘上还不存在。虚拟页1、4、6被缓存在物理主存中，页2、5、7已经被分配了，但是当前并为缓存在主存中。</p><p><img src="/2021/11/08/malloc/image-20211110142235210.png" alt="image-20211110142235210"></p><p><strong>10.3.1 高速缓存的组织结构</strong></p><p>&emsp;&emsp;使用术语<strong>SRAM缓存</strong>来表示位于CPU和物理主存之间的L1和L2高速缓存，使用术语<strong>DRAM缓存</strong>来表示虚拟主存系统的缓存:物理主存。DRAM比SRAM慢10倍，磁盘比DRAM慢100000多倍。因此DRAM缓存的不命中(miss)比起SRAM的不命中要昂贵的多，因为DRAM缓存不命中要有磁盘来服务，而SRAM缓存不命中由DRAM来服务。所以，DRAM缓存这种结构完全是用巨大的不命中开销换空间。</p><p><strong>10.3.2 页表</strong></p><p>&emsp;&emsp;虚拟主存系统需要判定一个虚拟页是否在物理主存中，如果在，存放在物理主存的哪个物理页中。当不命中时，虚拟页放到哪个物理页。这些功能是由许多软硬件联合提供的，包括：操作系统软件，MMU(memory management unit)中的地址翻译硬件，和一个存放在物理主存中叫做页表的数据结构。<strong>页表</strong>存放在物理主存中，将虚拟页映射到物理页。每次<strong>地址翻译硬件</strong>将一个虚拟地址转换成物理地址时，都会读取页表。<strong>操作系统</strong>负责维护页表内容，以及在磁盘与物理主存之间来回传送页。</p><p>&emsp;&emsp;下图展示了一个页表的结构。页表是一个PTE(page table entry，页表条目)的数组。虚拟地址空间中的每个页在页表中的一个固定偏移量处都有一个PTE。我们假设每个PTE是由一个有效位(valid bit)和一个n位地址字段组成的。有效位表明改虚拟页当前是否被缓存在物理主存中。如果设置了有效位，那么地址字段就表示物理主存中相应物理页的起始位置，这个物理页中缓存了该虚拟页。如果没有设置有效位，那么一个空地址表示这个虚拟页还未被分配。分则，这个地址就指向磁盘上虚拟页的起始位置。</p><p>&emsp;&emsp;下图展示了一个有8个虚拟页和4个物理页的系统的页表。四个虚拟页1、2、7已被缓存在物理主存中，两个页0、5还没分配。剩下的页3、6已被分配还未缓存。</p><p><img src="/2021/11/08/malloc/image-20211110145708890.png" alt="image-20211110145708890"></p><p><strong>10.3.3 页命中</strong></p><p>&emsp;&emsp;考虑一下当CPU读虚拟主存中的一个字时，它的地址被VP2包含，且被缓存在DRAM中，会发生什么？地址翻译硬件将虚拟地址作为一个索引，来定位PTE2，由于设置了有效位，地址翻译硬件就知道VP2已经缓存在物理主存DRAM中了，所以它使用PTE中的物理主存地址构造出这个字的物理地址。</p><p><img src="/2021/11/08/malloc/image-20211110150622783.png" alt="image-20211110150622783"></p><p><strong>10.3.4 缺页</strong></p><p>&emsp;&emsp;通常将DRAM缓存不命中称为缺页(page fault)。下图展示了在缺页之前我们的示例页表的状态。</p><p><img src="/2021/11/08/malloc/image-20211110151117891.png" alt="image-20211110151117891"></p><p>&emsp;&emsp;CPU使用了VP3中的一个字，地址翻译硬件从存储器中读取PTE3，从有效位推断出VP3未被缓存，触发一个缺页异常。</p><p>&emsp;&emsp;缺页异常调用内核中的缺页异常处理程序，该程序会选择一个牺牲页，此例中就是PP3，如果PP3中的VP4已经被修改了，内核就将VP4拷贝回磁盘。无论哪种情况，内核都会修改VP4的页表条目，反映出VP4不再缓存在主存中这一事实。</p><p>&emsp;&emsp;接下来，内核从磁盘拷贝VP3到物理主存中的PP3，更新PTE3，随后返回。当异常处理程序返回时，它会重新执行导致缺页的指令，该指令会把导致缺页的虚拟地址重新发送到地址翻译硬件。但是现在VP3已经缓存在物理主存中了，那么地址翻译硬件就能正常地将虚拟地址变成物理地址了。</p><p><img src="/2021/11/08/malloc/image-20211110151807094.png" alt="image-20211110151807094"></p><p>&emsp;&emsp;虚拟主存是在20世纪60年代早期发明的，远在SRAM之前。在虚拟主存的习惯说法中，块被称为页。在磁盘和主存之间传送页的活动叫做<strong>交换</strong>(swapping)或者<strong>页面调度</strong>(paging)。页从磁盘换入DRAM，和从DRAM换出磁盘。仅当不命中发生时，才换入页的策略被称为按需页面调度(demand paging)。其他的方法也是可能的，比如尝试着预测不命中，在页实际被引用之前就换入页。然而，所有现代系统都使用的是按需页面调度的方式。</p><p><strong>10.3.5 分配页面</strong></p><p>&emsp;&emsp;下图展示了当操作系统分配一个新的虚拟页时，对示例页表的影响，例如，调用malloc。在这个示例中，通过在磁盘上创建空间，并更新PTE5，使它指向磁盘上这个新创建的页面，从而分配VP5。<img src="/2021/11/08/malloc/image-20211110154046679.png" alt="image-20211110154046679"></p><p><strong>10.3.6 局部性再次搭救</strong></p><p>&emsp;&emsp;在了解到虚拟主存是把物理主存当做磁盘的缓存，通过页表和缺页异常将磁盘上的页放入物理主存时，我们的第一印象：不命中的惩罚辣么大，虚拟主存系统的效率一定很低。实际上虚拟主存工作的相当好，这归功于<strong>局部性</strong>(locality)。</p><p>&emsp;&emsp;尽管在整个运行过程中程序引用的所有页面大小可能超出物理主存的大小，但是程序往往趋向于在一个较小的<strong>活动页面集</strong>(active page set)上工作，这个集合叫做<strong>工作集</strong>(working set)或者<strong>常驻集合</strong>(resident set)。在初始开销，也就是将工作集中的页调入主存中后，在接下来的指令执行中，将大量命中工作集的页，而不会产生多少额外的缺页开销。这种现象称为局部性。</p><p>&emsp;&emsp;如果我们的程序有良好的局部性，虚拟主存系统就能工作得相当好。当然，不是所有的程序都有良好的局部性。如果工作集的大小超出了物理存储器的大小，那么程序将处于一种不幸的状态，叫做<strong>颠簸</strong>(thrashing)，这时页面将不断地换进换出。如果一个程序执行慢得像爬一样，那么聪明的程序员会考虑看是不是发生了颠簸。</p><p><strong><em>旁注：统计缺页次数</em></strong>：你可以用unix的getusage函数监测缺页的数量(以及许多其他的信息)。</p></div></div><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>10.4 虚拟主存作为主存管理的工具</span></div>    <div class="hide-content"><p>&emsp;&emsp;上述内容，使我们看到虚拟主存是如何用DRAM来缓存来自更大虚拟地址空间的页面。到目前为止，我们都假设有一个单独的页表，将一个虚拟地址空间映射到物理地址空间。实际上，操作系统为每个进程提供了一个独立的页表，因而每个进程都有一个独立的虚拟地址空间。下图示例中，进程i的页表将VP1映射到PP2，VP2映射到PP7。相似地，进程j的页表将VP1映射到PP67, VP2映射到PP10。注意，多个虚拟页面可以映射到同一个共享物理页上。</p><p><img src="/2021/11/08/malloc/image-20211110162016209.png" alt="image-20211110162016209"></p><p>&emsp;&emsp;按需页面调度和独立的虚拟地址空间的结合对系统中主存的使用和管理造成了深远的影响。特别的，虚拟主存简化了程序的链接和加载，共享代码和数据，以及对程序分配主存。</p><p><strong>10.4.1 简化链接</strong></p><p>&emsp;&emsp;独立的地址空间允许每个进程使用相同的结构存放如虚拟主存，而不管代码和数据实际存放在物理主存的何处。例如，每个Linux进程都使用下图所示的格式。</p><p>&emsp;&emsp;文本区总是从虚拟地址0x08048000处开始，栈总是从0xbfffffff向下伸展，共享库代码总是从地址0x40000000处开始，而操作系统代码和数据总是从0xc0000000开始。这样的一致性极大地简化了链接器的设计和实现，允许链接器生成全链接的可执行文件，这些可执行文件是独立于物理存储器中代码和数据的最终位置的。</p><p><img src="/2021/11/08/malloc/image-20211110162453991.png" alt="image-20211110162453991"></p><p><strong>10.4.2 简化共享</strong></p><p>&emsp;&emsp;独立地址空间为操作系统提供了管理进程共享的机制。一般而言，每个进程都有自己私有的代码、数据、堆以及栈区域，是不和其他进程共享的。在这种情况中，操作系统创建页表，将相应的虚拟页映射到不同的物理页面。</p><p>&emsp;&emsp;然而，有时需要进程共享代码和数据。例如，每个进程必须调用相同的操作系统内核代码，而每个C程序都会调用标准库中的程序，比如printf。操作系统通过将不同进程中适当的虚拟页面映射到的物理页面，从而使多个进程共享代码，而不是在每个进程中都包括单独的内核和C标准库的拷贝。</p><p><strong>10.4.3 简化主存分配</strong></p><p>&emsp;&emsp;当一个程序要求额外的对空间时(例如调用malloc的结果)，操作系统分配k个连续的虚拟主存页，并且将它们映射到物理主存中任意k个页。由于页表工作的方式，操作系统没有必要分配k个连续的物理主存页面。页面可以随机地分散在物理存储器中。</p><p><strong>10.4.4 简化加载</strong></p><p>&emsp;&emsp;虚拟主存也使加载可执行文件和已共享目标文件到主存中变得容易。ELF(Executable and Linkable Format)可执行文件中的.txt和.data节是相邻的。为了加载这些节到一个新创建的进程中，Linux加载程序分配了一个从地址0x08048000处开始的连续的虚拟页区域，将它们标识为无效(即未缓存)，并将它们的页表条目指向目标文件中适当的位置。</p><p>&emsp;&emsp;有趣的是，加载器从不真正地从磁盘中拷贝任何数据到主存中。当每个页面第一次被引用时，虚拟主存系统将通过缺页异常把数据从磁盘上调入到主存。</p><p>&emsp;&emsp;映射一个连续虚拟页的集合到任意一个文件中的任意一个位置，叫做主存映射(memory mapping)。Unix提供了一个叫做mmap的系统调用，允许应用程序进行主存映射。我们将在10.8节中更详细地描述应用层主存映射。</p></div></div><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>10.5 虚拟主存作为主存保护的工具</span></div>    <div class="hide-content"><p>&emsp;&emsp;任何现代计算机系统必须为操作系统提供手段来控制进程对主存的访问。不允许一个用户进程修改它的只读文本段，也不应该允许它读或修改任何内核中的代码和数据结构，不应该允许它读或写其他进程的私有主存，不允许它修改任何与其他进程共享的虚拟页面，除非所有共享者显示地允许它这么做。</p><p>&emsp;&emsp;提供独立的地址空间使得分离不同进程的私有主存变得容易。每次CPU生成一个地址时，地址翻译硬件都会读一个PTE，可以通过在PTE上添加一些额外的许可位来控制对一个虚拟页面内容的访问。</p><p><img src="/2021/11/08/malloc/image-20211110183033531.png" alt="image-20211110183033531"></p><p>&emsp;&emsp;在这个示例中，我们已经添加了三个许可位到每个PTE。SUP位表示进程是否必须运行在内核模式下才能访问该页。运行在内核模式中的进程可以访问任何页，但是运行在用户模式中的进程只允许访问那些SUP为0的页面。READ位和WRITE位控制对页面的读和写访问。例如，如果进程i运行在用户模式下，那么它有读VP0和读写VP1的权限。然而不允许它访问VP2。</p><p>&emsp;&emsp;如果一条指令违反了这些许可条件，那么CPU就触发一个一般保护屏障，执行一个内核中的异常处理程序。Unix shell将这种异常报告为”段错误(segmentation fault)”。</p></div></div><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>10.6 地址翻译</span></div>    <div class="hide-content"><p>&emsp;&emsp;这一节讲的是地址翻译的基础知识，省略了大量细节，尤其是和时钟相关的细节，虽然这些细节对硬件设计者来说是非常重要的，但是超出了我们讨论的范围。下图概括了本节使用的所有符号：</p><p><img src="/2021/11/08/malloc/image-20211110184631885.png" alt="image-20211110184631885"></p><p>&emsp;&emsp;地址翻译是一个N元素的虚拟地址空间(VAS)中的元素和一个M元素的物理地址空间(PAS)中元素的映射。</p><p>&emsp;&emsp;MAP(A) = A’ 如果虚拟地址A出的数据在PAS的物理地址A‘处</p><p>   &emsp;&emsp;&emsp;&emsp;&emsp;=∅ 如果虚拟地址A出的数据不在物理主存中</p><p>&emsp;&emsp;<strong>下图展示了MMU是如何利用页表来实现虚拟地址到物理地址的转换。</strong>CPU中的一个控制寄存器，<strong>页表基址寄存器</strong>(page table base register, PTBR)指向当前进程的页表。n位的虚拟地址包含两个部分：一个p位的VPO(virtual page offset，虚拟页面偏移)和一个(n-p)位的VPN(virtual page number，虚拟页号)。MMU利用VPN来选择适当的PTE。例如，VPN0选择PTE0, VPN1选择PTE1, 以此类推。将页表条目中的PPN(physical page number，物理页号)和虚拟地址中的VPO拼接，就得到相应的物理地址。</p><p><img src="/2021/11/08/malloc/image-20211110184736396.png" alt="image-20211110184736396"></p><p><strong>下图展示了页命中时，CPU硬件执行的步骤。</strong></p><ul><li>第一步：处理器生成一个虚拟地址，并把它传给MMU。</li><li>第二步：MMU生成PTE地址，并从高速缓存/主存请求得到它。</li><li>第三步：高速缓存/主存向MMU返回PTE。</li><li>第四步：MMU构造物理地址，并把它传送给高速缓存/主存。</li><li>第五步：高速缓存/主存返回所请求的数据字给处理器。</li></ul><p><img src="/2021/11/08/malloc/image-20211110190300518.png" alt="image-20211110190300518"></p><p><strong>缺页时，要求硬件和操作系统内核协作完成地址映射</strong></p><ul><li>第一步：处理器生成一个虚拟地址，并把它传给MMU。</li><li>第二步：MMU生成PTE地址，并从高速缓存/主存请求得到它。</li><li>第三步：高速缓存/主存向MMU返回PTE。</li><li>第四步：PTE中的有效位是0，MMU触发一次异常，执行内核中的缺页异常处理程序。</li><li>第五步：缺页处理程序找到一个物理主存中的牺牲页，如果这个页已经被修改了，就把它换出到磁盘。</li><li>第六步：缺页处理程序调入新的页面到主存，并更新主存中的PTE。</li><li>第七步：缺页处理程序返回到原来的进程，重新执行导致缺页的指令。CPU将引起缺页的虚拟地址重新发送给MMU。这次虚拟页面在主存中。MMU向高速缓存/主存请求PTE, 高速缓存/主存返回PTE, MMU构造物理地址发送给高速缓存/主存，高速缓存/主存返回所请求的数据字给CPU。</li></ul><p><img src="/2021/11/08/malloc/image-20211110191121387.png" alt="image-20211110191121387"></p><p><strong>10.6.1 结合高速缓存和虚拟主存</strong></p><p>&emsp;&emsp;在任何既使用虚拟主存又使用SRAM缓存的系统中，都有应该使用虚拟地址还是使用物理地址来访问高速缓存的问题。大多数系统选择物理寻址。使用物理寻址，多个进程同时在高速缓存中有存储块和共享来自相同虚拟页面的块成为很简单的事。而且，高速缓存无需处理保护问题，因为访问权限的检查是地址翻译的一部分。</p><p><img src="/2021/11/08/malloc/image-20211110191843187.png" alt="image-20211110191843187"></p><p><strong>10.6.2 使用TLB加速地址翻译</strong></p><p>&emsp;&emsp;每次CPU产生一个虚拟地址，MMU就必须查阅一个PTE, 以便将虚拟地址翻译为物理地址。在最糟糕的情况下，这会要求一次对存储器的额外的取数据，代价是几十到几百个周期。如果PTE碰巧缓存在L1中，那么开销就下降到1个或2个周期。然而，许多系统都试图消除这样的开销，它们在MMU中包括了一个关于PTE的小的缓存，称为TLB(translation lookaside buffer，翻译后备缓冲器)。</p><p>&emsp;&emsp;TLB是一个小的、虚拟寻址的缓存，其中每一行都保存着一个由单个PTE组成的块。用于组选择和行匹配的索引和标记字段是从虚拟地址中的虚拟页号中提取出来的(索引找到组，标记找到行)。如果TLB有T=2^t个组，那么TLB索引是由VPN的t个最低位组成的，而TLB标记是由VPN中剩余的位组成的。</p><p><img src="/2021/11/08/malloc/image-20211110193146823.png" alt="image-20211110193146823"></p><p><strong>TLB命中时，地址翻译的步骤：</strong></p><ul><li>第一步：CPU产生一个虚拟地址。</li><li>第二步和第三步：MMU从TLB中取出相应的PTE。</li><li>第四步：MMU将这个虚拟地址翻译成一个物理地址，并且将它发送到高速缓存/主存。</li><li>第五步：高速缓存/主存将所请求的数据字返回给CPU。</li></ul><p><img src="/2021/11/08/malloc/image-20211110193443627.png" alt="image-20211110193443627"></p><p><strong>当TLB不命中时，MMU必须从L1缓存中取出相应的PTE放入TLB中，可能会覆盖一个已有的条目</strong></p><p>&emsp;&emsp;如果该组有空行，则缓存入空行；如果该组中没有空行，就选择一个非空行进行替换。</p><p><img src="/2021/11/08/malloc/image-20211110193508099.png" alt="image-20211110193508099"></p><p><strong>10.6.3 多级页表</strong></p><p>&emsp;&emsp;每个进程都有一个页表，在地址空间为32位的系统中，如果每个页大小4KB，每个PTE大小4字节，则每个进程需要4M(4*2^32/2^12)B大小的页表驻留在主存中。</p><p>&emsp;&emsp;用来压缩页表的常用方法是使用层次结构。比如在一个两级页表结构中，让每个页表的大小都为4KB，每个页表就有1K个PTE。一级页表中的每个PTE指向一个二级页表，一个二级页表存放了1k个正常的PTE。所以一个一级页表的PTE相当于映射了1K个页，即1K*4KB=4MB的虚拟地址空间。一个一级页表有1K个PTE，就相当于映射了1K*4MB=4GB的虚拟地址空间到物理主存。</p><p><img src="/2021/11/08/malloc/image-20211110195246419.png" alt="image-20211110195246419"></p><p>&emsp;&emsp;这种层级页表结构节省了很多空间，如果一级页表中的一个PTE是空的，那么就没有二级页表，对于一个普通程序而言，4GB的虚拟地址空间大部分都是未分配的。只有一级页表和最经常使用的二级页表才需要缓存在主存中。</p><p>&emsp;&emsp;使用k级页表结构的地址翻译。虚拟地址被划分成了k个VPN和1个VPO。每个VPNi都是一个找到i级页表的索引，1≤i≤k。第j级页表中的每个PTE，1≤j≤k-1，都指向第j+1级的某个页表的基址。第k级页表中的每个PTE都包含某个物理页面的PPN，或者一个磁盘块的地址。为了构造物理地址，MMU必须访问k个PTE。</p><p><img src="/2021/11/08/malloc/image-20211110201809977.png" alt="image-20211110201809977"></p><p>&emsp;&emsp;访问k个PTE, 乍一看是昂贵的。然而，这里TLB能够起作用，通过将页表中不同层次上的PTE缓存起来，实际中，多级页表的地址翻译并不比单级页表慢很多。</p><p><strong>10.6.4 综合：端到端的地址翻译</strong></p><p>&emsp;&emsp;这一节，我们通过一个具体的端到端的地址翻译示例，来综合一下我们刚学过的内容。这个示例运行在有一个TLB和L1缓存的小系统上。我们假设：</p><ul><li>主存是按字节寻址的。</li><li>主存访问的字长是1字节。</li><li>虚拟地址是14位长(n=14)。</li><li>物理地址是12位长(m=12)。</li><li>页面大小是64字节(P=64)。</li><li>TLB有四组，每组4行，共16个条目。</li><li>L1缓存是物理寻址，16组，每组一行，每行大小4字节(也叫直接映射)。</li></ul><p>&emsp;&emsp;因为页面大小是64=2^6字节，所以虚拟地址和物理地址的低6位分别是VPO和PPO。虚拟地址的高8位作为VPN。物理地址的高6位作为PPN。</p><p><img src="/2021/11/08/malloc/image-20211110202649191.png" alt="image-20211110202649191"></p><p><strong>TLB、页表、L1cache某时间点的状态：</strong></p><ul><li>TLB。TLB是利用VPN的为进行虚拟寻址的。因为TLB有四个组，所以VPN的低两位就作为组索引(TLBI)。VPN中剩下的高6位作为标记(TLBT)，用来区别可能映射到同一个TLB组的不同的VPN。</li></ul><p><img src="/2021/11/08/malloc/image-20211110203159830.png" alt="image-20211110203159830"></p><ul><li>页表。这个页表是一级结构，一共有2^14/2^6=2^8个页，也就是有256个页表条目。然而我们只对开头的16个感兴趣。为了方便，我们用索引它的VPN标识每个PTE; 但要记住这些VPN并不是页表的一部分，也不在主存中。</li></ul><p><img src="/2021/11/08/malloc/image-20211110203251665.png" alt="image-20211110203251665"></p><ul><li>缓存。直接映射的缓存，是通过物理地址中的字段来寻址的。因为处理器只要4字节，而cache一行有16字节，分为4块，所以物理地址的低2位作为块偏移。因为有16组，所以接下来的4位就用来表示组索引(CI)，剩下6位作为标记(CT)。</li></ul><p><img src="/2021/11/08/malloc/image-20211110203631143.png" alt="image-20211110203631143"></p><p>&emsp;&emsp;给定了初始化设定。让我们来看看当CPU执行一条读地址0x03d4处字节的加载指令时，会发生什么？</p><p><img src="/2021/11/08/malloc/image-20211110204314000.png" alt="image-20211110204314000"></p><p>&emsp;&emsp;开始时，MMU从虚拟地址中抽出VPN(0x0f)，并且检查TLB是否缓存了PTE 0x0f的一个拷贝。TLB从VPN中抽取出TLB索引(0x3)和TLB标记(0x3)，组0x3的第二个条目中有效位匹配，命中，然后将缓存的PPN(0X0D)返回给MMU。如果TLB不命中，那么MMU就需要从主存中取出相应的PTE。</p><p>&emsp;&emsp;现在，MMU将PTE的PPN(0x0D)和来自虚拟地址的VPO(0x14)拼接起来，形成物理地址(0x354)。</p><p><img src="/2021/11/08/malloc/image-20211110205440198.png" alt="image-20211110205440198"></p><p>&emsp;&emsp;接下来，MMU将物理地址发送给缓存，缓存从物理地址中抽取出缓存偏移CO(0X0)、缓存组索引CI(0x5)以及缓存标记CT(0X0D)。组0x5中的标记与CT匹配，命中，读出在偏移量CO处的字节(0x36)，并将它返回给MMU，随后MMU将它传递会CPU。</p></div></div><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>10.7 案例研究 ：Linux主存系统</span></div>    <div class="hide-content"><p>&emsp;&emsp;Linux为每个进程维持了一个单独的虚拟地址空间。内核虚拟主存位于0xc0000000之上，包含内核中的代码和数据。内核虚拟主存的某些区域被映射到所有进程的共享物理页面。例如，每个进程共享内核的代码和全局数据结构。Linux也将一组连续的虚拟页面(大小为主存大小)映射到相应的一组连续的物理页面。这就为内核提供了一种便利的方法，来访问物理存储器中任何特定的位置。内核虚拟主存的其他区域包含每个进程都不相同的数据。示例包括页表、内核在进程的上下文中执行代码时用的栈，以及记录虚拟地址空间当前组织的各种数据结构。</p><p><img src="/2021/11/08/malloc/image-20211110215115625.png" alt="image-20211110215115625"></p><p><strong>Linux虚拟主存区域</strong></p><p>&emsp;&emsp;Linux将虚拟主存组织成一些<strong>区域(也叫作段)</strong>的集合。一个区域(area)是已经分配的连续虚拟页。例如代码段、数据段、堆、共享库段，以及用户栈都是不同的区域。每个已分配的虚拟页都保存在某个区域中。区域的概念允许虚拟地址空间有间隙。</p><p>&emsp;&emsp;图10.29展示了记录进程虚拟主存区域的内核数据结构。内核为每个进程维护一个单独的任务结构(task_struct)。任务结构中的元素包含或者指向内核运行该进程所需要的所有信息(例如，PID、指向用户栈的指针、可执行文件的名字，以及程序计数器)。</p><p>&emsp;&emsp;task_struct中的一个条目mm指向mm_struct, mm_struct描述了虚拟主存当前的状态。我们感兴趣的两个字段是pgd和mmap，其中pgd指向一级页表的基址，mmap指向一个vm_area_structs(区域结构)的链表，其中每个vm_area_structs都描述了当前虚拟地址空间的一个区域(area)。当内核运行这个进程时，它就将pgd存放在PDBR控制寄存器中。</p><p>&emsp;&emsp;一个区域结构(vm_area_struct)包含下面的字段：</p><ul><li>vm_start：指向这个区域的起始处。</li><li>vm_end：指向这个区域的结束处。</li><li>vm_port：描述这个区域内包含的所有页面的读写许可权限。</li><li>vm_flags：描述这个区域内的页面是否是与其他进程共享的，还是这个进程私有的(还描述了一些其他信息)。</li><li>vm_next：指向链表中下一个区域结构。</li></ul><p><img src="/2021/11/08/malloc/image-20211111103449044.png" alt="image-20211111103449044"></p><p><strong>Linux缺页异常处理</strong></p><p>&emsp;&emsp;假设MMU在试图翻译某个虚拟地址A时，触发了一个缺页。这个异常将导致CPU执行内核的缺页处理程序，处理程序执行如下步骤：</p><ol><li>&emsp;&emsp;虚拟地址A是合法的吗？换句话说，A在某个区域结构(vm_area_struct)定义的区域内吗？为了回答这个问题，缺页处理程序搜索区域结构链表，将A和每个区域结构中的vm_start和vm_end做比较。如果这个指令是不合法的，那么缺页处理程序就触发一个段错误，从而终止这个进程。这个情况在图10.30中标识为”1”。<br>&emsp;&emsp;因为一个进程可以创建任意数量的虚拟主存区域(使用下一节中描述的mmap函数)，所以顺序搜索区域结构的链表花销可能会很大。因此在实际中，Linux在链表中添加了一棵树，并在这棵树上查找。</li><li>&emsp;&emsp;试图进行的对存储器的访问是否合法？换句话说，进程是否有读或这写这个区域内页面的权限？例如，这个缺页是不是由一条试图对代码段里的只读页面进行写操作的存储指令造成的？这个缺页是不是因为一个运行在用户模式下的进程试图从内核虚拟主存中读取字造成的？如果试图进行的访问是不合法的，那么缺页处理程序会触发一个保护异常，终止这个进程。这种情况在图10.30中标识为“2”。</li><li>&emsp;&emsp;此时，内核知道了这个缺页是由于对合法的虚拟地址进行合法的操作造成的。它选择一个牺牲页面，如果这个牺牲页面被修改过，那么就将它交换出去，换入新的页面，并更新页表。当缺页处理程序返回时，CPU重新执行引起缺页的指令，这条指令将再次发送A到MMU，这一次，MMU就能正常地翻译A。</li></ol><p><img src="/2021/11/08/malloc/image-20211111110309063.png" alt="image-20211111110309063"></p></div></div><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>10.8 主存映射</span></div>    <div class="hide-content"><p>&emsp;&emsp;Linux通过将一个虚拟主存区域与一个磁盘上的对象(object)关联起来，以初始化这个虚拟主存区域的内容，这个过程称为主存映射(memory mapping)。虚拟主存区域可以映射到两种类型的对象：</p><ol><li>Unix文件系统中的普通文件：一个区域可以映射到一个普通磁盘文件(例如一个可执行目标文件)的连续部分。文件被分成页面大小的片，每一片包含一个虚拟页面的初始内容。因为按需进行页面调度，所以这些虚拟页面没有实际交换进入物理主存，直到CPU第一次引用到页面。如果区域比文件的这部分要大一些，就用0填充区域的剩下部分。</li><li>匿名文件：一个区域也可以映射到一个匿名文件，匿名文件是由内核创建的，包含的全是二进制零。CPU第一次引用这样一个区域内的虚拟页面时，内核就在物理主存中找到一个合适的牺牲页面，如果该页面被修改过，就将这个页面换出来，用二进制0覆盖牺牲页面，并更新页表，将这个页面标记为是驻留在存储器中的。注意在磁盘和主存之间并没有实际的数据传送。因为这个原因，映射到匿名文件的区域中的页面，有时也叫作二进制零的页(demand-zero page)。</li></ol><p>&emsp;&emsp;无论在那种情况，一旦一个虚拟页面被初始化了，它就在一个由内核维护的专门的<strong>交换文件</strong>(swap file)之间换来换去。交换文件也叫作交换空间或者交换区域。需要意识到很重要的一点是，任何时间点，交换空间都限制着当前运行着的程序能够分配的虚拟页面的总数。</p><p><strong>10.8.1 再看共享对象</strong></p><p>&emsp;&emsp;一个对象可以被映射到虚拟存储器的一个区域，要么作为共享对象，要么作为私有对象。如果一个进程将一个共享对象映射到它的虚拟地址空间的一个区域内，那么这个进程对这个区域的任何写操作，对于那些也把这个共享对象映射到它们虚拟主存的其他进程而言，也是可见的。而且，这些变化也会反映在磁盘上的原始对象中。</p><p>&emsp;&emsp;另一方面，对一个映射到私有对象的区域做的改变，对于其他进程来说是不可见的，并且进程对这个区域所做的任何写操作都不会反映在磁盘上的对象中。一个共享对象映射到的虚拟主存区域叫做共享区域，一个私有对象映射到主存区域叫做私有区域。</p><p>&emsp;&emsp;假设进程1将一个共享对象映射到它的虚拟主存的一个区域中，进程2将同一个共享对象也映射到它的虚拟主存中(虚拟地址不一定相同)。</p><p><img src="/2021/11/08/malloc/image-20211110213424453.png" alt="image-20211110213424453"></p><p>&emsp;&emsp;因为每个对象都有一个唯一的文件名，内核可以迅速判定进程1已经映射了这个对象，而且可以使进程2中的页表条目指向相应的物理页面。</p><p>&emsp;&emsp;私有对象使用叫做<strong>写时拷贝</strong>(copy-on-write)的巧妙技术被映射到虚拟主存中。一开始，多个进程将同一个私有对象映射到自己的虚拟主存时，在物理主存中只保存私有对象的一份拷贝。对于每个映射私有对象的进程，相应私有区域的页表条目都被标记为只读，并且区域结构被标记为私有的写时拷贝。只要没有进程试图写它自己的私有区域，它们就可以继续共享物理主存中对象的一个单独拷贝。然而，只要有一个进程试图写私有区域内的某个页面，那么这个写操作就会触发一个保护屏障。</p><p>&emsp;&emsp;当故障处理程序注意到保护异常是由于进程试图写私有的写时拷贝区域中的一个页面而引起的，他就会在物理主存中创建这个页面的一个新拷贝，更新页表条目指向这个新的拷贝，然后恢复这个页面的可写权限。当故障处理程序返回时，CPU重新执行这个写操作，现在在新创建的页面上这个写操作就可以正常执行了。</p><p>&emsp;&emsp;写时拷贝节省了稀有的物理主存。</p><p><img src="/2021/11/08/malloc/image-20211110214508298.png" alt="image-20211110214508298"></p><p><strong>10.8.2 再看fork函数</strong></p><p>&emsp;&emsp;现在，我们理解了虚拟主存和主存映射，那么我们可以清晰地知道fork函数是如何创建一个新进程的。</p><p>&emsp;&emsp;当fork函数被当前进程调用时，内核为新进程创建各种数据结构，并分配给它一个唯一的PID。为了给这个新进程创建虚拟主存，它创建了当前进程的 mm_struct、区域结构(vm_area_struct)和页表的原样拷贝。它标记两个进程中的每个页面为只读，并标记两个进程中每个区域结构为写时私有拷贝的。</p><p>&emsp;&emsp;当fork函数返回时，新进程的虚拟主存和调用fork时的虚拟主存相同。当这两个进程中的任一个后来进行写操作时，写时拷贝机制就会创建新页面并更新页表。</p><p><strong>10.8.3 再看execve函数</strong></p><p>&emsp;&emsp;虚拟主存和主存映射在将程序加载到主存的过程中扮演着关键的角色。假设运行在当前进程的程序执行了如下的execve调用：</p><p>&emsp;&emsp;Execve(“a.out”, argv, environ);</p><p>&emsp;&emsp;execve函数在当前进程中加载并运行包含在可执行目标文件a.out中的程序，用a.out程序替代当前程序。加载并运行a.out需要以下步骤：</p><ul><li>删除已存在的用户区域：删除当前进程虚拟地址的用户部分中已存在的区域结构。</li><li>映射私有区域：为新程序的文本、数据、bss和栈区域创建新的区域结构(task-&gt;mm-&gt;mmap-&gt;vm_area_structs)。所有这些新的区域都是私有的写时拷贝的。文本和数据区域被映射为a.out文件中的文本和数据区。bss区域是请求二进制零的，映射到匿名文件，其大小包含在a.out中。栈和堆区域也是请求二进制零的，初始长度为0。图10.33概括了私有区域的不同映射。</li><li>映射共享区域：如果a.out程序与共享对象链接，比如标准C库的lib.so，那么这些对象都是动态链接到这个程序的，并且映射到用户虚拟地址空间中的共享区域内。</li><li>设置程序计数器(PC)：execve做的最后一件事情就是设置当前进程上下文中(进程记住自己被切换时的寄存器值，如rip中的指令地址)的程序计数器，使之指向文本区域的入口点。</li></ul><p><img src="/2021/11/08/malloc/image-20211111113721701.png" alt="image-20211111113721701"></p><p><strong>10.8.4 使用mmap函数的用户级主存映射</strong></p><p>&emsp;&emsp;Unix进程可以使用mmap函数来创建新的虚拟主存区域，并将对象映射到这些区域中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">mmap</span><span class="params">(<span class="keyword">void</span>* start, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span>, offset)</span></span>;</span><br><span class="line"><span class="comment">//返回：若成功时则为指向映射区域的指针，若出错则为1</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;mmap函数让内核创建一个虚拟主存区域，最好是从地址start开始的一个区域，并将文件描述符fd指定的对象的一个连续组块(多个连续页)映射到这个新的区域。连续的组块大小为length字节，从距文件开始出偏移量为offset字节的地方开始。start地址通常被定义为NULL。</p><p><img src="/2021/11/08/malloc/image-20211111122753433.png" alt="image-20211111122753433"></p><p>&emsp;&emsp;参数port是新映射虚拟主存区域的访问权限字段(也就是，在相应区域结构中的vm_port字段)。</p><ul><li>PORT_EXEC：这个区域内的页面由可以被CPU执行的指令组成。</li><li>PORT_READ：这个区域内的页面可读。</li><li>PORT_WRITE：这个区域内的页面可写。</li><li>PORT_NONE：这个区域内的页面不能被访问。</li></ul><p>&emsp;&emsp;参数flags由描述被映射对象类型的位组成。如果MAP_ANON标记位被设置，并且fd为NULL，那么被映射的对象就是一个匿名对象，而相应的虚拟页面是请求二进制零的。MAP_PRIVATE表示被映射的对象是一个私有的写时拷贝对象，而MAP_SHARED表示是一个共享对象。例如：</p><p>&emsp;&emsp;bufp = Mmap(NULL, size, PORT_READ, MAP_PRIVATE|MAP_ANON, 0, 0);</p><p>让内核创建一个新的包含size字节的、只读、私有、请求二进制零的虚拟存储器区域。如果调用成功，bufp指代新区域的地址。</p><p>&emsp;&emsp;munmap函数删除虚拟存储器的区域：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span>* start, <span class="keyword">size_t</span> length)</span></span>;</span><br><span class="line"><span class="comment">//返回：若成功则为0，若出错则为-1</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;munmap函数删除从虚拟地址start开始的，由接下来length字节组成的区域。接下来对已删除区域的引用会导致段错误。</p></div></div><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>10.9 动态主存分配</span></div>    <div class="hide-content"><p>&emsp;&emsp;虽然可以使用低级的mmap和munmap函数来创建和删除虚拟主存的区域，但是大多数C程序还是会在运行时需要额外虚拟主存时，使用一种动态主存分配器(dynamic memory allocator)。</p><p>&emsp;&emsp;一个动态主存分配器维护着一个称为<strong>堆</strong>(heap)(图10.35)的进程虚拟主存区域。在大多数的Unix系统中，堆是一个请求二进制零的区域，它紧接在未初始化的bss区域后开始，并向上扩大(向更高的地址)。对于每个进程，内核维护着一个变量brk(读作“break”)，它指向堆的顶部。</p><p><img src="/2021/11/08/malloc/image-20211111124445279.png" alt="image-20211111124445279"></p><p>&emsp;&emsp;分配器将堆视为一组不同大小的<strong>块</strong>(block)的集合来维护。每个块就是一个连续的虚拟主存组块(连续多个虚拟页)，要么是已分配的，要么是空闲的。</p><p>&emsp;&emsp;分配器有两种基本风格。两种风格都要求程序显示地分配块，不同之处在于由负责释放已分配的块。</p><ul><li><p>显示分配器(explicit allocator)：要求程序显示地释放任何已分配的块。例如，C标准库提供一种叫做malloc程序包的显式分配器。C程序通过调用malloc函数来分配一个块，并通过调用free函数来释放一个块。C++中的new和delete操作符与C中的malloc和free相当。</p></li><li><p>隐式分配器(implicit allocator)：要求分配器检测何时一个已分配块不再被程序使用，然后就释放这个块。隐式分配器也叫作<strong>垃圾收集器</strong>(garbage collector)，而自动释放未使用的已分配的块的过程叫做<strong>垃圾收集</strong>(garbage collection)。诸如Lisp、ML以及Java之类的高级语言就用垃圾收集来释放已分配的块。</p></li></ul><p>&emsp;&emsp;本节剩下的部分讨论的是显示分配器的设计和实现。我们将在10.10小结中讨论隐式分配器。为了更具体，我们的讨论集中于管理堆区域的分配器。然而，学生们应该明白，主存分配是一个普遍的概念，例如，图形处理密集的程序就经常使用标准分配器来要求获得一大块虚拟主存，然后使用与应用相关的分配器来管理块中的主存，以支持图形节点的创建和销毁。</p><p><strong>10.9.1 malloc和free函数</strong></p><p>&emsp;&emsp;C标准库提供了一个称为malloc程序包的显示分配器。程序通过调用malloc函数来从堆中分配块。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="comment">//返回：若成功则为指针，若出错则为NULL</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;malloc函数返回一个指针，指向大小为至少size字节的主存块，这个块会为可能包含在这个块内的所有数据对象类型做对齐。在我们熟悉的Unix系统上，malloc返回一个8字节边界对齐的块。size_t类型被定义为unsigned int(无符号整数)。</p><p>&emsp;&emsp;如果malloc遇到问题(例如，程序要求的主存块比可用的虚拟主存还要大)，那么它就返回NULL，并设置errno。malloc不初始化它返回的主存。那些想要已初始化的动态主存的应用程序可以使用calloc，calloc是一个基于malloc的瘦包装函数，它将分配的主存初始化为0。想要改变一个以前已分配块的大小，可以使用realloc函数。</p><p>&emsp;&emsp;动态主存分配器(例如malloc)可以通过使用mmap和munmap函数，显示地分配和释放堆主存，还可以使用sbrk函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">sbrk</span><span class="params">(<span class="keyword">int</span> incr)</span></span>;</span><br><span class="line"><span class="comment">//返回：若成功则为老brk指针，若出错则为-1</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;sbrk通过将内核的brk指针增加incr来扩大和减小堆。若果成功，它就返回brk的旧值，否则，它就返回-1，并将errno设置为ENOMEM。如果incr为零，那么sbrk就返回brk的当前值。用一个为负的incr来调用sbrk是合法的。而且很巧妙，因为返回值(brk的旧值)指向在新堆顶上面的第abs(incr)字节。</p><p>&emsp;&emsp;程序通过调用free函数来释放已分配的堆块。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;</span><br><span class="line"><span class="comment">//返回：无</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;ptr参数必须指向一个从malloc获得的已分配块的起始位置。如果不是，那么free的行为就是错的0。更糟的是，free什么都不返回，就不会告诉应用程序出了错误。</p><p>&emsp;&emsp;图10.36展示了使用malloc和free是如何管理一个C程序的16字的(非常)小的堆的。每个方框代表一个4字节的字。内部有阴影的方框表示已分配，内部无阴影的方框表示空闲块。初始时，堆是由一个大小为16字的、双字对齐的空闲块组成的。</p><ul><li>图10.36(a)：程序请求一个4字的块。malloc的响应是：从空闲块的前部切出一个4字的块，并返回一个指向这个块的第一字的指针。</li><li>图10.36(b)：程序请求一个5字的块。malloc的响应时：从空闲块的前部分配一个6字的块。在本例中，malloc在块里填充了一个额外的字，是为了保持空闲块是双字边界对齐的。</li><li>图10.36(c)：程序请求一个6字的块，而malloc就从空闲块的前部切出一个6字的块。</li><li>图10.36(d)：程序释放在图10.36(b)中分配的那个6字的块。注意，在调用free返回之后，指针p2仍然指向被释放了的块。应用有责任在它调用一个新的malloc重新分配之前，不再使用p2。</li><li>图10.36(e)：程序请求一个2字的块。在这种情况中，malloc分配在前一步中被释放了的块的一部分，并返回一个指向这个新块的指针。</li></ul><p><img src="/2021/11/08/malloc/image-20211111164034631.png" alt="image-20211111164034631"></p><p><img src="/2021/11/08/malloc/image-20211111164049976.png" alt="image-20211111164049976"></p><p><strong>10.9.2 为什么要使用动态主存分配</strong></p><p>&emsp;&emsp;程序使用动态主存分配的最重要原因是，它们经常直到程序实际运行时，才知道某些数据结构的大小。例如，假设要求我们编写一个C程序，它读一个n个ASCII码整数的链表，每一行一个整数，从stdin到一个C数组。输入是由整数n，和接下来要读和存储到数组中的n个整数组成的。最简单的方法就是用某种硬编码的最大数组大小静态地定义这个数组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 15213</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, n;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">if</span> (n &gt; MAXN);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input file too big&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;<span class="built_in">array</span>[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;用这样的硬编码的大小来分配数组通常不是好想法。MAXN的值是任意的，和机器上可用的虚拟主存的实际数量没有关系。而且，如果这个程序的使用者想读取一个比MAXN更大的文件，唯一的办法就是用一个更大的MAXN值来重新编译这个程序。虽然对于这个简单的示例来说这不成问题，但是硬编码数组界限的出现对于拥有百万行代码和大量使用者的大型软件产品而言是一场维护的噩梦。</p><p>&emsp;&emsp;一种更好的办法是在运行时，在已知了n的值之后，动态地分配这个数组。使用这种方法，数组大小的最大值就只由可用的虚拟主存数量来限制了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *<span class="built_in">array</span>, i, n;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="built_in">array</span> = (<span class="keyword">int</span>*)Malloc(n * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;<span class="built_in">array</span>[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;动态主存分配是一种有用而重要的编程技术。</p><p><strong>10.9.3 分配器的要求和目标</strong></p><p>&emsp;&emsp;显示分配器必须在一些相当严格的约束条件下工作：</p><ul><li>处理任意请求序列。一个应用可以有任意序列的分配请求和释放请求，只要满足约束条件：每个释放请求必须对应于一个当前已分配的块，这个块产生于以前的分配请求。</li><li>立即响应请求。分配器必须立即相应分配请求。因此，不允许分配器为了提高性能缓冲请求重新排列。</li><li>只使用堆。分配器使用的任何非标量数据结构都必须保存在堆里。</li><li>对齐块。分配器必须对齐块，使得它可以保存任何类型的数据对象。在大多数系统中，这意味着分配器返回的块是8字节对齐的。</li><li>不修改已分配的块。分配器只能操作或者改变空闲块。特别是，一旦块被分配了，就不允许修改或者移动它了。因此，诸如压缩已分配块这样的技术是不允许使用的。</li></ul><p>&emsp;&emsp;在这些条件下，分配器的编写者试图实现吞吐率最大化和存储器使用率最大化，而这两个性能目标经常是相互冲突的。</p><ul><li><strong>目标1：最大化吞吐率</strong>。假定n个分配和释放请求的某种序列：R0,R1,…,Rk,…,Rn-1。<br>我们希望一个分配器的吞吐率最大化，吞吐率就是在每个单位时间里完成的请求数。例如，如果一个分配器在1秒中内完成500个分配请求和500个释放请求，那么它的吞吐率就是每秒1000次操作。一般而言，我们可以通过使满足分配和释放请求的平均时间最小化，来使吞吐率最大化。正如我们会看到的，开发一个具有合理性能的分配器并不困难，所谓合理性能是指一个分配请求的最糟运行时间与空闲块的数量成线性关系，而一个释放请求的运行时间是一个常数。</li><li><strong>目标2：最大化主存利用率</strong>。天真的程序员经常不正确地假设虚拟主存是一个无限的资源。实际上，一个系统中被所有进程分配的虚拟主存的全部数量是受磁盘上交换空间的数量限制的。好的程序员知道虚拟主存是一个有限的空间，必须高效地使用，对于可能被要求分配和释放大块主存的动态主存分配器来说，尤其如此。<br>有很多方式来描述一个分配器使用堆的效率如何。在我们的经验中，最有用的标准是<strong>峰值利用率</strong>(peak utilization)。假定n个分配和释放请求的某种序列：R0,R1,…,Rk,…,Rn-1。<br>如果一个应用程序请求一个p字节的块，那么得到的已分配块的<strong>有效载荷</strong>(payload)是p字节。在 请求Rk完成之后，<strong>聚集有效载荷</strong>(aggregate payload)，表示为Pk，为当前已分配的块的有效载荷之和，而Hk表示堆的当前的大小。<br>&emsp;&emsp;那么，前k个请求的峰值利用率，表示为 Uk = max(Pi) / Hk，i≤k。<br>那么，分配器的目标就是在真个序列中使峰值利用率Un-1最大化。正如我们将要看到的，在最大化吞吐率和最大化利用率之间是有平衡关系的。特别是，以堆利用率为代价，很容易编写出吞吐率最大化的分配器。分配器设计中一个有趣的挑战就是在两个目标之间找到一个适当的平衡。</li></ul><p><strong>10.9.4 碎片</strong></p><p>&emsp;&emsp;造成堆利用率很低的主要原因是一种称为<strong>碎片</strong>(fragmentation)的现象，这种现象是当有未使用的主存但不能满足分配请求。有两种形式的碎片：<strong>内部碎片</strong>(internal fragmentation)和<strong>外部碎片</strong>(external fragmentation)。</p><p>&emsp;&emsp;内部碎片是描述一个已分配块比有效载荷大的现象。很多原因都可能造成这个问题。例如，一个分配器的实现可能对增加块的大小以满足边界对齐。</p><p>&emsp;&emsp;内部碎片的量化是简单的，就是已分配块和它们的有效载荷之差的和。因此，在任意时间点，内部碎片的数量只取决之前的请求和分配器的实现方式。</p><p>&emsp;&emsp;外部碎片是描述空闲存储器合计起来能够满足一个分配请求，但是没有一个单独的空闲块大到能处理这个请求的现象。</p><p>&emsp;&emsp;外部碎片比内部碎片的量化要困难的多。因为它不仅取决于以前的请求和分配器的实现方式，还取决于未来的请求。假设k个请求之后，所有空闲块的大小都恰好是4个字。这个堆会有外部碎片吗？答案取决于将来的请求，如果将来所有的分配请求都比4个字小，那么就不会有外部碎片。如果有一个或多个请求比4个字大，那么这个堆就会有外部碎片。</p><p>&emsp;&emsp;因为外部碎片难以量化，所以分配器试图维持少量的大空闲块，而不是维持大量的小空闲块。</p><p><strong>10.9.5 实现问题</strong></p><p>&emsp;&emsp;可以想象出的最简单的分配器，会把堆组织成一个大的字节数组，还有一个指针P，初始指向这个数组的第一个字节。为了分配size字节，malloc将P的当前值保存在栈里，将P增加size，并将P的旧值返回到调用函数。free只是简单地返回调用函数，而不做任何其他事情。</p><p>&emsp;&emsp;这个简单的分配器是一种极端情况。因为每个malloc和free只执行很少量的指令，吞吐率会极好。然而，因为分配器从不重复使用任何块，存储器利用率将极差。一个实际的分配器要在吞吐率和利用率之间把握好平衡，就必须考虑以下几个问题。</p><ul><li><strong>空闲块组织：</strong>我们如何记录空闲块。</li><li><strong>放置：</strong>我们如何选择一个合适的空闲块来放置一个新分配的块？</li><li><strong>分隔：</strong>在我们将一个新分配的块放置到某个空闲块之后，我们如何处理这个空闲块中的剩余部分？</li><li><strong>合并：</strong>我们如何处理一个刚刚被释放的块？</li></ul><p>&emsp;&emsp;本章的剩余部分，将详细讨论这些问题。因为像放置、分隔以及合并这样的基本技术贯穿在许多不同的空闲块组织方式中，所以我们将在一种叫做隐式空闲链表的简单空闲块组织结构中来介绍它们。</p><p><strong>10.9.6 隐式空闲链表</strong></p><p>&emsp;&emsp;任何实际的分配器都需要一些数据结构，用来划分块边界，并区别已分配块和空闲块。大多数分配器将这些信息嵌在块本身当中。一个简单的方法如图10.37所示。</p><p><img src="/2021/11/08/malloc/image-20211111183244428.png" alt="image-20211111183244428"></p><p>&emsp;&emsp;在这种结构下，一个块是由一个字的头部、有效载荷，以及可能的填充组成的。头部记录了这个块的大小(包括头部和所有填充)，以及这个块是已分配的还是空闲的。如果我们强加一个双字的对齐约束条件，那么块大小就总是8的倍数，且块大小的最低3位总是零。因此，我们只需要存储块大小的29个高位，用剩余的3位来记录其他信息。我们用头部的最低位指明这个块是已分配的，还是空闲的。例如，假设我们有一个已分配的块，大小为24(0x18)字节。那么它的头部将是：</p><p>&emsp;&emsp;0x00000018 | 0x1 = 0x00000019.</p><p>&emsp;&emsp;类似地，一个块大小为40(0x28)字节的空闲块有如下的头部：</p><p>&emsp;&emsp;0x00000028 | 0x0 = 0x00000028.</p><p>&emsp;&emsp;头部后面就是应用调用malloc时申请的有效载荷。有效载荷后面是一块不使用的填充块，其大小可以是任意的。填充可能是分配器策略的一部分，用来对付外部碎片。或者也需要用它来满足对齐要求。</p><p>&emsp;&emsp;假设块的格式如图10.37所示，我们可以将堆组织为一个连续的已分配块和空闲块的序列，如图10.38所示。</p><p><img src="/2021/11/08/malloc/image-20211111185230381.png" alt="image-20211111185230381"></p><p>&emsp;&emsp;我们称这种结构为<strong>隐式空闲链表</strong>，是因为空闲块是通过头部中的大小字段隐式地连接着的。分配器可以通过遍历堆中的所有块，从而间接地遍历整个空闲块的结合。注意，我们需要特别标记出结束的块，在这个示例中，就是一个设置了已分配位而大小为0的终止头部(terminating header)。</p><p>&emsp;&emsp;隐式空闲链表的优点是简单。显著的缺点是任何操作的开销，例如放置分配的块需要搜索空闲块，与堆中已分配块和空闲块的总数呈线性关系。</p><p>&emsp;&emsp;很重要的一点是，意识到系统对齐要求和分配器对齐要求对最小快的大小有强制要求。例如，我们假设一个双字对齐的要求，那么每个块的大小都必须是双字(8字节)的倍数。因此，图10.37中的块格式就导致最小的块大小为两个字：一个字作头，另一个字维持对齐要求。</p><p><strong>10.9.7 放置分配的块</strong></p><p>&emsp;&emsp;当一个应用请求一个k字节的块时，分配器搜索空闲链表，查找一个足够大、可以放置所请求块的空闲块。分配器执行这种搜索的方式是由<strong>放置策略</strong>(placement policy)确定的。一些常见的策略是首次适配(first fit)、下一次适配(next fit)和最佳适配(best fit)。</p><p>&emsp;&emsp;<strong>首次适配</strong>从头开始搜索空闲链表，选择第一个合适的空闲块。<strong>下一次适配</strong>和首次适配很相似，只不过不是从链表的起始处开始每次搜索，而是从上一次查询结束的地方开始。<strong>最佳适配</strong>检查每个空闲块，选择匹配所需请求大小的最小空闲块。</p><p>&emsp;&emsp;首次适配的一个优点是它趋向于将大的空闲块保留在链表的后面。缺点是它趋向于在靠近链表起始处留下小空闲块的”碎片”，这就增加了对较大块的搜索时间。下一次适配是由Donald Knuth作为首次适配的一种替代品最早提出的，源于这样一个想法：如果我们上一次在某个空闲块里已经发现了一个匹配，那么很可能下一次我们也能在这个剩余块中发现匹配。下一次适配比首次适配运行起来明显要快一些。然而，一些研究表明，下一次适配的主存利用率比首次适配低得多。研究还表明最佳适配比首次试配和下一次适配的主存利用率都高一些。然而，在简单空闲链表组织结构中，比如隐式空闲链表中，使用最佳适配的缺点是它要求对堆进行彻底的搜索。在后面，我们将看到更加巧妙的分离式空闲链表结构，它实现了最佳适配策略，而不需要进行彻底的堆搜索。</p><p><strong>10.9.8 分割空闲块</strong></p><p>&emsp;&emsp;一旦分配器找到一个匹配的空闲块，它就必须做另一个策略决定，那就是分配这个空闲块中多少空间。一个选择是用整个空间块。虽然这种方式简单而快捷，但是主要的缺点是会造成内部碎片。如果放置策略趋向于生产好的匹配，那么额外的内部碎片也是可以接收的。</p><p>&emsp;&emsp;然而，如果匹配不太好，那么分配器通常会选择将这个空闲块分割成两部分。第一部分变成分配块，而剩下的变成一个新的空闲块。图10.39展示了分配器如何分隔图10.38中8个字的空闲块，来满足一个应用对堆主存3个字的请求。</p><p><img src="/2021/11/08/malloc/image-20211111192901515.png" alt="image-20211111192901515"></p><p><strong>10.9.9 获取额外的堆存储器</strong></p><p>&emsp;&emsp;如果分配器不能为请求找到合适的空闲块，将会发生什么呢？一个选择是通过合并那些虚拟主存中相邻的空闲块来创建一些更大的空闲块(在下一节中描述)。然而，如果这样还是不能生成一个足够大的块，那么分配器就会向内核请求额外的堆主存，要么是调用mmap，要么是通过调用sbrk函数。在任一种情况下，分配器都会将额外的(或增加的)主存转换成一个大的空闲块，将这个块插入到空闲链表中，然后将被请求的块放置在这个新的空闲块中。</p><p><strong>10.9.10 合并空闲块</strong></p><p>&emsp;&emsp;当分配器释放一个已分配块时，可能有其他空闲块与这个新释放的空闲块相邻。这些相邻的空闲块可能引起一种现象，叫做<strong>假碎片</strong>(fault fragmentation)，这里有许多可用的空闲块被切割称为小的、无法使用的空闲块。比如，图10.40展示了释放图10.39中分配块后得到的结果。结果是两个相邻的空闲块，每个有效载荷都为3个字。因此，接下来一个请求4字有效载荷的malloc就会失败，即使两个空间块的合计大小足够大，可以满足这个请求。</p><p><img src="/2021/11/08/malloc/image-20211111201537688.png" alt="image-20211111201537688"></p><p>&emsp;&emsp;为了对付假碎片问题，任何实际的分配器都必须合并相邻的空闲块，这个过程称为<strong>合并</strong>(coalescing)。这就提出了一个重要的策略决定，那就是何时执行合并。分配器可以选择<strong>立即合并</strong>(immediate coalescing)，也就是在一个块被释放的时候，就合并所有的相邻块。或者它也可以选择<strong>推迟合并</strong>(deferred coalescing)，也就是等到某个稍晚的时候再合并空闲块。例如，分配器可以推迟合并，直到某个分配请求失败，然后扫描整个堆，合并所有空闲块。</p><p>&emsp;&emsp;立即合并简单明了，可以在常数时间内完成，但是对于某些请求模式，这种方式会产生一种抖动：块会反复地合并，然后马上分割。例如，在图10.40中，反复地分配和释放一个3个字的块将产生大量不必要的分割和合并。在我们对分配器的讨论中，我们会假设使用立即合并，但是你应该了解，快速的分配器通常会选择某种形式的推迟合并。</p><p><strong>10.9.11 带边界标记的合并</strong></p><p>&emsp;&emsp;分配器是如何实现合并的？让我们称我们想要释放的块为当前块。那么，合并下一个空闲块很简单且高效。当前块的头部指向下一个块的额头不，可以检查这个指针以判断下一个块是否是空闲的。如果是，就将它的大小简单地加到当前块的头部上，这两个块在常数时间内被合并。</p><p>&emsp;&emsp;但是我们该如何合并前面的块呢？给定一个带头部的隐式空闲链表，唯一的选择将是搜索整个链表，记住前面块的位置，直到我们到达当前块。使用隐式链表，这意味着每次调用free的时间都与块的数目成线性关系。即使更巧妙的空闲链表组织，搜索时间也不会是常数。</p><p>&emsp;&emsp;Knuth提出了一种聪明而通用的技术，叫做<strong>边界标记(boundary tag)</strong>，允许在常数时间内进行对前面块的合并。这种思想，如图10.41所示，是在每个块的结尾处添加一个<strong>脚部</strong>(footer边界标记),其中脚部就是头部的一个副本。如果每个块包含这样一个脚部，那么分配器就可以通过检查它的脚部，判断前面一个块的起始位置和状态，这个脚部总是在距当前块结尾位置一个字的距离。</p><p><img src="/2021/11/08/malloc/image-20211111222157928.png" alt="image-20211111222157928"></p><p>考虑当分配器释放当前块时所有可能存在的情况：</p><ol><li>前面的块和后面的块都是已分配的。</li><li>前面的块是已分配的，后面的块是空闲的。</li><li>前面的块是空闲的，而后面的块是已分配的。</li><li>前面的和后面的块都是空闲的。</li></ol><p>图10.42展示了我们如何对这四种情况进行合并。</p><p><img src="/2021/11/08/malloc/image-20211111230158312.png" alt="image-20211111230158312"></p><p>&emsp;&emsp;边界标记是简单优雅的，它对许多不同类型的分配器和空闲链表结构都是通用的。然而，它也存在一个缺陷。要求每个块都保持一个头部和一个脚部，在应用程序操作许多小块时，会产生显著的主存开销，例如，如果一个图形应用通过反复调用malloc和free，来动态地创建和销毁图形节点，并且每个图形节点只要求两个字，那么头部和脚部将占用每个已分配块的一半的空间。</p><p>&emsp;&emsp;幸运的是，有一种非常聪明的边界标记的优化方法。已分配的块实际上不需要脚部，空闲的块才需要脚部。我们可以仅在块被释放，写脚部曾经的覆盖效载荷。</p><p><strong>10.9.12 综合：实现一个简单的分配器</strong></p><p>&emsp;&emsp;我们的分配器使用如图10.43所示的memlib.c包提供的一个堆模型。模型的目的在于允许我们再不干涉已存在的malloc包的情况下，运行我们的分配器。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//memlib.c 堆模型</span></span><br><span class="line"><span class="comment">/*private global variables*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *mem_start_brk; <span class="comment">/* points to first byte of the heap */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *mem_brk;       <span class="comment">/* points to last byte of the heap */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *mem_max_addr;  <span class="comment">/* max virtual address for the heap */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*mem_init - initializes the memory system model</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mem_init</span><span class="params">(<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mem_start_brk = (<span class="keyword">char</span> *)Malloc(size); <span class="comment">/* models available VM */</span></span><br><span class="line">    mem_brk = mem_start_brk;              <span class="comment">/* heap is initially empty */</span></span><br><span class="line">    mem_max_addr = mem_start_brk + size;  <span class="comment">/* max VM address for heap */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* mem_sbrk -simple model of the sbrk function. Extends the heap</span></span><br><span class="line"><span class="comment">* by incr bytes and returns the start address of the new area.</span></span><br><span class="line"><span class="comment">* In this model, the heap cannot be shrunk.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mem_sbrk</span><span class="params">(<span class="keyword">int</span> incr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* old_brk = mem_brk;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ( (incr&lt;<span class="number">0</span>) || ((mem_brk+incr) &gt; mem_max_addr)) &#123;</span><br><span class="line">        errno = ENOMEM;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">void</span>*)<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mem_brk += incr;</span><br><span class="line">    <span class="keyword">return</span> old_brk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;分配器包含在一个源文件中(malloc.c)，用户可以编译链接这个源文件到它们的应用之中。分配器提供三个函数给应用程序：</p><p>&emsp;&emsp;1. int mm_init(void);</p><p>&emsp;&emsp;2. void* mm_malloc(size_t size);</p><p>&emsp;&emsp;3. void<em> mm_free(void </em>bp);</p><p>&emsp;&emsp;分配器使用图10.41所示的块格式，空闲链表结构为隐式空闲链表，具有图10.44所示的恒定形式(invariant form)。</p><p><img src="/2021/11/08/malloc/image-20211112135230156.png" alt="image-20211112135230156"></p><p>&emsp;&emsp;第一个字(4字节)是一个用于与结尾块双字边界对齐的填充字。填充后面紧跟着一个特殊的序言块(prologue block)，这是一个8字节的已分配块，只由一个头部和一个脚部组成。序言块是在初始化时创建的，并且永不释放。在序言块后紧跟的是零个或多个由malloc或者free调用创建的普通块。堆总是以一个特殊的结尾块(epilogue block)来结束，这个块是一个大小为零的已分配块，只有一个头部组成。序言块和结尾块是一种消除合并时边界条件的技巧。分配器使用一个私有(静态)全局变量(heap_listp)，它总是指向序言块。(作为小优化，我们可以让它指向下一个块，而不是序言块)。</p><p>&emsp;&emsp;下面是我们在分配器编码中将要使用的基本常数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//操作空闲链表的基本常数和宏</span></span><br><span class="line"><span class="comment">/* Basic constants and macros */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WSIZE4<span class="comment">/* word size(bytes) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DSIZE8<span class="comment">/* doubleword size(bytes) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHUNKSIZE (1&lt;&lt;12) <span class="comment">/* initial heap size(bytes) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OVERHEAD 8  <span class="comment">/* overhead of header and footer(bytes) */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(x,y) ((x)&gt;(y) ? (x):(y))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Pack a size and allocated bit into a word */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PACK(size, alloc) ((size) | (alloc))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Read and write a word at address p */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET(p) (*(size_t *)(p))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUT(p, val) (*(size_t *)(p) = (val))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Read the size and allocated fields from address p */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_SIZE(p)  (GET(p) &amp; ~0x7) <span class="comment">//~0111 = 前面补1 1000 </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_ALLOC(p) (GET(p) &amp; 0x1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Given block ptr bp, compute address of its header and footer */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HDRP(bp) ((char*)(bp) - WSIZE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FTRP(bp) ((char*)(bp) + GET_SIZE(HDRP(bp)) - DSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Given block ptr bp, compute address of next and previous blocks */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NEXT_BLKP(bp) ((char*)(bp) + GET_SIZE(((char*)(bp)-WSIZE)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREV_BLKP(bp) ((char*)(bp) - GET_SIZE(((char*)(bp)-DSIZE)))</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在空闲链表中操作头部和脚部可能是很麻烦的，因为它要求大量使用强制类型转换和指针运算。因此，定义一个小的宏集合来访问和遍历空闲链表是很有帮助的。比如我们可以用如下代码确定下一个块的大小:</p><p>&emsp;&emsp;size_t size = GET_SIZE(HDRP(NEXT_BLKP(bp)));</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化空闲链表</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mm_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* create the initial empty heap */</span></span><br><span class="line">    <span class="keyword">if</span> ((heap_listp = mem_sbrk(<span class="number">4</span>*WSIZE)) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    PUT(heap_listp, <span class="number">0</span>);  <span class="comment">/* alignment padding */</span></span><br><span class="line">    PUT(heap_listp+WSIZE, PACK(OVERHEAD, <span class="number">1</span>)); <span class="comment">/* prologue header */</span></span><br><span class="line">    PUT(heap_listp+DSIZE, PACK(OVERHEAD, <span class="number">1</span>)); <span class="comment">/* prologue footer */</span></span><br><span class="line">    PUT(heap_listp+WSIZE+DSIZE, PACK(<span class="number">0</span>, <span class="number">1</span>));  <span class="comment">/* epilogue header */</span></span><br><span class="line">    heap_listp += DSIZE;<span class="comment">/* point to prologue block */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Extend the empty heap with a free block of CHUNKSIZE bytes */</span></span><br><span class="line">    <span class="keyword">if</span> (extend_heap(CHUNCKSIZE/WSIZE) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;mm_init函数从主存中得到4个字，并将它们初始化，从而创建一个空的空闲链表。然而它调用extend_heap函数(下面的代码块中展示)，这个函数将堆扩展CHUNKSIZE字节，并且创建初始空闲块。此刻分配器已初始化了，并且准备好接受来自应用的分配和释放请求。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">extend_heap</span><span class="params">(<span class="keyword">size_t</span> words)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* bp;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Allocate an even number of words to maintain alignment */</span></span><br><span class="line">    size = (words % <span class="number">2</span>) ? (words+<span class="number">1</span>)*WSIZE : words*WSIZE;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">int</span>)(bp = mem_sbrk(size)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Initialize free block header/footer and the epilogue header */</span></span><br><span class="line">    PUT(HDRP(bp), PACK(size, <span class="number">0</span>));<span class="comment">/* free block header */</span></span><br><span class="line">    PUT(FTRP(bp), PACK(size, <span class="number">0</span>));<span class="comment">/* free block footer */</span></span><br><span class="line">    PUT(HDRP(NEXT_BLKP(bp)), PACK(<span class="number">0</span>,<span class="number">1</span>)); <span class="comment">/* new epilogue header */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Coalesce if the previous block was free */</span></span><br><span class="line">    <span class="keyword">return</span> coalesce(bp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;extend_heap函数会在两种情况下被调用：①当堆被初始化时；②mm_malloc不能找到一个合适的匹配块时。为了保持对齐，extend_heap将请求大小向上取整为2字的倍数，然后向虚拟主存系统请求额外的堆空间。在很可能出现最后一个块是空闲块的情况下，我们调用coalesce函数来合并两个空闲块，并返回指向合并后的块的块指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//释放和合并块</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mm_free</span><span class="params">(<span class="keyword">void</span>* bp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> size = GET_SIZE(HDRP(bp));</span><br><span class="line">    </span><br><span class="line">    PUT(HDRP(bp), PACK(size,<span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(bp), PACK(size,<span class="number">0</span>));</span><br><span class="line">    coalesce(bp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">coalesce</span><span class="params">(<span class="keyword">void</span>* bp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> prev_alloc = GET_ALLOC(FTRP(PREV_BLKP(bp)));</span><br><span class="line">    <span class="keyword">size_t</span> next_alloc = GET_ALLOC(HDRP(NEXT_BKLP(bp)));</span><br><span class="line">    <span class="keyword">size_t</span> size = GET_SIZE(HDRP(bp));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (prev_alloc &amp;&amp; next_alloc)&#123;</span><br><span class="line">        <span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (prev_alloc &amp;&amp; !next_alloc)</span><br><span class="line">    &#123;</span><br><span class="line">        size += GET_SIZE(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">        PUT(HDRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(HDRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">return</span>(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!prev_alloc &amp;&amp; next_alloc)&#123;</span><br><span class="line">        size += GET_SIZE(HDRP(PREV_BLKP(bp)));</span><br><span class="line">        PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">return</span>(PREV_BLKP(bp));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        size += GET_SIZE(HDRP(PREV_BLKP(bp))) + GET_SIZE(FTRP(NEXT_BLKP(bp)));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(NEXT_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">return</span>(PREV_BLKP(bp));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们的空闲链表结构十分巧妙，它的序言块和结尾块总是标记为已分配，使得我们能够忽略麻烦的边界情况，也就是释放的块在堆的起始或结尾处。如果没有这些特殊的块，我们必须在每次释放块时，检查这些并不常见的边界情况，这将导致代码混乱，容易出错，执行更多指令。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分配块</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">mm_malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> asize;<span class="comment">/* adjusted block size */</span></span><br><span class="line">    <span class="keyword">size_t</span> extendsize;<span class="comment">/* amount to extend heap if no fit */</span></span><br><span class="line">    <span class="keyword">char</span>* bp;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Ignore spurious requests */</span></span><br><span class="line">    <span class="keyword">if</span> (size&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Adjust block size to include overhead and alignment reqs. */</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt;= DSIZE)</span><br><span class="line">        asize = DSIZE + OVERHAED;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        asize = DSIZE * ((size + (OVERHEAD) + (DSIZE<span class="number">-1</span>)) / DSIZE);</span><br><span class="line">    <span class="comment">/* Search the free list for a fit*/</span></span><br><span class="line">    <span class="keyword">if</span> ( (bp = find_fit(asize)) != <span class="literal">NULL</span> )&#123;</span><br><span class="line">        place(bp, asize);</span><br><span class="line">        <span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* No fit found. Get more memory and place the block */</span></span><br><span class="line">    extendsize = MAX(asize, CHUNKSIZE);</span><br><span class="line">    <span class="keyword">if</span> ( (bp = extend_heap(extendsize/WSIZE)) == <span class="literal">NULL</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    place(bp, asize);</span><br><span class="line">    <span class="keyword">return</span> bp;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;需要你为分配器实现一个find_fit函数，对隐式空闲链表执行首次适配搜索</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">find_fit</span><span class="params">(<span class="keyword">size_t</span> asize)</span></span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;需要你为分配器实现一个place函数，j将分配块放置在空闲块的起始位置，仅当剩余部分的大小大于等于最小块大小16字节时才分割(加块结构)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">place</span><span class="params">(<span class="keyword">void</span>* bp, <span class="keyword">size_t</span> asize)</span></span></span><br></pre></td></tr></table></figure><p><strong>10.9.13 显式空闲链表</strong></p><p>&emsp;&emsp;隐式空闲链表结构，因为块分配与堆块的综述呈线性关系，所以对通用的分配器，隐式空闲链表是不合适的(尽管对于堆块预先就知道是很小的特殊分配器来说，它是比较好的)。</p><p>&emsp;&emsp;一种更好的办法是将空闲块组织为某种形式的显示数据结构。因为程序不需要一个空闲块的主体，所以实现这个数据结构的指针可以存放在这些空闲块的主体里面。例如，可以使用一个双向空闲链表结构，在每个空闲块中，包含一个pred(前驱)和succ(后继)指针，如图10.50所示。</p><p><img src="/2021/11/08/malloc/image-20211112170857426.png" alt="image-20211112170857426"></p><p>&emsp;&emsp;使用双向链表，而不是隐式空闲链表，使首次适配的分配时间从块总数的线性时间，减少到了空闲块数量的线性时间。不过释放一个块的时间可以是线性的，也可以是常数的，这取决于我们在空闲链表中对块排序的策略。</p><p>&emsp;&emsp;一种方法是<strong>后进先出</strong>(LIFO)的顺序维护链表，将新释放的块放置在链表的开始处。使用LIFO的顺序和首次适配的放置策略，分配器会最先检查最近使用过的块。在这种情况下，释放一个块可以在常数时间内完成。如果使用了边界标记(当前块可以借助上一块的尾部找到上一块，是个隐式指针)，那么合并也可以在常数时间内完成。</p><p>&emsp;&emsp;另一种方法是按照<strong>地址顺序</strong>来维护链表，其中链表中每个块的地址都小于它的祖先的地址。在这种情况下，释放一个块需要线性时间的搜索，来定位合适的祖先。按照地址排序的首次适配比LIFO的首次适配有更高的存储器利用率，接近最佳适配的利用率。</p><p>&emsp;&emsp;一般而言，显示链表的缺点是空闲块必须足够大，以包含所有需要的指针，以及头部和可能的脚部。这就导致了更大的最小块大小，也潜在地提高了内部碎片的程度。</p><p><strong>10.9.14 分离的空闲链表</strong></p><p>&emsp;&emsp;就像我们已经看到的，一个使用单向空闲链表的分配器需要与空闲块数量成线性关系的时间来分配块。一种流行的减少分配时间的方法，通常称为<strong>分离存储</strong>(segregated storage)，维护多个空闲链表，其中每个链表中的块有大致相等的大小。</p><p>&emsp;&emsp;一般的思路是将所有可能的块大小分成几类(size class)。分配器维护着一个空闲链表数组，每类一个空闲链表数组，按照大小的升序排列。当分配器需要一个大小为n的块时，它就搜索相应的空闲链表。如果它不能找到相应大小的块与之匹配，它就搜索下一个链表，依次类推。</p><p>&emsp;&emsp;有关动态存储分配的文献描述了很多种分离存储方法，主要的区别在于它们如何划分类，何时进行合并，何时向操作系统请求额外的堆存储器，是否允许分隔，等等。为了使你大致了解有哪些可能性，我们会描述两种基本的方法：<strong>简单分离存储</strong>(simple segregated storage)和<strong>分离适配</strong>(segregated fit)。</p><p>&emsp;&emsp;<strong>简单分离存储</strong></p><p>&emsp;&emsp;使用简单分离存储，每个大小类的空闲链表包含大小相等的块。一个{17-32}大小块，其空闲链表全由32字节的块组成。</p><p>&emsp;&emsp;为了分配一个给定大小的块，我们检查相应的空闲链表。如果链表非空，我们就简单地分配其中第一块的全部。分空闲块是不会分割的。如果链表为空，分配器就向操作系统请求一个固定大小的额外主存组块(通常是页面大小的整数倍)，将这个组块(chunk)分成大小相等的块，并将这些块连接起来形成性的空闲链表。要释放一个块，分配器只要简单地将这个块插入到相应的空闲链表的前部。</p><p>&emsp;&emsp;这种方法有许多优点。分配和释放块都是很快的常数时间操作。而且，每个组块(chunk)中都是大小相等的块，不分割，不合并，这意味着每个块分配释放的开销很小。既然每个组块只有大小相同的块，那么一个已分配块的大小就可以从它的地址中推断出来。因为没有合并，所以已分配块的头部就不需要一个已分配/空闲标记。因此已分配块不需要头部，同时因为没有合并，它们也不需要脚部。因为分配和释放操作都是在空闲链表的起始处操作，所以链表只需要是单向的，而不用是双向的了。关键点在于，唯一在任何块中都需要的字段是每个空闲块中的一个字的succ指针，因此最小快大小就是一个字。</p><p>&emsp;&emsp;一个显著的缺点是，简单分离存储很容易造成内部和外部碎片。因为空闲块是不会被分隔的，所以可能会造成内部碎片。更糟的是，某些引用模式会引起极多的外部碎片，因为是不会合并空闲块的。</p><p>&emsp;&emsp;研究者提出了一种粗糙的合并形式来对付外部碎片问题。分配器记录操作系统返回的每个组块(chunk)中的空闲块的数量。无论何时，如果有一个组块完全由空闲块组成，那么分配器就从它的当前大小类中删除这个组块，使得它对其他大小类可用。</p><p>&emsp;&emsp;<strong>分离适配</strong></p><p>&emsp;&emsp;使用这种方法，分配器维护着一个空闲链表的数组。每个空闲链表适合一个大小类相关联的，每个链表包含大小不同的块，这些块的大小是大小类的元素。有许多不同的分离适配分配器，我们描述一个简单版本。</p><p>&emsp;&emsp;为了分配一个块，我们必须确定请求的大小类，并且对适当的空闲链表做首次适配，查找一个合适的块。如果我们找到了一个，那么我们(可选地)分割它，并将剩余的部分插入到适当的空闲链表中。如果我们找不到合适的块，那么我们就搜索下一个更大的大小类的空闲链表。如此重复，直到找到一个合适的块。如果没有空闲链表中有合适的块，那么我们就向操作系统请求额外的堆主存，从这个新的堆主存中分配出一块，将剩余的部分放置在最大的大小类中。要释放一个块，我们自行合并，并将结果放置到相应的空闲链表中。</p><p>&emsp;&emsp;分离适配方法是一种常见的选择，C标准库中提供GNU malloc包就是采用的这种方法，因为这种方法既快速，对主存的使用也很有效率。搜索时间减少了，因为搜索被限制在堆的某个部分，而不是整个堆。主存利用率得到了改善，因为有一个有趣的事实：对分离空闲链表的简单的首次适配搜索相当于对整个堆的最佳适配搜索。</p><p>&emsp;&emsp;<strong>伙伴系统</strong></p><p>&emsp;&emsp;伙伴系统(buddy system)是分离匹配的一种特例，其中每个大小类都是2的幂。基本的思路是假设一个堆的大小为2^m个字，我们为每个块大小2^k维护一个分离空闲链表，其中0≤k≤m。请求块大小向上取整为最接近的2的幂。最开始时，只有一个大小为2^m个字的空闲块。</p><p>&emsp;&emsp;为了分配一个大小为2^k的块，我们找到第一个可用的、大小为2^j的块，其中k≤j≤m。如果j=k，那么我们就找到了。否则，我们递归地二分这个块，直到j=k。当我们进行这样的分割时，每个剩下的半块(也叫作伙伴)，被放置在相应的空闲链表中。要释放一个大小为2^k的块，我们继续合并空闲的伙伴。当我们遇到一个已分配的伙伴时，我们就停止合并。</p><p>&emsp;&emsp;关于伙伴系统的一个关键事实是，给定地址和块大小，很容易计算出它的伙伴的地址。例如，一个块，大小为32字节，地址为：xxx…x00000，它的伙伴的地址为 xxx…x10000。换句话说，一个块的地址和它的伙伴只有一位不相同。</p><p>&emsp;&emsp;伙伴系统分配器的主要优点是它的快速搜索和快速合并。主要缺点是要求块大小为2的幂可能导致显著的内部碎片。因此，伙伴系统分配器不适合通用目的的工作负载。然而，对于某些与应用相关的工作负载，其中块大小预先知道是2的幂，伙伴系统分配器就很有吸引力了。</p></div></div><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>10.10 垃圾回收 To Do</span></div>    <div class="hide-content"><p>&emsp;&emsp;在诸如C malloc包这样的显式分配器中，应用通过调用malloc和free来分配和释放堆块。应用要负责释放所有不再需要的已分配块。</p><p>&emsp;&emsp;未能释放已分配的块是一种常见的编程错误。例如，考虑下面的C函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">garbage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span>*)Malloc(<span class="number">15213</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">/* array p is garbage at this point*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;因为程序不再需要p，所以在garbage返回前应该释放p。不幸的是，程序员忘了释放这个块。它在程序的生命周期内都保持为已分配状态，毫无必要地占用着本来可以用来满足后面分配请求的堆空间。</p><p>&emsp;&emsp;<strong>垃圾收集器</strong>(garbage collector)是一种动态存储分配器，它自动释放程序不再需要的已分配块。这些块被称之为垃圾(garbage)。自动回收堆主存的过程叫做<strong>垃圾收集</strong>(garbage collection)。在一个支持垃圾收集的系统中，应用显式分配堆块，但是从不显式地释放它们，取而代之的是，垃圾收集器定期识别垃圾块，并相应地调用free，将这些块放到空闲链表中。</p><p>&emsp;&emsp;垃圾收集器可以追溯到John McCarthy在20世纪60年代早期在MIT开发的Lisp系统。它是诸如Java、ML、Perl和Mathematica等现代语言系统的一个重要部分，而且它仍然是一个重要的研究领域。有关文献描述了大量的垃圾收集方法，其数量令人吃惊。我们的讨论局限于McCarthy独创的Mark&amp;Sweep(标记&amp;清除)算法，这个算法很有趣，因为它可以建立在已存在的malloc包的基础上，为C和C++程序提供垃圾收集。</p><p><strong>10.10.1 垃圾收集器的基本要素</strong></p><p>&emsp;&emsp;垃圾收集器将主存视为一张有向可达图(reachability graph)，其形式如图10.51所示。该图的结点被分成一组根节点(root node)和一组堆结点(heap node)。每个堆结点对应于堆中的一个已分配块。有向边p-&gt;q意味着块p中的某个位置指向块q中的某个位置。根节点对应于一种不在堆中的位置，它们中包含指向堆中的指针。这些位置可以是寄存器，栈里的变量，或者虚拟主存中读写数据区域内的全局变量。</p><p><img src="/2021/11/08/malloc/image-20211116130921856.png" alt="image-20211116130921856"></p><p>&emsp;&emsp;当存在一条从任意根节点出发并到达p的有向路径时，我们说一个结点p是可达的(reachable)。在任何时刻，和垃圾相对应的不可达节点是不能被应用再次使用的。</p><p>&emsp;&emsp;像ML和Java这样的语言的垃圾收集器，对应用如何创建和使用指针有很严格控制，能够维护可达图的一种精确的表示，因此也就能够回收所有垃圾。然而，诸如C和C++这样的语言的收集器通常不能维持可达图的精确表示。这样的收集器也叫作保守的<strong>垃圾收集器</strong>(conservative garbage)。每个可达块都被正确地标记为可达了，而一些不可达结点却可能被错误地标记为可达。</p><p>&emsp;&emsp;收集器可以按需要提供它们的服务，或者它们可以作为一个和应用并行的独立线程，不断地更新可达图和回收垃圾。例如，考虑我们如何为C程序将一个保守的收集器加入到已存在的malloc包中。</p><p><img src="/2021/11/08/malloc/image-20211118103829015.png" alt="image-20211118103829015"></p><p>&emsp;&emsp;无论何时应用需要堆空间时，它都会用通常的方式调用malloc。如果malloc找不到一个合适的空闲块，那么它就调用垃圾收集器，希望能够回收一些垃圾到空闲链表。收集器识别出垃圾块，并通过调用free函数将它们返回给堆。关键的想法是收集器代替应用去调用free。当对收集器的调用返回时，malloc重试，试图发现一个合适的空闲块。如果还是失败了，那么它就会向操作系统要求额外的存储器。最后，malloc返回一个指向请求块的指针(如果成功)或者返回一个空指针(如果不成功)。</p><p><strong>10.10.2 Mark&amp;Sweep垃圾收集器</strong></p><p>&emsp;&emsp;Mark&amp;Sweep垃圾收集器由标记(mark)阶段和清除(sweep)阶段组成。标记阶段标记出根节点的所有可达的和已分配的后继，而后面的清除阶段释放每个未被标记的已分配块。典型地，块头部中空闲的低位中的一位用来表示这个块是否被标记了。</p><p>&emsp;&emsp;我们对Mark&amp;Sweep的描述将假设使用下列函数，其中ptr定义为typedef char* ptr:</p><ul><li>ptr isPtr(ptr p)：如果p指向一个已分配块中的某个字，那么就返回一个指向这个块的起始位置的指针b。否则返回NULL。</li><li>int blockMarked(ptr b)：如果已经标记了块b，那么就返回true。</li><li>int blockAllocated(ptr b)：如果块b是已分配的，那么就返回true。</li><li>void markBlock(ptr b)：标记块b。</li><li>int length(b)：返回块b的字长(包括头部)。</li><li>void unmarkBlock(ptr b)：将块b的状态由已标记的改为未标记的。</li><li>ptr nextBlock(ptr b)：返回堆中块b的后继。</li></ul><p>&emsp;&emsp;标记阶段为每个根节点调用一次图10.53（a）所示的mark函数。如果p不指向一个已分配并且未标记的堆块，mark函数就立即返回。否则，它就标记这个块，并对块中的每个字递归地调用它自己。每次对mark函数的调用都标记某个根结点的所有未标记并且可达的后继结点。在标记阶段的末尾，任何未标记的已分配块都被认定为是不可达的，是垃圾，可以在清除阶段回收。</p><p>&emsp;&emsp;清除阶段是对图10.53（b）所示的sweep函数的一次调用。sweep函数在堆中每个块上反复循环，释放它锁遇到的所有未标记的已分配块(也就是垃圾)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//mark 和 sweep函数的伪代码</span><br><span class="line">void mark(ptr p) &#123;</span><br><span class="line">    if ((b = isPtr(p)) == NULL)</span><br><span class="line">        return;</span><br><span class="line">    if (blockMarked(b))</span><br><span class="line">        return;</span><br><span class="line">    markBlock(b);</span><br><span class="line">    for (i=0; i&lt;len; i++)</span><br><span class="line">        mark(b[i])</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void sweep(ptr b, ptr end)</span><br><span class="line">&#123;</span><br><span class="line">while (b&lt;end)&#123;</span><br><span class="line">if (blockMarked(b))</span><br><span class="line">unmarkBlock(b);</span><br><span class="line">else if (blockAllocated(b))</span><br><span class="line">free(b);</span><br><span class="line">b = nextBlock(b)</span><br><span class="line">&#125;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;图10.54展示了一个小堆的Mark&amp;Sweep的图形化解释。块边界用粗线条表示。每个方块对应于主存中的一个字。每个块有一个字的头部，要么是标记了的，要么是标记了的，要么是未标记的。</p><p><img src="/2021/11/08/malloc/image-20211118110445077.png" alt="image-20211118110445077"></p><p>&emsp;&emsp;初始情况下，图10.54中的堆由6个已分配块组成，其中每个块都是未分配的。第3块包含一个指向第1块的指针。第4块包含指向第3块和第6块的指针。根指向第4块。在标记阶段之后，第1块、第3块、第4块和第6块被做了标记，因为它们是从根节点可达的。第2块和第5块是未标记的，因为它们是不可达的。在清除阶段之后，这两个不可达块被回收到空闲链表。</p><p><strong>C程序的保守Mark&amp;Sweep</strong></p><p>&emsp;&emsp;Mark&amp;Sweep对C程序的垃圾收集是一种合适的方法，因为它可以就地工作，而不需要移动任何块。然而，C语言为isPtr函数的实现造成了一些有趣的挑战。</p><p>&emsp;&emsp;第一，C不会使用任何类型信息来标记主存位置。因此，对isPtr没有一种明显方式来判断它的输入参数p是不是一个指针。第二，即使我们知道p是一个指针，对isPtr也没有明显的方式来判断p是否指向一个已分配块的有效载荷中的某个位置。</p><p>&emsp;&emsp;对后一问题的解决方法是将已分配块集合维护成一棵平衡二叉树，这棵树保持着这样一个属性：左子树中的所有块都放在较小的地址出，而右子树中的所有块都放在较大的地址处。如图10.55所示，这就要求每个已分配块的头部里有两个附加字段(left和right)。每个字段指向某个已分配块的头部。</p><p><img src="/2021/11/08/malloc/image-20211118112352762.png" alt="image-20211118112352762"></p><p>&emsp;&emsp;isPtr(ptr p)函数用树来执行对已分配块的二分查找。在每一步中，它依赖于块头部中的大小字段来判断p是否落在这个块的范围内。</p><p>&emsp;&emsp;从某种意义上来说，平衡树方法是正确的，例如它保证会标记所有从根节点可达的结点。这是一个必要的保证，因为应用程序的用户当然不会喜欢把它们的已分配块过早地返回给空闲链表。然而，这种方法从某种意义上而言又是保守的，因为它可能不正确地标记实际上不可达的块。</p><p>&emsp;&emsp;C程序的Mark&amp;Sweep收集器必须是保守的，其根本原因是C语言不会用类型信息来标记主存位置。因此，像int或者float这样的标量可以伪装成指针。例如，假设某个可达的已分配块在它的有效载荷中包含一个int，其值恰巧对应于某个其他已分配块b的有效载荷中的一个地址。对收集器而言，是没有办法推断出这个数据实际上是int而不是指针。因此，分配器必须保守的将块b标记为可达，尽管事实上它可能是不可达的。</p></div></div><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>10.11 C程序中常见的与主存有关的错误</span></div>    <div class="hide-content"><p>&emsp;&emsp;对C程序员来说，管理和使用虚拟主存可能是个苦难的、容易出错的任务。</p><p><strong>10.11.1 间接引用坏指针</strong></p><p>&emsp;&emsp;正如我们在10.7.2节中学到的，在进程的虚拟地址空间中有较大的洞，没有映射到任何有意义的数据。如果我们试图间接引用一个指向这些洞的指针，那么操作系统就会以段异常终止我们的程序。而且，虚拟主存的某些区域是只读的。试图写这些区域将造成以保护异常终止这个程序。</p><p>&emsp;&emsp;间接引用坏指针的一个常见示例是经典的scanf错误。假设我们想要使用scanf从stdin读一个整数到一个变量。做这件事情正确地方式是传递给scanf一个格式串和变量的地址：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;val);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然而，对于C程序员初学者而言(对于有经验者也是如此！)，很容易传递val的内容，而不是地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, val);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这种情况下，scanf将把val的内容解释为一个地址，并试图讲一个字写到这个位置。在最好的情况下，程序立即以异常终止。在最糟糕的情况下，val的内容对应于虚拟主存的某个合法的读写区域，于是我们就覆盖了主存，这通常会在以后造成灾难性的、令人困惑的后果。</p><p><strong>10.11.2</strong></p><p>&emsp;&emsp;虽然.bss主存位置(诸如未初始化的全局C变量)总是被加载器初始化为0，但是对于堆主存却并不是这样的。一个常见的错误就是假设堆存储器被初始化为零。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* return y = Ax */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">matvec</span><span class="params">(<span class="keyword">int</span>** A, <span class="keyword">int</span>* x, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">int</span>* y = (<span class="keyword">int</span>*)Malloc(n * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            y[i] += A[i][j] * x[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这个示例中，程序员不正确地假设向量y被初始化为零。正确的实现方式是将y[i]设置为0，或者使用calloc。</p><p><strong>10.11.3 允许栈缓冲区溢出</strong></p><p>&emsp;&emsp;正如我们在3.13节中看到的，如果一个程序不检查输入串的大小就写入栈中的目标缓冲区，那么这个程序就会有缓冲区溢出错误(buffer overflow bug)。例如，下面的函数就有缓冲区错误，因为gets函数拷贝一个任意长度的串到缓冲区。为了纠正这个错误，我们必须使用fgets函数，这个函数限制了输入串的大小。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufoverflow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">64</span>];</span><br><span class="line">    </span><br><span class="line">    gets(buf); <span class="comment">/* here is the stack buffer overflow bug */</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>10.11.4 假设指针和它们指向的对象是相同大小的</strong></p><p>&emsp;&emsp;一种常见的错误是假设指向对象的指针和它们所指向的对象是相同大小的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Create an nxm array */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>** <span class="title">makeArray1</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span>** A = (<span class="keyword">int</span>**)Malloc(n * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        A[i] = (<span class="keyword">int</span>*)Malloc(m * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里的目的是创建一个由n个指针组成的数组，每个字镇都指向一个包含m个int的数组。然而，因为程序员将sizeof(int*)写成了sizeof(int)，代码实际创建的是一个int的数组。这段代码只有在int和指向int的指针大小相同的环境下运行良好。</p><p><strong>10.11.5 造成错位错误</strong></p><p>&emsp;&emsp;错位(Off-by-one)错误是另一种很常见的覆盖错误发生的原因。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Create an nxm array */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>** <span class="title">makeArray2</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span>** A = (<span class="keyword">int</span>**)Malloc(n * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;=n; i++)</span><br><span class="line">        A[i] = (<span class="keyword">int</span>*)Malloc(m*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>10.11.6 引用指针，而不是它所指的对象</strong></p><p>&emsp;&emsp;如果我们不太注意C操作符的优先级和结合性，我们就会错误地操作指针，而不是期望的操作指针所指向的对象。比如，考虑下面的函数，其目的是删除一个有*size项的二叉堆里的第一项，然后对剩下的size-1重建堆。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">binheapDelete</span><span class="params">(<span class="keyword">int</span>** binheap, <span class="keyword">int</span>* size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* packet = binheap[<span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line">    binheap[<span class="number">0</span>] = binheap[*size - <span class="number">1</span>];</span><br><span class="line">    *size--; <span class="comment">/* this should be (*size)-- */</span></span><br><span class="line">    heapify(binheap, *size, <span class="number">0</span>);</span><br><span class="line">    reuturn(packet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>—和*运算符优先级相同，从右向左结合。这里原则是如果你对优先级和结合性有疑问，就使用括号。</p><p><strong>10.11.7 误解指针运算</strong></p><p>&emsp;&emsp;另一种常见的错误是忘记了指针的算术操作是以它们指向的对象的大小为单位来进行的，而这种大小单位并不一定是字节。例如，下面函数的目的是扫描一个int的数组，并返回一个指针，指向val的首次出现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">search</span><span class="params">(<span class="keyword">int</span>* p, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (*p &amp;&amp; *p != val)</span><br><span class="line">        p += <span class="keyword">sizeof</span>(<span class="keyword">int</span>); <span class="comment">/*should be p++*/</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>10.11.8 引用不存在的变量</strong></p><p>&emsp;&emsp;没有太多经验的C程序员不理解栈的规则，有时会引用不再合法的本地变量，如下列所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">stackref</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &amp;val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个函数返回一个指针如p，指向栈里的一个局部变量，然后弹出它的栈帧。尽管p仍然指向一个合法的存储器地址，但是它已经不再指向一个合法的变量了。当以后在程序中调用其他函数时，存储器将重用它们的栈帧。后来，如果程序分配某个值给*p，那么它可能实际正在修改另一个函数中的栈帧中的一个条目，从而带来潜在地灾难性的、令人困惑的后果。</p><p><strong>10.11.9 应用空闲堆块中的数据</strong></p><p>&emsp;&emsp;一个相似的错误是应用已经被释放了的堆块中的数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">heapref</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> *x, *y;</span><br><span class="line">    </span><br><span class="line">    x = (<span class="keyword">int</span>*)Malloc(n * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="built_in">free</span>(x);</span><br><span class="line">    </span><br><span class="line">    y = (<span class="keyword">int</span>*)Malloc(m * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;m; i++)</span><br><span class="line">        y[i] = x[i]++; <span class="comment">/* oops!x[i] is a word in a free block */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>10.11.10 引起存储器泄漏</strong></p><p>&emsp;&emsp;存储器泄漏是缓慢、隐形的杀手，表示程序员忘记释放已分配块。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">leak</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* x = (<span class="keyword">int</span>*)Malloc(n * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">/* x is garbage at this point */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果leak经常被调用，那么渐渐地，堆里就会充满了垃圾，最糟糕的情况下，会占有整个虚拟地址空间。对于像守护进程和服务器这样的程序来说，存储器泄漏是特别严重的，这些程序是不会终止的。</p></div></div><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>10.12 扼要重述一些有关虚拟主存的关键概念 (咕咕咕!)</span></div>    <div class="hide-content"><p>&emsp;&emsp;在这一章里，我们已经看到了虚拟存储器是如何工作的，系统如何用它来实现某些功能，例如加载程序、映射共享库以及为进程提供私有受保护的地址空间。我们还看到了许多应用程序正确或者不正确地使用虚拟存储器的方式。</p><p>&emsp;&emsp;一个关键的经验教训是，即使虚拟存储器是由系统自动提供的，它也是一种有限的存储器资源，应用程序必须精明地管理它。征途我们从堆动态存储分配器的研究中学到的那样，管理虚拟存储器资源可能包括些微妙的时间和空间的平衡。另一个关键经验教训是，在C程序中很容易犯与存储器有关的错误。坏的指针值、释放已经空闲了的块、不恰当的强制类型转换和指针运算，以及覆盖堆结构，这些只是可能给我们带来麻烦的许多方式中的一小部分。实际上，与存储器有关的错误很讨厌，这是导致java产生的一个重要原因，java取消了取变量地址的能力，完全控制了动态存储分配器，从而严格控制了对虚拟存储器的访问。</p></div></div><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>10.13 小结</span></div>    <div class="hide-content"><p>&emsp;&emsp;虚拟存储器是对主存的一个抽象。支持虚拟存储器的处理器通过使用一种叫做虚拟寻址的间接形式来引用主存。处理器产生一个虚拟地址，在被发送到主存之前，这个地址被翻译成一个物理地址。从虚拟地址空间到物理地址空间的地址翻译要求硬件和软件紧密合作。专门的硬件通过使用页表来翻译虚拟地址，而页表的内容是由操作系统提供的。</p><p>&emsp;&emsp;虚拟存储器提供三个重要的功能。第一，它在主存中自动缓存最近使用的存放磁盘上的虚拟地址空间的内容。虚拟存储器缓存中的块叫做页。对磁盘上页的应用会触发缺页，缺页导致处理器执行一个缺页处理程序。缺页处理程序将页面从磁盘拷贝到主存缓存，如果必要，将写回被驱逐的页。第二，虚拟存储器简化了存储器的管理，进而又简化了链接、在进程间共享数据、进程的存储器分配，以及程序加载。最后，虚拟存储器通过在每条页表条目中加入保护位，从而简化了存储器保护。</p><p>&emsp;&emsp;地址翻译的过程必须和系统中任意硬件缓存的操作集成在一起。大多数页表条目位于L1高速缓存中，但是一个称为TLB的页表条目在芯片上的高速缓存，，通常会消除访问在L1上的页表条目的开销。</p><p>&emsp;&emsp;现代系统通过将虚拟存储器组块(chunk)和磁盘上的文件组块关联起来，来初始化虚拟存储器组块，这个过程称为存储器映射。存储器映射为共享数据、创建新的进程以及加载程序，提供了一种高效的机制。应用可以使用mmap函数来手工地创建和删除虚拟地址空间的区域。然而，大多数的程序依赖于动态存储分配器，例如malloc，它管理虚拟地址空间区域内一个称为堆的区域。动态存储分配器是一个有系统级感觉的应用级程序，它直接操作存储器，而无需类型系统的很多帮助。分配器有两种类型：显式分配器要求应用显示地释放它们的存储器块；隐式分配器(垃圾收集器)自动释放任何无用的和不可达的块。</p><p><a href="http://csapp.cs.cmu.edu/3e/labs.html">CS:APP3e, Bryant and O’Hallaron (cmu.edu)</a>上可以下载每个实验。</p><p><img src="/2021/11/08/malloc/image-20211118134709857.png" alt="image-20211118134709857"></p><p>注意左边的链接需要讲师认证才能下载(含答案)，右边单个的链接挨个点击下载。(不含答案)</p></div></div><h1 id="简单版本"><a href="#简单版本" class="headerlink" title="简单版本"></a>简单版本</h1><p>隐式空闲链表结构，mmap分配组块(chunk)，首次适配策略放置块，分割，边界标记便于合并。</p><p>简单起见，不对地址参数的正确性做检查</p><p>画图工具为google浏览器插件 Gliffy Diagrams。</p><h2 id="mmap和munmap"><a href="#mmap和munmap" class="headerlink" title="mmap和munmap"></a>mmap和munmap</h2><p>就是简单包裹了一下系统调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;syscall.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stddef.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">void</span>* paddr = (<span class="keyword">void</span> *)SYSCALL6(<span class="number">9</span>, addr, length, prot, flags, fd, offset);</span><br><span class="line">    <span class="keyword">return</span> paddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = (<span class="keyword">int</span>)SYSCALL2(<span class="number">11</span>, addr, length);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常量和宏"><a href="#常量和宏" class="headerlink" title="常量和宏"></a>常量和宏</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALIGN_UP_N_BYTES(size, n) ((((size) + (n) - 1) / (n)) * (n))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALIGN_UP_8_BYTES(size) ALIGN_UP_N_BYTES(size, 8)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALIGN_UP_4KB(size) ALIGN_UP_N_BYTES(size, 4096)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THRESHOLD_FOR_MMAP (256 * 1024)<span class="comment">//max block size in segment</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEGMENT_SIZE (2 * 1024 * 1024) </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEM_BLOCK_MINIMUM 16</span></span><br></pre></td></tr></table></figure><h2 id="Segment和块结构"><a href="#Segment和块结构" class="headerlink" title="Segment和块结构"></a>Segment和块结构</h2><p><strong>Segment结构</strong></p><p>Segment是通过mmap函数请求的区域。后面将只放一个大块的区域称为区域，将用来再分配给多个块的区域称为Segment。对每个请求到的Segment，添加16字节的Segment头部(前驱和后继指针)，用来放一个大块的区域，直接放一个块头部。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SLMemSegment</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SLMemSegment</span> *<span class="title">pPrevMemSegment</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SLMemSegment</span> *<span class="title">pNextMemSegment</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>经过测试，输出的结构大小为16字节，意味着一个指针变量的大小默认为8字节。</p><p><img src="/2021/11/08/malloc/image-20211113121707861.png" alt="image-20211113121707861"></p><p>Segment结构示意图：</p><p><img src="/2021/11/08/malloc/image-20211113140403399.png" alt="image-20211113140403399"></p><p><strong>块结构</strong></p><p>关于C的struct的位域，使用如下代码测试。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span>&#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> a : <span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> b : <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span> <span class="title">t</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span>* <span class="title">p</span> =</span> &amp;t;</span><br><span class="line">p-&gt;a = <span class="number">1</span>;</span><br><span class="line">p-&gt;b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gdb查看内存发现，先申请的在低位，后申请的在高位。且注意使用unsigned无符号数，不然1位的a为1时，会显示成负数。</p><p><img src="/2021/11/08/malloc/image-20211112230237761.png" alt="image-20211112230237761"></p><p>块头部大小为8个字节即64位，由于块是8字节对齐的，所以块大小的最低3位始终为0，只需要高61位表示块大小。第0位CurBlkInUseBit表示该块是否是空闲块，第1位PrevBlkInUseBit表示该块的上一块是否在使用，第3位FromMmapBit表示该块的虚拟主存空间是否字节通过mmap分配。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SLMemBlock</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> CurBlkInUseBit : <span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> PrevBlkInUseBit : <span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> FromMmapBit : <span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> ulBlockSize : <span class="number">61</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>块结构示意图：仅当该块为空闲块时，才写上脚部。由于其头部脚部皆为8字节，所以一个最小块大小为16字节。</p><p><img src="/2021/11/08/malloc/image-20211113152023237.png" alt="image-20211113152023237"></p><h2 id="分配原理"><a href="#分配原理" class="headerlink" title="分配原理"></a>分配原理</h2><p>MyMalloc函数。首先请求的size加上头部，再对size做对齐。超过256KB的请求，通过mmap分配区域，否则，从已分配的Segment中分配空间给块。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">MyMalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">size = ALIGN_UP_8_BYTES(size);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(size &lt; MEM_BLOCK_MINIMUM)</span><br><span class="line">size = MEM_BLOCK_MINIMUM;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">size += <span class="keyword">sizeof</span>(struct SLMemBlock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(size &gt;= THRESHOLD_FOR_MMAP)</span><br><span class="line"><span class="keyword">return</span> MallocBymmap(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> MallocBySegmentList(size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MallocBymmap函数。首先对加过头部的size进行4KB的对齐，通过mmap分配区域，让内核创建一个包含size字节的、请求二进制零的虚拟主存区域。如果调用成功，addr指代新区域的地址。将块头部写入区域的开始位置，返回主体的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">MallocBymmap</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line">&#123;</span><br><span class="line">size = ALIGN_UP_4KB(size);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *addr = mmap(<span class="literal">NULL</span>, size, PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(addr == MAP_FAILED)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SLMemBlock</span> *<span class="title">p</span> =</span> (struct SLMemBlock *)addr;</span><br><span class="line"></span><br><span class="line">p-&gt;CurBlkInUseBit = <span class="number">1</span>;</span><br><span class="line">p-&gt;PrevBlkInUseBit = <span class="number">1</span>;</span><br><span class="line">p-&gt;FromMmapBit = <span class="number">1</span>;</span><br><span class="line">p-&gt;ulBlockSize = size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">char</span> *)addr + <span class="keyword">sizeof</span>(struct SLMemBlock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MallocBySegmentList函数。遍历所有Segment，寻找合适的空闲块，找到返回块的主体地址。如果还没有Segment，或者找不到合适的空闲块，则获取新的Segment，在新的Segment中找到一个空闲块。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">MallocBySegmentList</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(struct SLMemSegment *pSegment = g_pSegmentList; pSegment != <span class="literal">NULL</span>; pSegment = pSegment-&gt;pNextMemSegment)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">void</span>* addr = GetFreeMemBlockFromSegment(pSegment, size);</span><br><span class="line"><span class="keyword">if</span>(addr != <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(GetAndInsertSegment() == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> GetFreeMemBlockFromSegment(g_pSegmentList, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GetAndInsertSegment函数。使用mmap函数请求一块大小为2MB的区域。将其起始位置的16字节设置为Segment头部，通过头部的前驱后继指针，将该Segment放入Segment链表的起始位置。再将8字节的块头部放入剩下部分的起始位置。由于该块目前是空闲的，将主体的最后8字节设置为脚部，包含块的大小。这里使用了强制类型转换使指针加减1对应的字节数不同，以此定位到脚部位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetAndInsertSegment</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">void</span> *addr = mmap(<span class="literal">NULL</span>, SEGMENT_SIZE, PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(addr == MAP_FAILED)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SLMemSegment</span> *<span class="title">pSegment</span> =</span> (struct SLMemSegment *)addr;</span><br><span class="line"></span><br><span class="line">pSegment-&gt;pNextMemSegment = g_pSegmentList;</span><br><span class="line">pSegment-&gt;pPrevMemSegment = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(g_pSegmentList != <span class="literal">NULL</span>)</span><br><span class="line">g_pSegmentList-&gt;pPrevMemSegment = pSegment;</span><br><span class="line"></span><br><span class="line">g_pSegmentList = pSegment;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SLMemBlock</span> *<span class="title">pFirstBlock</span> =</span> (struct SLMemBlock *)((<span class="keyword">char</span> *)addr + <span class="keyword">sizeof</span>(struct SLMemSegment));</span><br><span class="line"></span><br><span class="line">pFirstBlock-&gt;CurBlkInUseBit = <span class="number">0</span>;</span><br><span class="line">pFirstBlock-&gt;PrevBlkInUseBit = <span class="number">1</span>;</span><br><span class="line">pFirstBlock-&gt;FromMmapBit = <span class="number">0</span>;</span><br><span class="line">pFirstBlock-&gt;ulBlockSize = SEGMENT_SIZE - <span class="keyword">sizeof</span>(struct SLMemSegment);</span><br><span class="line"></span><br><span class="line">*((<span class="keyword">unsigned</span> <span class="keyword">long</span> *)((<span class="keyword">char</span> *)pFirstBlock + pFirstBlock-&gt;ulBlockSize) - <span class="number">1</span>) = pFirstBlock-&gt;ulBlockSize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GetFreeMemBlockFromSegment函数，从Segment中获取空闲块。输入为一个Segment地址和请求的块大小。遍历所有Segmetn中的所有块，找到当前未使用的(空闲)，满足请求大小的块。如果分割空闲块后的剩余部分比最小块大小要小，就不分割，更新下一块(如果有)的PrevBlkInUseBit位。如果可以分割，写新块的头部和脚部。更新空闲块的大小，返回找到空闲块的主体地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">GetFreeMemBlockFromSegment</span><span class="params">(struct SLMemSegment *pSegment, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SLMemBlock</span> *<span class="title">pBlock</span> =</span> (struct SLMemBlock *)((<span class="keyword">char</span> *)pSegment + <span class="keyword">sizeof</span>(struct SLMemSegment));</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SLMemBlock</span> *<span class="title">pEndBlock</span> =</span> (struct SLMemBlock *)((<span class="keyword">char</span> *)pSegment + SEGMENT_SIZE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(; pBlock &lt; pEndBlock; pBlock = (struct SLMemBlock *)((<span class="keyword">char</span> *)pBlock + pBlock-&gt;ulBlockSize))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(pBlock-&gt;CurBlkInUseBit == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pBlock-&gt;ulBlockSize &lt; size)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pBlock-&gt;ulBlockSize - size &lt; MEM_BLOCK_MINIMUM)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SLMemBlock</span> *<span class="title">pNextBlock</span> =</span> (struct SLMemBlock *)((<span class="keyword">char</span> *)pBlock + pBlock-&gt;ulBlockSize);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pNextBlock &lt; pEndBlock)</span><br><span class="line">pNextBlock-&gt;PrevBlkInUseBit = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">struct SLMemBlock *pNextBlock = (struct SLMemBlock *)((<span class="keyword">char</span> *)pBlock + size);</span><br><span class="line"></span><br><span class="line">pNextBlock-&gt;CurBlkInUseBit = <span class="number">0</span>;</span><br><span class="line">pNextBlock-&gt;PrevBlkInUseBit = <span class="number">1</span>;</span><br><span class="line">pNextBlock-&gt;FromMmapBit = <span class="number">0</span>;</span><br><span class="line">pNextBlock-&gt;ulBlockSize = pBlock-&gt;ulBlockSize - size;</span><br><span class="line"></span><br><span class="line">*((<span class="keyword">unsigned</span> <span class="keyword">long</span> *)((<span class="keyword">char</span> *)pNextBlock + pNextBlock-&gt;ulBlockSize) - <span class="number">1</span>) = pNextBlock-&gt;ulBlockSize;</span><br><span class="line"></span><br><span class="line">pBlock-&gt;ulBlockSize = size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pBlock-&gt;CurBlkInUseBit = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">char</span> *)pBlock + <span class="keyword">sizeof</span>(struct SLMemBlock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IsTheLastBlockInSegment函数，判断某块是否是某Segment的最后一个块。输入为某块地址。遍历段，如果该块地址大于Segment地址且该块下一字节的地址小于Segment下一字节的地址，说明该块不是最后一块，返回0。如果该块的下一字节地址，和某Segment下一字节的地址相同则为最后一块，返回1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsTheLastBlockInSegment</span><span class="params">(struct SLMemBlock *pBlock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *pEnd = (<span class="keyword">char</span> *)pBlock + pBlock-&gt;ulBlockSize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(struct SLMemSegment *pSegment = g_pSegmentList; pSegment != <span class="literal">NULL</span>; pSegment = pSegment-&gt;pNextMemSegment)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">char</span> *pSegmentEnd = (<span class="keyword">char</span> *)pSegment + SEGMENT_SIZE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(((<span class="keyword">char</span> *)pBlock &gt; (<span class="keyword">char</span> *)pSegment) &amp;&amp; (pEnd &lt; pSegmentEnd))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pEnd == pSegmentEnd)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="释放原理"><a href="#释放原理" class="headerlink" title="释放原理"></a>释放原理</h2><p>MyFree函数。输入一个块的主体地址。检查块头部，如果是mmap分配的区域，调用unmap释放区域。检查该块是否是最后一块。如果不是最后一块，如果下一块也空闲，记录新的块大小加上下一块大小。如果上一块也空闲，记录新的块大小加上上一块大小，同时更新型的块地址为上一块地址，更新新块的头部和脚部。如果新块不是Segment的最后一块，更新下一块头部的PrevBlkInUseBit=0。如果新块是最后一块，且块大小和去了Segment头部的Segment一样大，说明Segment为空，调用FreeSegment函数释放Segment。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyFree</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(ptr == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SLMemBlock</span> *<span class="title">pBlock</span> =</span> (struct SLMemBlock *)((<span class="keyword">char</span> *)ptr - <span class="keyword">sizeof</span>(struct SLMemBlock));</span><br><span class="line"><span class="keyword">if</span>(pBlock-&gt;FromMmapBit == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">munmap((<span class="keyword">void</span>*)pBlock, pBlock-&gt;ulBlockSize);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> len = pBlock-&gt;ulBlockSize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> bLast = IsTheLastBlockInSegment(pBlock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!bLast)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SLMemBlock</span> *<span class="title">pNextBlock</span> =</span> (struct SLMemBlock *)((<span class="keyword">char</span> *)pBlock + len);</span><br><span class="line"><span class="keyword">if</span>(pNextBlock-&gt;CurBlkInUseBit == <span class="number">0</span>)</span><br><span class="line">len += pNextBlock-&gt;ulBlockSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pBlock-&gt;PrevBlkInUseBit == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> prev_size = *((<span class="keyword">unsigned</span> <span class="keyword">long</span> *)pBlock - <span class="number">1</span>);</span><br><span class="line">len += prev_size;</span><br><span class="line"></span><br><span class="line">pBlock = (struct SLMemBlock *)((<span class="keyword">char</span> *)pBlock - prev_size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pBlock-&gt;ulBlockSize = len;</span><br><span class="line">pBlock-&gt;CurBlkInUseBit = <span class="number">0</span>;</span><br><span class="line">pBlock-&gt;PrevBlkInUseBit = <span class="number">1</span>;</span><br><span class="line">pBlock-&gt;FromMmapBit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">bLast = IsTheLastBlockInSegment(pBlock);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SLMemBlock</span> *<span class="title">pNextBlock</span> =</span> (struct SLMemBlock *)((<span class="keyword">char</span> *)pBlock + pBlock-&gt;ulBlockSize);</span><br><span class="line">*((<span class="keyword">unsigned</span> <span class="keyword">long</span> *)pNextBlock - <span class="number">1</span>) = pBlock-&gt;ulBlockSize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!bLast)</span><br><span class="line">&#123;</span><br><span class="line">pNextBlock-&gt;PrevBlkInUseBit = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(pBlock-&gt;ulBlockSize == SEGMENT_SIZE - <span class="keyword">sizeof</span>(struct SLMemSegment))</span><br><span class="line">FreeSegment((struct SLMemSegment *)((<span class="keyword">char</span> *)pBlock - <span class="keyword">sizeof</span>(struct SLMemSegment)));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FreeSegment函数，释放Segment。输入参数为Segment地址。如果该Segment在Segment链表初始位置，更新g_pSegmentList指向下一个Segment，如果下一个Segment存在，修改其前驱为NULL。否则修改其前驱的后继为其后继，如果其后继存在，修改其后继的前驱为其前驱。调用munmap释放Segment所占的区域。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FreeSegment</span><span class="params">(struct SLMemSegment *pSegment)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(g_pSegmentList == pSegment)</span><br><span class="line">&#123;</span><br><span class="line">g_pSegmentList = pSegment-&gt;pNextMemSegment;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(g_pSegmentList != <span class="literal">NULL</span>)</span><br><span class="line">g_pSegmentList-&gt;pPrevMemSegment = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">pSegment-&gt;pPrevMemSegment-&gt;pNextMemSegment = pSegment-&gt;pNextMemSegment;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pSegment-&gt;pNextMemSegment != <span class="literal">NULL</span>)</span><br><span class="line">pSegment-&gt;pNextMemSegment-&gt;pPrevMemSegment = pSegment-&gt;pPrevMemSegment;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">munmap((<span class="keyword">void</span>*)pSegment, SEGMENT_SIZE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="某一时间点分配器分配的虚拟主存快照"><a href="#某一时间点分配器分配的虚拟主存快照" class="headerlink" title="某一时间点分配器分配的虚拟主存快照"></a>某一时间点分配器分配的虚拟主存快照</h2><p>实际上，Segment中的块要更多，因为块大小超过256KB就会直接mmap申请一个4KB对齐的区域，而一个Segment的大小是2M。</p><p><img src="/2021/11/08/malloc/image-20211114013556567.png" alt="image-20211114013556567"></p><h2 id="效率分析"><a href="#效率分析" class="headerlink" title="效率分析"></a>效率分析</h2><p>直接由mmap分配的块，其分配和释放完全独立。</p><p>从Segment中分配的块：</p><p>吞吐率：搜索空闲块的开销与Segment和所有块的数目线性相关。释放块时需要确认块是否为Segment中最后一块，开销与Segment数目线性相关。</p><p>主存利用率：由于是8字节对齐，分配空闲块时进行分隔，内部碎片不多。由于使用首次适配策略放置空闲块，外部碎片要看请求序列是什么样，可能会有比较多的小空闲块不能被分配。</p><h1 id="显式空闲链表，加快分配"><a href="#显式空闲链表，加快分配" class="headerlink" title="显式空闲链表，加快分配"></a>显式空闲链表，加快分配</h1><h2 id="双向空闲链表"><a href="#双向空闲链表" class="headerlink" title="双向空闲链表"></a>双向空闲链表</h2><h3 id="总体设计"><a href="#总体设计" class="headerlink" title="总体设计"></a>总体设计</h3><p>新增一个全局指针变量g_pFreeBlockList，指向空闲块链表。</p><p>在空闲块的主体里增加先驱和后继的指针。以便空闲块能找到空闲链表中的前驱和后继，在合并时好修改空闲链表。</p><p>将新释放的空闲块放到链表最前面。</p><p>分配时，首次适配策略放置块，分割，更新空闲链表。</p><p>释放时，尝试合并虚拟主存地址相邻的块，合并后更新空闲链表。</p><h2 id="效率分析-1"><a href="#效率分析-1" class="headerlink" title="效率分析"></a>效率分析</h2><p>直接由mmap分配的块，其分配和释放完全独立。</p><p>从Segment中分配的块：</p><p>吞吐率：搜索空闲块的开销最糟与空闲块数目线性相关，吞吐率有了提高。释放块时需要确认块是否为Segment中最后一块，开销与Segment数目线性相关。修改空闲链表的开销为常数时间。</p><p>主存利用率：因为块多了两个指针变量，所以最小块大小变大，由于使用了优化的边界标记，所以仅当请求的块大小很小时，内部碎片才变多。仍然使用首次适配策略放置空闲块，外部碎片要看请求序列是什么样，可能会有比较多的小空闲块不能被分配。</p><h3 id="详细设计与实现"><a href="#详细设计与实现" class="headerlink" title="详细设计与实现"></a>详细设计与实现</h3><h4 id="Segment结构"><a href="#Segment结构" class="headerlink" title="Segment结构"></a>Segment结构</h4><p>不变</p><h4 id="块结构"><a href="#块结构" class="headerlink" title="块结构"></a>块结构</h4><p>头部并没有变。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SLMemBlock</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> CurBlkInUseBit : <span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> PrevBlkInUseBit : <span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> FromMmapBit : <span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> ulBlockSize : <span class="number">61</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>变的是仅当块空闲时，写在主体中的脚部。脚部也作为链表的组成单位。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SLFreeBlock</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SLFreeBlock</span>* <span class="title">pPrevFreeBlock</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SLFreeBlock</span>* <span class="title">pNextFreeBlock</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> ulBlockSize;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>块结构示意图：</p><p>仅当块空闲时，写脚部。脚部现在包含空闲块前驱指针，空闲块后继指针，空闲块大小。现在一个块的大小最小为32字节。</p><p><img src="/2021/11/08/malloc/image-20211113165715918.png" alt="image-20211113165715918"></p><h4 id="常量和宏-1"><a href="#常量和宏-1" class="headerlink" title="常量和宏"></a>常量和宏</h4><p>最小块的大小从16字节变为32字节。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALIGN_UP_N_BYTES(size, n) ((((size) + (n) - 1) / (n)) * (n))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALIGN_UP_8_BYTES(size) ALIGN_UP_N_BYTES(size, 8)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALIGN_UP_4KB(size) ALIGN_UP_N_BYTES(size, 4096)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THRESHOLD_FOR_MMAP (256 * 1024)<span class="comment">//max block size in segment</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEGMENT_SIZE (2 * 1024 * 1024) </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEM_BLOCK_MINIMUM 32<span class="comment">//it used to be 16, now its 32</span></span></span><br></pre></td></tr></table></figure><h4 id="分配原理-1"><a href="#分配原理-1" class="headerlink" title="分配原理"></a>分配原理</h4><p>MyMalloc函数。首先8字节对齐size，再给size加上头部大小。如果size小于最小块大小32字节，size就为32字节。如果size大于等于32字节，且size大于等于256KB，调用MallocBymmap单独分配一个区域放置该块，该块的分配和释放是完全独立的。否则，调用MallocBySegmentList函数从Segment中分配一个块。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">MyMalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">size = ALIGN_UP_8_BYTES(size);</span><br><span class="line">    size += <span class="keyword">sizeof</span>(struct SLMemBlock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(size &lt; MEM_BLOCK_MINIMUM)</span><br><span class="line">size = MEM_BLOCK_MINIMUM;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(size &gt;= THRESHOLD_FOR_MMAP)</span><br><span class="line"><span class="keyword">return</span> MallocBymmap(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> MallocByFreeBlockList(size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MallocBymmap不变。</p><p>MallocBySegmentList函数，改为MallocByFreeBlock函数，调用GetFreeBlockFromFreeBlockList搜索空闲链表，寻找第一个合适的空闲块，找到返回块的主体地址，取缔了GetFreeMemBlockFromSegment。如果还没有空闲块，或者找不到合适的空闲块，则获取新的Segment，更新空闲链表，再次搜索空闲链表，第一个就是合适的空闲块。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">MallocByFreeBlockList</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* addr = GetFreeBlockFromFreeBlockList(size);</span><br><span class="line">    <span class="keyword">if</span>(addr != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> addr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(GetAndInsertSegment() == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> GetFreeBlockFromFreeBlockList(size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GetAndInsertSegment函数。使用mmap函数请求一块大小为2MB的区域。将其起始位置的16字节设置为Segment头部，通过头部的前驱后继指针，将该Segment放入Segment链表的起始位置。再将8字节的块头部放入剩下部分的起始位置。将作为空闲链表组成单元的脚部放入区域的最后24字节。将脚部放入FreeBlock链表的起始位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetAndInsertSegment</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">void</span> *addr = mmap(<span class="literal">NULL</span>, SEGMENT_SIZE, PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(addr == MAP_FAILED)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SLMemSegment</span> *<span class="title">pSegment</span> =</span> (struct SLMemSegment *)addr;</span><br><span class="line"></span><br><span class="line">pSegment-&gt;pNextMemSegment = g_pSegmentList;</span><br><span class="line">pSegment-&gt;pPrevMemSegment = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(g_pSegmentList != <span class="literal">NULL</span>)</span><br><span class="line">g_pSegmentList-&gt;pPrevMemSegment = pSegment;</span><br><span class="line"></span><br><span class="line">g_pSegmentList = pSegment;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SLMemBlock</span> *<span class="title">pFirstBlock</span> =</span> (struct SLMemBlock *)((<span class="keyword">char</span> *)addr + <span class="keyword">sizeof</span>(struct SLMemSegment));</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SLFreeBlock</span> *<span class="title">pFirstFreeBlock</span> =</span> (struct SLFreeBlock *)((<span class="keyword">unsigned</span> <span class="keyword">long</span>*)((<span class="keyword">char</span>*)addr + SEGMENT_SIZE)<span class="number">-3</span>);</span><br><span class="line">    </span><br><span class="line">pFirstBlock-&gt;CurBlkInUseBit = <span class="number">0</span>;</span><br><span class="line">pFirstBlock-&gt;PrevBlkInUseBit = <span class="number">1</span>;</span><br><span class="line">pFirstBlock-&gt;FromMmapBit = <span class="number">0</span>;</span><br><span class="line">pFirstBlock-&gt;ulBlockSize = SEGMENT_SIZE - <span class="keyword">sizeof</span>(struct SLMemSegment);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pFirstFreeBlock-&gt;ulBlockSize = pFirstBlock-&gt;ulBlockSize;</span><br><span class="line">    pFirstFreeBlock-&gt;pPrevFreeBlock = <span class="literal">NULL</span>;</span><br><span class="line">    pFirstFreeBlock-&gt;pNextFreeBlock = g_pFreeBlockList;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(g_pFreeBlockList != <span class="literal">NULL</span>)</span><br><span class="line">g_pFreeBlockList-&gt;pPrevFreeBlock = pFirstFreeBlock;</span><br><span class="line">    </span><br><span class="line">    g_pFreeBlockList = pFirstFreeBlock;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GetFreeMemBlockFromSegment函数，改为GetFreeMemBlockFromFreeBlockList。遍历空闲块链表，找到当前未使用的(空闲)，满足请求大小的块。如果分割空闲块后的剩余部分比最小块大小要小，就不分割，更新空闲链表，如果有，更新下一块的PrevBlkInUseBit位。如果可以分割，写新块的头部和脚部，更新空闲链表。更新空闲块的大小，返回找到空闲块的主体地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">GetFreeBlockFromFreeBlockList</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SLFreeBlock</span>* <span class="title">pFreeBlock</span> =</span> g_pFreeBlockList;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span>(; <span class="literal">NULL</span> != pFreeBlock; pFreeBlock = pFreeBlock-&gt;pNextFreeBlock)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pFreeBlock-&gt;ulBlockSize &lt; size)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">     </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">SLMemBlock</span>* <span class="title">pBlock</span> =</span> (struct SLMemBlock*)( (<span class="keyword">unsigned</span> <span class="keyword">long</span>*)( (<span class="keyword">char</span>*)(pFreeBlock) - pFreeBlock-&gt;ulBlockSize ) + <span class="number">3</span> );</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//nocut</span></span><br><span class="line">        <span class="keyword">if</span>(pFreeBlock-&gt;ulBlockSize - size &lt; MEM_BLOCK_MINIMUM)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//Delete pFreeBlock from FreeBlockList</span></span><br><span class="line">            <span class="keyword">if</span>(g_pFreeBlockList == pFreeBlock)</span><br><span class="line">            &#123;</span><br><span class="line">                g_pFreeBlockList = pFreeBlock-&gt;pNextFreeBlock;</span><br><span class="line">                <span class="keyword">if</span>(g_pFreeBlockList != <span class="literal">NULL</span>)</span><br><span class="line">                g_pFreeBlockList-&gt;pPrevFreeBlock = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pFreeBlock-&gt;pPrevFreeBlock-&gt;pNextFreeBlock = pFreeBlock-&gt;pNextFreeBlock;</span><br><span class="line">                <span class="keyword">if</span>(pFreeBlock-&gt;pNextFreeBlock != <span class="literal">NULL</span>)</span><br><span class="line">            pFreeBlock-&gt;pNextFreeBlock-&gt;pPrevFreeBlock = pFreeBlock-&gt;pPrevFreeBlock;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">SLMemBlock</span>* <span class="title">pNextBlock</span> =</span> (struct SLMemBlock *)( (<span class="keyword">char</span>*)pFreeBlock + <span class="keyword">sizeof</span>(struct SLFreeBlock) );  </span><br><span class="line">            <span class="keyword">int</span> bLast = IsTheLastBlockInSegment(pBlock);</span><br><span class="line">            <span class="keyword">if</span>(!bLast)</span><br><span class="line">pNextBlock-&gt;PrevBlkInUseBit = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cut</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//add new header</span></span><br><span class="line">            struct SLMemBlock* pNextBlock = (struct SLMemBlock *)( (<span class="keyword">char</span>*)pBlock + size );</span><br><span class="line">pNextBlock-&gt;CurBlkInUseBit = <span class="number">0</span>;</span><br><span class="line">pNextBlock-&gt;PrevBlkInUseBit = <span class="number">1</span>;</span><br><span class="line">pNextBlock-&gt;FromMmapBit = <span class="number">0</span>;</span><br><span class="line">pNextBlock-&gt;ulBlockSize = pBlock-&gt;ulBlockSize - size;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//add new footer</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">SLFreeBlock</span>* <span class="title">pNextFreeBlock</span> =</span> (struct SLFreeBlock*)((<span class="keyword">unsigned</span> <span class="keyword">long</span>*)((<span class="keyword">char</span>*)pNextBlock + pNextBlock-&gt;ulBlockSize) - <span class="number">3</span>);</span><br><span class="line">pNextFreeBlock-&gt;ulBlockSize = pNextBlock-&gt;ulBlockSize;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//Delete pFreeBlock from FreeBlockList</span></span><br><span class="line">            <span class="keyword">if</span>(g_pFreeBlockList == pFreeBlock)</span><br><span class="line">            &#123;</span><br><span class="line">                g_pFreeBlockList = pFreeBlock-&gt;pNextFreeBlock;</span><br><span class="line">                <span class="keyword">if</span>(g_pFreeBlockList != <span class="literal">NULL</span>)</span><br><span class="line">                g_pFreeBlockList-&gt;pPrevFreeBlock = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pFreeBlock-&gt;pPrevFreeBlock-&gt;pNextFreeBlock = pFreeBlock-&gt;pNextFreeBlock;</span><br><span class="line">                <span class="keyword">if</span>(pFreeBlock-&gt;pNextFreeBlock != <span class="literal">NULL</span>)</span><br><span class="line">            pFreeBlock-&gt;pNextFreeBlock-&gt;pPrevFreeBlock = pFreeBlock-&gt;pPrevFreeBlock;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//add pNextFreeBlock to FreeBlockList</span></span><br><span class="line">            pNextFreeBlock-&gt;pPrevFreeBlock = <span class="literal">NULL</span>;</span><br><span class="line">            pNextFreeBlock-&gt;pNextFreeBlock = g_pFreeBlockList;</span><br><span class="line">            <span class="keyword">if</span>(g_pFreeBlockList != <span class="literal">NULL</span>)</span><br><span class="line">                g_pFreeBlockList-&gt;pPrevFreeBlock = pNextFreeBlock;</span><br><span class="line">            g_pFreeBlockList = pNextFreeBlock;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//update old size</span></span><br><span class="line">pBlock-&gt;ulBlockSize = size;           </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//update CurBlkInUseBit</span></span><br><span class="line">pBlock-&gt;CurBlkInUseBit = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">char</span> *)pBlock + <span class="keyword">sizeof</span>(struct SLMemBlock);        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IsTheLastBlockInSegment函数，不变。</p><h4 id="释放原理-1"><a href="#释放原理-1" class="headerlink" title="释放原理"></a>释放原理</h4><p>MyFree函数。输入一个块的主体地址。检查块头部，如果是mmap分配的区域，调用unmap释放区域。检查该块是否是最后一块。如果不是最后一块，如果下一块也空闲，记录新的块大小加上下一块大小，删除空闲链表。如果上一块也空闲，记录新的块大小加上上一块大小，删除空闲链表，同时更新型的块地址为上一块地址，更新新块的头部和脚部，更新空闲链表。如果新块不是Segment的最后一块，更新下一块头部的PrevBlkInUseBit=0，增加空闲链表。如果新块是最后一块，且块大小和去了Segment头部的Segment一样大，说明Segment为空，调用FreeSegment函数释放Segment，否则增加空闲链表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyFree</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(ptr == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SLMemBlock</span> *<span class="title">pBlock</span> =</span> (struct SLMemBlock *)((<span class="keyword">char</span> *)ptr - <span class="keyword">sizeof</span>(struct SLMemBlock));</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SLFreeBlock</span> *<span class="title">pFreeBlock</span> =</span> (struct SLFreeBlock *)( (<span class="keyword">unsigned</span> <span class="keyword">long</span>*)( (<span class="keyword">char</span> *)pNextBlock + pBlock-&gt;ulBlockSize ) - <span class="number">3</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//free by ummap</span></span><br><span class="line">    <span class="keyword">if</span>(pBlock-&gt;FromMmapBit == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">munmap((<span class="keyword">void</span>*)pBlock, pBlock-&gt;ulBlockSize);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> len = pBlock-&gt;ulBlockSize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> bLast = IsTheLastBlockInSegment(pBlock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//not last block</span></span><br><span class="line"><span class="keyword">if</span>(!bLast)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SLMemBlock</span> *<span class="title">pNextBlock</span> =</span> (struct SLMemBlock *)((<span class="keyword">char</span> *)pBlock + len);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SLFreeBlock</span> *<span class="title">pNextBlockFooter</span> =</span> (struct SLFreeBlock *)( (<span class="keyword">unsigned</span> <span class="keyword">long</span>*)( (<span class="keyword">char</span> *)pNextBlock + pBlock-&gt;ulBlockSize ) - <span class="number">3</span> );        </span><br><span class="line">        <span class="comment">//next block is free</span></span><br><span class="line">        <span class="keyword">if</span>(pNextBlock-&gt;CurBlkInUseBit == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//update size of new block</span></span><br><span class="line">            len += pNextBlock-&gt;ulBlockSize;</span><br><span class="line">            <span class="comment">//Delete pNextBlockFooter from FreeBlockList</span></span><br><span class="line">            <span class="keyword">if</span>(g_pFreeBlockList == pNextBlockFooter)</span><br><span class="line">            &#123;</span><br><span class="line">                g_pFreeBlockList = pNextBlockFooter-&gt;pNextFreeBlock;</span><br><span class="line">                <span class="keyword">if</span>(g_pFreeBlockList != <span class="literal">NULL</span>)</span><br><span class="line">                    g_pFreeBlockList-&gt;pPrevFreeBlock = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                pNextBlockFooter-&gt;pPrevFreeBlock-&gt;pNextFreeBlock = pNextBlockFooter-&gt;pNextFreeBlock;</span><br><span class="line">                <span class="keyword">if</span>(pNextBlockFooter-&gt;pNextFreeBlock != <span class="literal">NULL</span>)</span><br><span class="line">                    pNextBlockFooter-&gt;pNextFreeBlock-&gt;pPrevFreeBlock = pNextBlockFooter-&gt;pPrevFreeBlock;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//prev block is free</span></span><br><span class="line"><span class="keyword">if</span>(pBlock-&gt;PrevBlkInUseBit == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">SLFreeBlock</span>* <span class="title">pPrevBlockFooter</span> =</span> (struct SLFreeBlock*)( (<span class="keyword">unsigned</span> <span class="keyword">long</span>*)pBlock - <span class="number">3</span> );</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> prev_size = pPrevBlockFooter-&gt;ulBlockSize;</span><br><span class="line"><span class="comment">//update size of new block</span></span><br><span class="line">        len += prev_size;</span><br><span class="line"><span class="comment">//Delete pPrevBlockFooter from FreeBlockList</span></span><br><span class="line">        <span class="keyword">if</span>(g_pFreeBlockList == pPrevBlockFooter)</span><br><span class="line">        &#123;</span><br><span class="line">            g_pFreeBlockList = pPrevBlockFooter-&gt;pNextFreeBlock;</span><br><span class="line">            <span class="keyword">if</span>(g_pFreeBlockList != <span class="literal">NULL</span>)</span><br><span class="line">                g_pFreeBlockList-&gt;pPrevFreeBlock = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pPrevBlockFooter-&gt;pPrevFreeBlock-&gt;pNextFreeBlock = pPrevBlockFooter-&gt;pNextFreeBlock;</span><br><span class="line">            <span class="keyword">if</span>(pPrevBlockFooter-&gt;pNextFreeBlock != <span class="literal">NULL</span>)</span><br><span class="line">                pPrevBlockFooter-&gt;pNextFreeBlock-&gt;pPrevFreeBlock = pPrevBlockFooter-&gt;pPrevFreeBlock;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//update pBlock</span></span><br><span class="line">pBlock = (struct SLMemBlock *)((<span class="keyword">char</span> *)pBlock - prev_size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//new header</span></span><br><span class="line">pBlock-&gt;ulBlockSize = len;</span><br><span class="line">pBlock-&gt;CurBlkInUseBit = <span class="number">0</span>;</span><br><span class="line">pBlock-&gt;PrevBlkInUseBit = <span class="number">1</span>;</span><br><span class="line">pBlock-&gt;FromMmapBit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//new footer</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SLMemBlock</span> *<span class="title">pNextBlock</span> =</span> (struct SLMemBlock *)((<span class="keyword">char</span> *)pBlock + pBlock-&gt;ulBlockSize);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SLFreeBlock</span> *<span class="title">pBlockFooter</span> =</span> (struct SLFreeBlock *)( (<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(pNextBlock) - <span class="number">3</span> );</span><br><span class="line">    pBlockFooter-&gt;ulBlockSize = pBlock-&gt;ulBlockSize;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//new block is not last block</span></span><br><span class="line">bLast = IsTheLastBlockInSegment(pBlock);</span><br><span class="line"><span class="keyword">if</span>(!bLast)</span><br><span class="line">&#123;</span><br><span class="line">pNextBlock-&gt;PrevBlkInUseBit = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//add new footer to FreeBlockList</span></span><br><span class="line">        pBlockFooter-&gt;pPrevFreeBlock = <span class="literal">NULL</span>;</span><br><span class="line">        pBlockFooter-&gt;pNextFreeBlock = g_pFreeBlockList;</span><br><span class="line">        <span class="keyword">if</span>(g_pFreeBlockList != <span class="literal">NULL</span>)</span><br><span class="line">            g_pFreeBlockList-&gt;pPrevFreeBlock = pBlockFooter;</span><br><span class="line">        g_pFreeBlockList = pBlockFooter;  </span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//new block is last</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">//segment is free</span></span><br><span class="line"><span class="keyword">if</span>(pBlock-&gt;ulBlockSize == SEGMENT_SIZE - <span class="keyword">sizeof</span>(struct SLMemSegment))</span><br><span class="line">        &#123;</span><br><span class="line">FreeSegment((struct SLMemSegment *)((<span class="keyword">char</span> *)pBlock - <span class="keyword">sizeof</span>(struct SLMemSegment)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//segment is not free</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//add new footer to FreeBlockList</span></span><br><span class="line">            pBlockFooter-&gt;pPrevFreeBlock = <span class="literal">NULL</span>;</span><br><span class="line">            pBlockFooter-&gt;pNextFreeBlock = g_pFreeBlockList;</span><br><span class="line">            <span class="keyword">if</span>(g_pFreeBlockList != <span class="literal">NULL</span>)</span><br><span class="line">                g_pFreeBlockList-&gt;pPrevFreeBlock = pBlockFooter;</span><br><span class="line">            g_pFreeBlockList = pBlockFooter;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FreeSegment函数，不变。</p><h4 id="某一时间点分配器分配的虚拟主存快照-1"><a href="#某一时间点分配器分配的虚拟主存快照-1" class="headerlink" title="某一时间点分配器分配的虚拟主存快照"></a>某一时间点分配器分配的虚拟主存快照</h4><p><img src="/2021/11/08/malloc/image-20211114014635415.png" alt="image-20211114014635415"></p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>测试单个Segment</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *p1 = MyMalloc(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">void</span> *p2 = MyMalloc(<span class="number">256</span>*<span class="number">1024</span>);</span><br><span class="line"><span class="keyword">void</span> *p3 = MyMalloc(<span class="number">64</span>);</span><br><span class="line"><span class="keyword">void</span> *p4 = MyMalloc(<span class="number">71</span>);</span><br><span class="line">MyFree(p1);</span><br><span class="line">MyFree(p2);</span><br><span class="line"><span class="keyword">void</span> *p5 = MyMalloc(<span class="number">420</span>*<span class="number">1024</span>);</span><br><span class="line"><span class="keyword">void</span> *p6 = MyMalloc(<span class="number">99</span>);</span><br><span class="line">MyFree(p4);</span><br><span class="line">MyFree(p3);</span><br><span class="line">MyFree(p6);</span><br><span class="line">MyFree(p5);</span><br></pre></td></tr></table></figure><p>测试两个Segment</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *p1 = MyMalloc(<span class="number">262120</span>);  <span class="comment">//256*1024-24</span></span><br><span class="line"><span class="keyword">void</span> *p2 = MyMalloc(<span class="number">262120</span>);</span><br><span class="line"><span class="keyword">void</span> *p3 = MyMalloc(<span class="number">262120</span>);</span><br><span class="line"><span class="keyword">void</span> *p4 = MyMalloc(<span class="number">262120</span>);</span><br><span class="line"><span class="keyword">void</span> *p5 = MyMalloc(<span class="number">262120</span>);</span><br><span class="line"><span class="keyword">void</span> *p6 = MyMalloc(<span class="number">262120</span>);</span><br><span class="line"><span class="keyword">void</span> *p7 = MyMalloc(<span class="number">262120</span>);</span><br><span class="line"><span class="keyword">void</span> *p8 = MyMalloc(<span class="number">262120</span>);</span><br><span class="line"><span class="keyword">void</span> *p9 = MyMalloc(<span class="number">262120</span>);</span><br><span class="line">MyFree(p9);</span><br><span class="line">MyFree(p8);</span><br><span class="line">MyFree(p4);</span><br><span class="line">MyFree(p3);</span><br><span class="line">MyFree(p7);</span><br><span class="line">MyFree(p1);</span><br><span class="line">MyFree(p2);</span><br><span class="line">MyFree(p5);</span><br><span class="line">MyFree(p6);</span><br></pre></td></tr></table></figure><h2 id="分离空闲链表-To-Do"><a href="#分离空闲链表-To-Do" class="headerlink" title="分离空闲链表 To Do"></a>分离空闲链表 To Do</h2><p>将块大小分成数个类，分配器维护一个空闲链表数组，每个空闲链表包含对应大小的空闲块</p><h1 id="加锁，并发分配"><a href="#加锁，并发分配" class="headerlink" title="加锁，并发分配"></a>加锁，并发分配</h1><h3 id="为什么要加锁"><a href="#为什么要加锁" class="headerlink" title="为什么要加锁"></a>为什么要加锁</h3><p>比如这样一个场景：多线程递减一全局变量的问题。</p><p>C编译器将增减运算转换成3条机器指令：从内存装载到寄存器，递减寄存器，从寄存器存储到内存。</p><p>某个出错情形：线程A运行，把nconn的值3装载到一个寄存器。系统把运行线程从A切换到B，A的寄存器被保存，B的寄存器被恢复。线程B执行与C表达式nconn—相对应的3条指令，把新值2存储到nconn。一段时间后，系统把运行线程从B切换回A。A的寄存器被恢复，A从原来离开的地方继续执行，把那个寄存器值从3减为2，再把值2存储到nconn。由于A没读到B减过的数据，所以最后A写了脏数据到nocnn中。</p><p><strong>把问题放大的测试代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;pthread.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NLOOP 5000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> counter; <span class="comment">/* incremented by threads */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">doit</span><span class="params">(<span class="keyword">void</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> </span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">pthread_t</span> tidA, tidB;</span><br><span class="line"></span><br><span class="line">  Pthread_create(&amp;tidA, <span class="literal">NULL</span>, &amp;doit, <span class="literal">NULL</span>);</span><br><span class="line">  Pthread_create(&amp;tidB, <span class="literal">NULL</span>, &amp;doit, <span class="literal">NULL</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* wait for both threads to terminate */</span></span><br><span class="line">  Pthread_join(tidA, <span class="literal">NULL</span>);</span><br><span class="line">  Pthread_join(tidB, <span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">doit</span><span class="params">(<span class="keyword">void</span> *vptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, val;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Each threads fetches, prints, and increments the counter NLOOP times.The value of the counter should increase monotonically.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NLOOP; i++)&#123;</span><br><span class="line">    val = counter;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d: %d\n&quot;</span>, pthread_self(), val + <span class="number">1</span>);</span><br><span class="line">    counter = val + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>某段结果：<img src="/2021/11/08/malloc/image-20211113232125079.png" alt="image-20211113232125079"></p><h3 id="同步锁"><a href="#同步锁" class="headerlink" title="同步锁"></a>同步锁</h3><p>在MyMalloc.c中将一个静态(仅该源文件可用)全局变量初始化为锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_mutex_t</span> allocator_mutex = PTHREAD_MUTEX_INITIALIZER;</span><br></pre></td></tr></table></figure><p>在MyMalloc和MyFree函数的入口出口分别加锁，解锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pthread_mutex_lock(&amp;counter_mutex);</span><br><span class="line">......</span><br><span class="line">Pthread_mutex_unlock(&amp;counter_mutex);</span><br></pre></td></tr></table></figure><h3 id="异步锁-To-Do"><a href="#异步锁-To-Do" class="headerlink" title="异步锁 To Do"></a>异步锁 To Do</h3><h3 id="每个线程一个私有空闲链表-To-Do"><a href="#每个线程一个私有空闲链表-To-Do" class="headerlink" title="每个线程一个私有空闲链表 To Do"></a>每个线程一个私有空闲链表 To Do</h3><h3 id="futex-To-Do"><a href="#futex-To-Do" class="headerlink" title="futex To Do"></a>futex To Do</h3><h3 id="CAS免锁-Compared-and-Swap-To-Do"><a href="#CAS免锁-Compared-and-Swap-To-Do" class="headerlink" title="CAS免锁 Compared and Swap To Do"></a>CAS免锁 Compared and Swap To Do</h3>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2021/11/08/%E7%89%B9%E5%BE%81%E5%87%BD%E6%95%B0/"/>
      <url>/2021/11/08/%E7%89%B9%E5%BE%81%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>title: 特征函数<br>description: 随机过程的特征函数，到底是什么呢？怎么诞生的？有什么用？<br>abbrlink: 25539<br>date: 2021-11-08 11:54:56<br>tags:<br>categories: 数<br>cover: /img/math.png </p><h1 id="不吐不快"><a href="#不吐不快" class="headerlink" title="不吐不快"></a>不吐不快</h1><p>随机过程的授课，教材，完全是一坨屎，知识出现了巨大的断层。</p><p>微积分，线性代数完全像空中楼阁，一捅就破。</p><p>人的脑子从来是从直观理解抽象(抽之于象)的，编写教材的人，授课的人，相关的人，应该好好反思自己到底在做什么。</p><p>为什么把美妙宝贵的经验模型印刷成/传授成无用的垃圾，丑陋的负担，面目可憎的东西。</p><p>将妙趣横生，令人拍声叫好的思维果实，塑造成毫无美感的恶心的东西，也是离谱了。</p><h1 id="烂尾宣告"><a href="#烂尾宣告" class="headerlink" title="烂尾宣告"></a>烂尾宣告</h1><p>烂尾了，现阶段理解不了。从泰勒级数，微分的基础：用极限求导，指数函数求导诞生自然常数e，虚数单位i，复杂数a+bi，泰勒级数推导出的欧拉公式，到对随机变量的矩的理解，特征函数包含了随机变量的所有矩，最后倒在傅里叶变换。</p><h1 id="随机变量和分布函数"><a href="#随机变量和分布函数" class="headerlink" title="随机变量和分布函数"></a>随机变量和分布函数</h1><p>&emsp;&emsp;随机变量是函数，其反应的映射关系是从随机试验的样本空间中的样本，映射到值域中的一个值。</p><p>&emsp;&emsp;累积概率分布函数F(x)=P{X≤x} （某事件概率=符合该事件的样本数/样本总数）用来研究随机试验样本或结果的分布情况(概率)。</p><p>&emsp;&emsp;概率密度函数：对应于离散型随机变量的分布律，展示了每一个值域中的值出现的概率，概率密度展示了连续型随机变量每一个值域中的值出现的概率。</p><p><img src="/2021/11/08/%E7%89%B9%E5%BE%81%E5%87%BD%E6%95%B0/image-20211122150653241.png" alt="image-20211122150653241"></p><p>&emsp;&emsp;在物理中，密度是质量m/体积v，表示单位体积的平均质量。对应到概率论中，密度是累加的概率P/一段值域，表示这单位区域长度上的平均概率，对F(x)求导，导数是某点附近的平均概率。可以用∫f(x)dx求累积概率分布函数F(x)。</p><p><img src="/2021/11/08/%E7%89%B9%E5%BE%81%E5%87%BD%E6%95%B0/image-20211122145833039.png" alt="image-20211122145833039"></p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>特征函数是随机变量的分布的另一种表现形式。</p><h1 id="泰勒级数"><a href="#泰勒级数" class="headerlink" title="泰勒级数"></a>泰勒级数</h1><p>参考妈咪说视频，两个函数，起点一样，各阶导数(函数关于自变量的变化率，函数关于自变量的变化率的变化率…)都一样，就认为这两个函数一样。</p><h2 id="亲民的函数如多项式函数"><a href="#亲民的函数如多项式函数" class="headerlink" title="亲民的函数如多项式函数"></a>亲民的函数如多项式函数</h2><p>y=x</p><p>y=x^3+x^2+5x+6</p><p>给一个x值，很快能算出对应的y值</p><p>多项式：自变量和常数通过加减乘以及自然数的幂次方运算得到的代数表达式</p><h2 id="不亲民的函数如三角函数和e-x"><a href="#不亲民的函数如三角函数和e-x" class="headerlink" title="不亲民的函数如三角函数和e^x"></a>不亲民的函数如三角函数和e^x</h2><p>y=sinx</p><p>y=cosx</p><p>y=e^x</p><p>这类函数你就不能很快的得到函数值，不能够快速求值，就比较讨厌</p><p>根据泰勒级数可知，两个函数f(x)，g(x)的各阶导数相等的越多，那么这两个函数越相似。</p><h2 id="不亲民的函数能否用多项式进行表达呢？"><a href="#不亲民的函数能否用多项式进行表达呢？" class="headerlink" title="不亲民的函数能否用多项式进行表达呢？"></a>不亲民的函数能否用多项式进行表达呢？</h2><h3 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h3><p>速度是路程关于时间的变化率，加速度是速度关于时间的变化率，加速度的加速度是加速度关于时间的变化率，…, 变化率也叫导数。</p><p>两个小人从同一起点沿同一直线，如果想走的一模一样，其初始速度，加速度，加速度的加速度, … 也就是n阶导数都要一样。</p><h3 id="用多项式拟合不亲民的函数，如果无穷项，那就是一模一样"><a href="#用多项式拟合不亲民的函数，如果无穷项，那就是一模一样" class="headerlink" title="用多项式拟合不亲民的函数，如果无穷项，那就是一模一样"></a>用多项式拟合不亲民的函数，如果无穷项，那就是一模一样</h3><p>假设f(x)=e^x 或 sinx 或 cosx</p><p>g(x)=a0+a1x+a2x^2+…+anx^n</p><p>要求f(0)=g(0)=1 =&gt; a0=1，使得起点和各阶导数都相等</p><p>f’(0) = g’(0)</p><p>f’’(0)=g’’(0)</p><p>…</p><p>fn(0)=gn(0)=n!an</p><p><img src="/2021/11/08/%E7%89%B9%E5%BE%81%E5%87%BD%E6%95%B0/image-20211228204518236.png" alt="image-20211228204518236"></p><h1 id="自然常数e，诞生自指数函数求导"><a href="#自然常数e，诞生自指数函数求导" class="headerlink" title="自然常数e，诞生自指数函数求导"></a>自然常数e，诞生自指数函数求导</h1><p>参考MIT课程 highlights of calculus</p><p>参考youtube视频</p><p><a href="https://www.youtube.com/watch?v=m2MIpDrF7Es">https://www.youtube.com/watch?v=m2MIpDrF7Es</a></p><h2 id="e的产生"><a href="#e的产生" class="headerlink" title="e的产生"></a>e的产生</h2><p>人们用极限对指数函数求导发现</p><p><img src="/2021/11/08/%E7%89%B9%E5%BE%81%E5%87%BD%E6%95%B0/image-20220102004032483.png" alt="image-20220102004032483"></p><p><img src="/2021/11/08/%E7%89%B9%E5%BE%81%E5%87%BD%E6%95%B0/image-20220102004027381.png" alt="image-20220102004027381"></p><p><img src="/2021/11/08/%E7%89%B9%E5%BE%81%E5%87%BD%E6%95%B0/image-20220102004051266.png" alt="image-20220102004051266"></p><p><img src="/2021/11/08/%E7%89%B9%E5%BE%81%E5%87%BD%E6%95%B0/image-20220102004153400.png" alt="image-20220102004153400"></p><p>M(t)=2^t的导数，与其本身成正比，比值为一个神秘的数字0.693…</p><p><img src="/2021/11/08/%E7%89%B9%E5%BE%81%E5%87%BD%E6%95%B0/image-20220102004300478.png" alt="image-20220102004300478"></p><p>M(t)=3^t的导数，与其本身成正比，比值为一个神秘的数字1.098…</p><p><img src="/2021/11/08/%E7%89%B9%E5%BE%81%E5%87%BD%E6%95%B0/image-20220102004457923.png" alt="image-20220102004457923"></p><p>M(t)=8^t的导数，与其本身成正比，比值为一个神秘的数字2.079…</p><p>是否有一个底数，使得其指数函数的导数与自身相等？定义其为e</p><h2 id="根据e-t的导数等于自身的性质，求e"><a href="#根据e-t的导数等于自身的性质，求e" class="headerlink" title="根据e^t的导数等于自身的性质，求e"></a>根据e^t的导数等于自身的性质，求e</h2><p>根据性质，直接用泰勒级数逼近e^x</p><script type="math/tex; mode=display">e^x=1+x+{x^2\over2!}+{x^3\over3!}+{x^4\over4!}+...+{x^n\over n!}</script><p>当x=1时，就产生了e</p><p>微分方程：dy/dx=y 即求导数等于自身的y，y=e^x</p><h2 id="自然对数的使用，结合链式求导规则"><a href="#自然对数的使用，结合链式求导规则" class="headerlink" title="自然对数的使用，结合链式求导规则"></a>自然对数的使用，结合链式求导规则</h2><p>链式求导规则：</p><p>代数，以符号代数：</p><script type="math/tex; mode=display">{△z\over△y}{△y\over△x}={△z\over△x}</script><p>极限，△(距离)趋近无穷小</p><script type="math/tex; mode=display">{dz\over dy} {dy\over dx} = {dz\over dx}</script><p>使用自然对数换底：</p><p>如2换成e^ln(2), 2^t求导后为ln(2)e^ln(2)t = ln(2)2^t</p><p><img src="/2021/11/08/%E7%89%B9%E5%BE%81%E5%87%BD%E6%95%B0/image-20220102005643853.png" alt="image-20220102005643853"></p><p><img src="/2021/11/08/%E7%89%B9%E5%BE%81%E5%87%BD%E6%95%B0/image-20220102010052376.png" alt="image-20220102010052376"></p><p>现在，指数函数求导得到的神秘系数，就是以其底数为真值的自然对数。</p><h1 id="数系和欧拉公式"><a href="#数系和欧拉公式" class="headerlink" title="数系和欧拉公式"></a>数系和欧拉公式</h1><p>参考李永乐视频</p><h2 id="数系"><a href="#数系" class="headerlink" title="数系"></a>数系</h2><ol><li>自然数N：{1，2，3，…}。1+2=3对加法封闭，1-2=-1对减法不封闭</li><li>整数Z：{…，-2，-1，0，1，2，…}。 对加减法封闭，2*3=6对乘法封闭，对除法不封闭2/3=?</li><li>可比数Q：{x|x=p/q, p,q∈Z}。对加减乘除封闭（除数不为0），2的开方=？对开方不封闭。</li><li>实数R ：用一根数轴表述，你给一个可比数，或者给一个不可比数，我都可以在数轴上找一个点。认为实数与数轴上的点一一对应。</li></ol><h2 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h2><p>一开始人们认为2-3没有意义，后来称其结果为-1，自然数拓宽到整数。</p><p>人们又认为2/3是没有意义的，后来称其为分数(可比数)，整数拓宽带可比数。</p><p>人们又认为根号2是没有意义的，后来称其为不可比数，可比数拓宽到实数。</p><p>现在，人们认为方程x^2=-1的解是没有意义的，也许它是有意义的，称其解为复数。</p><h3 id="虚数"><a href="#虚数" class="headerlink" title="虚数"></a>虚数</h3><p>i^2=-1 =&gt; i=根号-1，i就是虚数单位</p><p>i^1=i，i^2=-1，i^3=-i，i^4=1</p><h3 id="复数-1"><a href="#复数-1" class="headerlink" title="复数"></a>复数</h3><p>形如a+bi的数，其中a和b都是实数。</p><p>复数的概念可以在一个平面上表示，横轴表示实数轴，数轴为虚数轴。</p><p>对于复数，加减乘除或者是实数次幂都是封闭的。</p><h3 id="欧拉公式"><a href="#欧拉公式" class="headerlink" title="欧拉公式"></a>欧拉公式</h3><p>问题来了，有人问一个数的复数次幂，比如2^i是什么呢？</p><p>于是欧拉提出了欧拉公式：e^iθ=cosθ+isinθ</p><p>欧拉恒等式：令θ=π，e^iπ=-1，即e^iπ+1=0</p><h4 id="最美公式"><a href="#最美公式" class="headerlink" title="最美公式"></a>最美公式</h4><p>人们说欧拉恒等式是最美的公式，因为它联系了自然界最重要的五个数：e，π，1，0，i</p><h3 id="欧拉公式的证明"><a href="#欧拉公式的证明" class="headerlink" title="欧拉公式的证明"></a>欧拉公式的证明</h3><p>可以用泰勒展开</p><script type="math/tex; mode=display">e^x=1+x+{x^2\over2!}+{x^3\over3!}+{x^4\over4!}+...+{x^n\over n!}</script><script type="math/tex; mode=display">sinx=x-{1\over3!}x^3+{1\over5!}x^5-{1\over7!}x^7+...</script><script type="math/tex; mode=display">cosx=1-{1\over2!}x^2+{1\over4!}x^4-{1\over6!}x^6+...</script><p>也可以用微分方程</p><h3 id="欧拉公式的应用"><a href="#欧拉公式的应用" class="headerlink" title="欧拉公式的应用"></a>欧拉公式的应用</h3><p>可以把复数形式变成指数形式</p><h1 id="概率论中的矩"><a href="#概率论中的矩" class="headerlink" title="概率论中的矩"></a>概率论中的矩</h1><h2 id="力矩"><a href="#力矩" class="headerlink" title="力矩"></a>力矩</h2><p><img src="/2021/11/08/%E7%89%B9%E5%BE%81%E5%87%BD%E6%95%B0/image-20211228211249358.png" alt="image-20211228211249358"></p><h2 id="概率论中的矩-1"><a href="#概率论中的矩-1" class="headerlink" title="概率论中的矩"></a>概率论中的矩</h2><h3 id="彩票问题"><a href="#彩票问题" class="headerlink" title="彩票问题"></a>彩票问题</h3><p>每一张中奖率如下</p><p><img src="/2021/11/08/%E7%89%B9%E5%BE%81%E5%87%BD%E6%95%B0/image-20211228211338078.png" alt="image-20211228211338078"></p><p>画成概率分布图</p><p><img src="/2021/11/08/%E7%89%B9%E5%BE%81%E5%87%BD%E6%95%B0/image-20211228211423666.png" alt="image-20211228211423666"></p><p>把0.00001%概率的500万，称一下，等同于概率为1的0.5</p><p><img src="/2021/11/08/%E7%89%B9%E5%BE%81%E5%87%BD%E6%95%B0/image-20211228211638226.png" alt="image-20211228211638226"></p><p>把可能中奖的结果称一下，等同于概率为1的1.5</p><p><img src="/2021/11/08/%E7%89%B9%E5%BE%81%E5%87%BD%E6%95%B0/image-20211228211737565.png" alt="image-20211228211737565"></p><p>实际上，如果都能卖完，一张彩票值1.5元，它卖2元它就赚。</p><h3 id="矩"><a href="#矩" class="headerlink" title="矩"></a>矩</h3><p>我们上面算的，实际上是期望E[x]=∑pixi，其实这就是矩</p><p><img src="/2021/11/08/%E7%89%B9%E5%BE%81%E5%87%BD%E6%95%B0/image-20211228212327372.png" alt="image-20211228212327372"></p><p>因为x是一次幂，所以也称一阶矩</p><p>方差D(x)=E[(X-μ)^2] = ∑pi(xi-μ)^2，所以方差也称为二阶矩。</p><p>矩是对试验及其对应的随机变量的一种刻画</p><p>直觉上可以有以下推论（其实还是有条件的，这里先忽略这些严格性，在实际应用中如下思考问题不大）：</p><p>各阶矩相等=&gt;各个特征相等=&gt;分布相同</p><h1 id="随机变量的特征函数"><a href="#随机变量的特征函数" class="headerlink" title="随机变量的特征函数"></a>随机变量的特征函数</h1><p>随机变量X的特征函数定义为：</p><script type="math/tex; mode=display">\psi_X(t)=E[e^{itX}]</script><p>为什么这么定义呢？首先，e^itX的泰勒展开式为：</p><script type="math/tex; mode=display">e^{itX}=1+{itX\over1}-{t^2X^2\over2!}-{it^3X^3\over3!}+...+{(it)^nX^n\over n!}</script><p>代入可以推出</p><script type="math/tex; mode=display">\psi_X(t)=E[e^{itX}]=1+{itE[X]\over1}-{t^2E[X^2]\over2!}-{it^3E[X^3]\over3!}+...+{(it)^nE[X^n]\over n!}</script><p>原来特征函数包含了分布函数的所有矩，也就是包含了分布函数的所有特征。</p><p>有数学家这么形同生成函数（特征函数是生成函数的一种）：</p><p>A generating function is a clothesline on which we hang up a sequence of numbers for display. 生成函数是用来展示一串数字的晾衣架。</p><p>特征函数确实像把各阶矩串在绳子上：</p><p><img src="/2021/11/08/%E7%89%B9%E5%BE%81%E5%87%BD%E6%95%B0/image-20211228214225856.png" alt="image-20211228214225856"></p><p>特征函数就是随机变量X的分布的另一种描述方式。</p><h1 id="傅里叶变换"><a href="#傅里叶变换" class="headerlink" title="傅里叶变换"></a>傅里叶变换</h1><p>参考 李永乐视频</p><p>参考 知乎文章 <a href="https://zhuanlan.zhihu.com/p/19763358">傅里叶分析之掐死教程（完整版）更新于2014.06.06 - 知乎 (zhihu.com)</a> </p><p><a href="https://zhuanlan.zhihu.com/p/41455378">傅里叶系列（一）傅里叶级数的推导 - 知乎 (zhihu.com)</a></p><h2 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h2><p>向量 &lt;-&gt; 点坐标，正交基</p><p><img src="/2021/11/08/%E7%89%B9%E5%BE%81%E5%87%BD%E6%95%B0/image-20220101230026704.png" alt="image-20220101230026704"></p><h2 id="描述规律振动现象的数学语言-三角函数"><a href="#描述规律振动现象的数学语言-三角函数" class="headerlink" title="描述规律振动现象的数学语言-三角函数"></a>描述规律振动现象的数学语言-三角函数</h2><p>如物体挂在弹簧上作简谐振动、单摆振动、无线电电子振荡器的电子振荡等，大多可以表述为：</p><script type="math/tex; mode=display">f(t)=Asin(\omega t+\psi)</script><p>其中，t表示时间，A表示振幅，ω表示角频率(是对旋转快慢的度量)，ψ表示初相(与考察时设置的原点位置有关)</p><h2 id="傅里叶级数的提出"><a href="#傅里叶级数的提出" class="headerlink" title="傅里叶级数的提出"></a>傅里叶级数的提出</h2><p>然而，世界上许多周期信号并非正弦函数那么简单，如方波、三角波等。傅里叶就想，能否用一系列的三角函数Ansin(nωt+ψ)之和来表示较复杂的周期函数f(t)呢。</p><p>于是，1807年，傅里叶提出(据说是傅里叶解热方程和弦振动导出的)：</p><script type="math/tex; mode=display">f(t)=A0+\sum_{n=1}^\infty A_nsin(n\omega t + \psi_n) \qquad(2)</script><p>这里，t是变量，其他都是常量。傅里叶是想把一个周期为T的函数表示成周期为T,2T,3T,4T,…  的正弦函数的线性叠加，一大堆正弦函数有不同的振幅，周期或者说频率，初相角，常数系数。n是从1到无穷大，这是一个无穷级数。</p><p>这里强调一下，傅里叶级数中对不同频率的波有一个要求就是给定一个初始的频率ω0，2π\ω0就是f(t)的周期，之后的角频率必须是ω0的整数倍，这就是DFT(Discrete Fourier Transform，DFT)中的角频率取值的规则</p><p>傅里叶对式2使用和角公式作变形：</p><script type="math/tex; mode=display">A_nsin(n\omega t+\psi_n)=A_nsin\psi_ncos(n\omega t)+A_ncos\psi_nsin(n\omega t) \qquad(3)</script><p>整合常数项，记</p><script type="math/tex; mode=display">a_n=A_nsin\psi_n，b_n=A_ncos\psi_n</script><p>这样公式3就可以写成如下形式：</p><script type="math/tex; mode=display">f(t)=A_0+\sum_{n=1}^\infty[a_ncos(n\omega t)+b_nsin(n\omega t)] \qquad (4)</script><p>我们只要解出A0，an，bn就可以得到周期函数f(t)的傅里叶级数</p><h2 id="麦克劳林公式中的待定系数法"><a href="#麦克劳林公式中的待定系数法" class="headerlink" title="麦克劳林公式中的待定系数法"></a>麦克劳林公式中的待定系数法</h2><p>这里为求A0，an，bn提供思路：</p><p>泰勒级数即为任意一个函数都可以用一个多项式来逼近，记为：</p><script type="math/tex; mode=display">f(x)=A+Bx+Cx^2+Dx^3+...</script><p>那么，麦克劳林令：</p><script type="math/tex; mode=display">f'(x)=B+2Cx+3Dx^2+...</script><script type="math/tex; mode=display">f''(x)=2CX+6Dx+...</script><script type="math/tex; mode=display">......</script><p>令x=0，可知</p><script type="math/tex; mode=display">A=f(0)</script><script type="math/tex; mode=display">B=f'(0)</script><script type="math/tex; mode=display">C=f''(0)/2!</script><script type="math/tex; mode=display">D=f'''(0)/3!</script><p>即</p><script type="math/tex; mode=display">N=f^n(x)/n!</script><p>而三角函数在一个周期内的积分(求被积函数与横坐标轴围成的面积，也是求还原后函数的值的变化量)为0：</p><p><img src="/2021/11/08/%E7%89%B9%E5%BE%81%E5%87%BD%E6%95%B0/Users/%25E5%25BE%2590%25E7%259B%259B/AppData/Roaming/Typora/draftsRecover/%25E7%2589%25B9%25E5%25BE%2581%25E5%2587%25BD%25E6%2595%25B0/v2-71286c295f4d93ac28ba335149dbea40_720w.jpg" alt="img"></p><h2 id="三角函数的正交性"><a href="#三角函数的正交性" class="headerlink" title="三角函数的正交性"></a>三角函数的正交性</h2><p>这是为下一步傅里叶级数展开时所用积分的准备知识：</p><p>一个三角函数系：1,cosx,sinx,cos2x,sin2x,…,cosnx,sinnx,…如果这一堆函数(包括常数1)中任何两个不同函数的乘积在区间[-π，π]上的积分为0，就说三角函数系在区间[-π，π]上正交，即有如下式子：</p><script type="math/tex; mode=display">\int_{-\pi}^{\pi}cosnxdx=0 \quad(n=1,2,3,...)</script><script type="math/tex; mode=display">\int_{-\pi}^{\pi}sinnxdx=0 \quad(n=1,2,3,...)</script><script type="math/tex; mode=display">\int_{-\pi}^{\pi}sinkx·cosnxdx=0 \quad(k,n=1,2,3,...)</script><script type="math/tex; mode=display">\int_{-\pi}^{\pi}coskx·cosnxdx=0 \quad(k,n=1,2,3,...;k\neq n)</script><script type="math/tex; mode=display">\int_{-\pi}^{\pi}sinkx·sinnxdx=0 \quad(k,n=1,2,3,...;k\neq n)</script><p>以上各式在区间[-π,π]的定积分均为0，第1式第2式可视为三角函数cos和sin与1相乘的积分；第3-5式则为sin和cos的不同组合相乘的积分公式。除了这5个式子外，不再有其他组合。但第3式中，k与n可以相等，相等时也是二个不同函数。</p><script type="math/tex; mode=display">coskx·cosnx={1\over2}[cos(k+n)x+cos(k-n)x]</script><script type="math/tex; mode=display">sinkx·sinnx=-{1\over2}[cos(k+n)x-cos(k-n)x]</script><script type="math/tex; mode=display">sinkx·cosnx={1\over2}[sin(k+n)x+sin(k-n)x]</script><p>计算第4式的定积分结果为0,3和5式方法相同</p><script type="math/tex; mode=display">\int_{-\pi}^\pi coskx·cosnxdx = {1\over2}\int_{-\pi}^\pi[cos(k+n)x+cos(k-n)x]dx = {1\over2}[{sin(k+n)x\over k+n}+{sin(k-n)x\over k-n}]|_{-\pi}^\pi = {1\over2}[0+0]=0</script><p>现在，我们知道三角函数系：1,cosx,sinx,cos2x,sin2x,…,cosnx,sinnx,…这一堆函数(包括常数1)中任何两个不同函数的乘积在区间[-π，π]上的积分为0</p><h2 id="函数展开成傅里叶级数"><a href="#函数展开成傅里叶级数" class="headerlink" title="函数展开成傅里叶级数"></a>函数展开成傅里叶级数</h2><p>前面提出的傅里叶级数：</p><script type="math/tex; mode=display">f(t)=A_0+\sum_{n=1}^\infty[a_ncos(n\omega t)+b_nsin(n\omega t)] \qquad (4)</script><p>对4式从[-π,π]积分，得</p><script type="math/tex; mode=display">\int_{-\pi}^{\pi}f(t)dt=\int_{-\pi}^\pi A_0dt+ \int_{-\pi}^\pi\sum_{n=1}^\infty[a_ncos(n\omega t)+b_nsin(n\omega t)]dt</script><script type="math/tex; mode=display">=\int_{-\pi}^{\pi}A_0dt+0=A_0t|_{-\pi}^\pi</script><script type="math/tex; mode=display">=(\pi-(-\pi))A_0=2\pi A_0</script><p>求得A0</p><script type="math/tex; mode=display">A_0={1\over2\pi}\int_{-\pi}^{\pi}f(t)dt</script><p>用coskωt乘4式的两边得</p><script type="math/tex; mode=display">f(t)cos(k\omega t)=A_0cos(k\omega t)+\sum_{n=1}^\infty[a_ncos(n\omega t)cos(k\omega t)+b_nsin(n\omega t)cos(k\omega t)]</script><p>对上式两边同时从-π到π积分</p><script type="math/tex; mode=display">\int_{-\pi}^{\pi}f(t)cos(k\omega t)dt = A_0\int_{-\pi}^{\pi}cos(k\omega t)dt+\sum_{n=1}^\infty[a_n\int_{-\pi}^{\pi}cos(n\omega t)·cos(k\omega t)+b_n\int_{-\pi}^{\pi}sin(n\omega t)·cos(k\omega t)]dt</script><p>根据三角函数的正交性，仅当k=n时，右边有不为0的积分项，即</p><script type="math/tex; mode=display">\int_{-\pi}^{\pi}cos(k\omega t)f(t)=a_n\int_{-\pi}^{\pi}cos^2(n\omega t)dt</script><script type="math/tex; mode=display">={a_n\over 2}\int_{-\pi}^{\pi}(1+cos2n\omega t)dt \qquad(半角公式)</script><script type="math/tex; mode=display">={a_n\over 2}(\int_{-\pi}^{\pi}1dt+\int_{-\pi}^{\pi}cos2n\omega tdt) \qquad(后一项三角函数积分为0)</script><script type="math/tex; mode=display">={a_n\over2}·2\pi=a_n\pi</script><p>解得</p><script type="math/tex; mode=display">a_n={1\over\pi}\int_{-\pi}^{\pi}cos(n\omega t)·f(t)dt \qquad(k=n)</script><p>同理，用sin(kωt)乘4式两边得：</p><script type="math/tex; mode=display">b_n={1\over\pi}\int_{-\pi}^{\pi}sin(n\omega t)·f(t)dt</script><p>我们发现A0的分母为2π，而an和bn的分母为π，为了统一分母，能够将a0用an表示，我们令a0=2A0 有：</p><script type="math/tex; mode=display">a_0={1\over\pi}\int_{-\pi}^{\pi}f(t)dt</script><p>推导的时候假设T=2π，然而T可以为任何长度的周期，将T=2π带进an，bn的表达式中</p><p>汇总得：</p><script type="math/tex; mode=display">a_n={2\over T}\int_{t_0}^{t_0+T}cos(n\omega t)·f(t)dt</script><script type="math/tex; mode=display">b_n={2\over T}\int_{t_0}^{t_0+T}sin(n\omega t)·f(t)dt</script><h2 id="傅里叶级数的指数形式"><a href="#傅里叶级数的指数形式" class="headerlink" title="傅里叶级数的指数形式"></a>傅里叶级数的指数形式</h2><p>根据欧拉公式，有</p><script type="math/tex; mode=display">cos(n\omega t)={1\over 2}(e^{-in\omega t}+e^{in\omega t})</script><script type="math/tex; mode=display">sin(n\omega t)={j\over 2}(e^{-in\omega t}-e^{in\omega t})</script><p>代入傅里叶级数得：</p><script type="math/tex; mode=display">f(t)={a_0\over 2}+\sum_{n=1}^\infty[a_n{e^{in\omega t}+e^{-in\omega t}\over 2}+ib_n{e^{-in\omega t}-e^{in\omega t}\over 2}]</script><script type="math/tex; mode=display">={a_0\over 2}+\sum_{n=1}^\infty[{a_n-ib_n\over 2}e^{in\omega t}+{a_n+ib_n\over 2}e^{-in\omega t}] \qquad (5)</script><p>将an,bn的表达式代入得</p><script type="math/tex; mode=display">{a_n-ib_n\over 2}={1\over T}[\int_{t_0}^{t_0+T}f(t)cos(n\omega t)dt-i\int_{t_0}^{t_0+T}f(t)sin(n\omega t)dt]</script><script type="math/tex; mode=display">={1\over T}\int_{t_0}^{t_0+T}f(t)[cos(n\omega t)-isin(n\omega t)]dt</script><script type="math/tex; mode=display">={1\over T}\int_{t_0}^{t_0+T}f(t)e^{-in\omega t}dt</script><p>同理可得：</p><script type="math/tex; mode=display">{a_n+ib_n\over2}={1\over T}\int_{t_0}^{t_0+T}f(t)e^{in\omega t}dt</script><p>将两式代入5式得</p><script type="math/tex; mode=display">f(t)={1\over T}\int_{t_0}^{t_0+T}f(t)dt+{1\over T}\sum_{n=1}^\infty[\int_{t_0}^{t_0+T}f(t)e^{-in\omega t}dt·e^{in\omega t}+\int_{t_0}^{t_0+T}f(t)e^{in\omega t}dt·e^{-in\omega t}]</script><script type="math/tex; mode=display">={1\over T}\int_{t_0}^{t_0+T}f(t)dt+{1\over T}\sum_{n=1}^\infty\int_{t_0}^{t_0+T}f(t)e^{-in\omega t}dt·e^{in\omega t}+{1\over T}\sum_{n=-1}^{-\infty}\int_{t_0}^{t_0+T}f(t)e^{-in\omega t}dt·e^{in\omega t}</script><script type="math/tex; mode=display">={1\over T}\sum_{n=-\infty}^{+\infty}\int_{t_0}^{t_0+T}f(t)e^{-in\omega t}dt·e^{in\omega t} \qquad (6)</script><script type="math/tex; mode=display">注：当n=0时，{1\over T}\int_{t_0}^{t_0+T}f(t)e^{-in\omega t}dt·e^{in\omega t}={1\over T}\int_{t_0}^{t_0+T}f(t)dt</script><h2 id="傅里叶变换-1"><a href="#傅里叶变换-1" class="headerlink" title="傅里叶变换"></a>傅里叶变换</h2><p>傅里叶级数只能处理周期函数，傅里叶变换可以处理非周期函数。</p><p>仔细研究6式 , ω角频率是2π/T的简写，是常量，当周期无穷大时，ω无穷小，而从频率的角度看一大堆正余弦函数，nω是一个变量表示不同的频率：</p><p>令</p><script type="math/tex; mode=display">\omega_x={2\pi\over N}·n \quad(N\rightarrow+\infty,N∈Z)</script><script type="math/tex; mode=display">F(\omega_x)=\int_{t_0}^{t_0+T}f(t)e^{-i\omega_xt}dt</script><p>有</p><script type="math/tex; mode=display">f(t)={1\over T}\sum_{n=-\infty}^{+\infty}\int_{t_0}^{t_0+T}f(t)e^{-in\omega t}dt·e^{in\omega t}</script><script type="math/tex; mode=display">={1\over T}\sum_{n=-\infty}^{n=\infty}[F(\omega_x)·e^{i\omega_xt}]</script><p>根据积分表达式的黎曼和表达式</p><script type="math/tex; mode=display">\int_a^bf(x)dx=\lim_{h->0}\sum_{n=0}^{(b-a)/h}f(a+n·h)·h</script><script type="math/tex; mode=display">{1\over T}\sum_{n=-\infty}^{n=\infty}[F(\omega_x)·e^{i\omega_xt}]={N\over 2\pi·T}\sum_{n=-\infty}^{n=+\infty}[F(\omega_x)·e^{i\omega_xt}·{2\pi\over N}]</script><script type="math/tex; mode=display">={N\over 2\pi·T}\int_{-\infty}^{+\infty}F(\omega_x)·e^{i\omega_xt}·{2\pi\over N}d\omega_x</script><p>令T-&gt;N，即可得到一个标准的傅里叶变换公式：</p><script type="math/tex; mode=display">f(t)={1\over2\pi}\int_{-\infty}^{+\infty}F(\omega_x)e^{i\omega_xt}d\omega_x \qquad (7)</script><p>其中</p><script type="math/tex; mode=display">F(\omega_x)=\int_{t_0}^{t_0+T}f(t)e^{-i\omega_xt}dt \qquad(8)</script><p>已知f(t),我们可以通过8式从时域函数f(t)中摘出频率ωn即ωx，得到频域函数的值F(ωx)</p><p>通过7式将频域函数F(ωx)原成原来的时域信号f(t)。</p><h2 id="傅里叶变换分析"><a href="#傅里叶变换分析" class="headerlink" title="傅里叶变换分析"></a>傅里叶变换分析</h2><p><img src="/2021/11/08/%E7%89%B9%E5%BE%81%E5%87%BD%E6%95%B0/image-20220101232650405.png" alt="image-20220101232650405"></p><p>傅里叶变换，把一个信号拆成一大堆不同频率的正弦信号，实部为振幅，虚部为相位。</p><p>傅里叶逆变换，把一大堆正弦信号逆变回原来的信号。</p><h2 id="对于傅里叶级数和傅里叶变换中实部和虚部-复数-的理解"><a href="#对于傅里叶级数和傅里叶变换中实部和虚部-复数-的理解" class="headerlink" title="对于傅里叶级数和傅里叶变换中实部和虚部(复数)的理解"></a>对于傅里叶级数和傅里叶变换中实部和虚部(复数)的理解</h2><p>To Do</p><h2 id="特征函数是概率密度函数f-x-的共轭傅里叶变换"><a href="#特征函数是概率密度函数f-x-的共轭傅里叶变换" class="headerlink" title="特征函数是概率密度函数f(x)的共轭傅里叶变换"></a>特征函数是概率密度函数f(x)的共轭傅里叶变换</h2><h2 id="特征函数相当于换了一个坐标系"><a href="#特征函数相当于换了一个坐标系" class="headerlink" title="特征函数相当于换了一个坐标系"></a>特征函数相当于换了一个坐标系</h2><p><img src="/2021/11/08/%E7%89%B9%E5%BE%81%E5%87%BD%E6%95%B0/image-20220102000335510.png" alt="image-20220102000335510"></p><p><img src="/2021/11/08/%E7%89%B9%E5%BE%81%E5%87%BD%E6%95%B0/image-20220102000515487.png" alt="image-20220102000515487"></p><h1 id="特征函数的好处"><a href="#特征函数的好处" class="headerlink" title="特征函数的好处"></a>特征函数的好处</h1><p><img src="/2021/11/08/%E7%89%B9%E5%BE%81%E5%87%BD%E6%95%B0/image-20220102000439130.png" alt="image-20220102000439130"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>力</title>
      <link href="/2021/11/08/%E5%8A%9B/"/>
      <url>/2021/11/08/%E5%8A%9B/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 力 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>信号发射器</title>
      <link href="/2021/11/08/%E4%BF%A1%E5%8F%B7%E5%8F%91%E5%B0%84%E5%99%A8/"/>
      <url>/2021/11/08/%E4%BF%A1%E5%8F%B7%E5%8F%91%E5%B0%84%E5%99%A8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 电 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++的引用</title>
      <link href="/2021/11/07/%E5%BC%95%E7%94%A8/"/>
      <url>/2021/11/07/%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="写在前面的话："><a href="#写在前面的话：" class="headerlink" title="写在前面的话："></a>写在前面的话：</h1><p>&emsp;&emsp;<strong>rbp一般保存栈基址，rsp一般保存栈顶地址，rax一般用作保存返回值，rdi一般用作传一个参数</strong></p><p>&emsp;&emsp;<strong>rbp，rsp的值进入不同函数后是发生改变的</strong></p><p>&emsp;&emsp;<strong>使用gdb的layout regs方式进行汇编代码的调试</strong></p><h1 id="实验的结论是"><a href="#实验的结论是" class="headerlink" title="实验的结论是"></a>实验的结论是</h1><p><strong>这样理解：每个函数都有一个返回变量，放在rax寄存器中，而不要用返回值来称呼返回的东西。</strong></p><p><strong>type&amp; 引用类型的变量：存放了赋值语句右边的type类型变量的地址，①在赋值时当作type变量使用，②在做形参时传地址(type*)，实参是存放这个地址的type&amp;引用变量，③在做返回变量时其实也就是赋值(某变量赋值给返回变量，返回变量赋值给接受变量)。</strong></p><p>type&amp;作为函数的返回类型，相当于把rax寄存器作为引用变量使用，存放了return语句右边type类型变量的type*地址，当做type类型变量使用。</p><p>使用type变量接收type&amp;返回变量，type&amp;返回变量当做type类型的变量使用，即把返回变量的type值赋值给type接收变量。即把return语句右边的type类型变量赋值给type类型接收变量。</p><p>使用type&amp;变量接收type&amp;返回变量，type&amp;返回变量当做type类型的变量使用，接收变量存放返回变量的地址，可以当做type类型变量使用。即体type&amp;接收变量，存放return语句右边的type类型变量的地址，并当做type类型变量使用。</p><p><strong>对象实际上就是栈上的几个成员变量，函数都在代码区</strong>。</p><p><strong>当把返回对象直接赋值给接收对象时，只需要在局部函数中执行一次构造函数</strong></p><p><strong>除了调用构造函数外，与普通变量的引用并无什么差别</strong></p><h1 id="普通变量的引用类型"><a href="#普通变量的引用类型" class="headerlink" title="普通变量的引用类型"></a>普通变量的引用类型</h1><h2 id="main函数中，int赋值给int"><a href="#main函数中，int赋值给int" class="headerlink" title="main函数中，int赋值给int"></a>main函数中，int赋值给int</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = a;</span><br><span class="line">        <span class="comment">//int c[20] = &#123;0&#125;;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/11/07/%E5%BC%95%E7%94%A8/1.png" alt="1.png"></p><p>-0x8(%rbp)存放a的值，-0x4(%rbp)存放b的值。</p><p>注：只有ab变量时，没有sub rsp的操作，a,b在栈顶之外，加上c[20]数组后才有sub rsp的操作。</p><h2 id="main函数中，int赋值给int-amp"><a href="#main函数中，int赋值给int-amp" class="headerlink" title="main函数中，int赋值给int&amp;"></a>main函数中，int赋值给int&amp;</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; b = a;</span><br><span class="line">a = <span class="number">3</span>; </span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/11/07/%E5%BC%95%E7%94%A8/2.png" alt="2"></p><p>-0x14(%rbp)存放变量a的值，-0x10(%rbp)存放b的值，为变量a的地址。</p><h2 id="其它函数中-形参为引用类型"><a href="#其它函数中-形参为引用类型" class="headerlink" title="其它函数中,形参为引用类型"></a>其它函数中,形参为引用类型</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>&amp; c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        c = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>&amp; b = a;</span><br><span class="line">        <span class="built_in">f</span>(b);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/11/07/%E5%BC%95%E7%94%A8/3.png" alt="3"></p><p>-0x14(%rbp)存放变量a的值，-0x10(%rbp)存放变量b的值，为变量a的地址。变量a的地址存放到rdi，作为参数传给函数f。</p><p><img src="/2021/11/07/%E5%BC%95%E7%94%A8/4.png" alt="4"></p><p>-0x8(%rbp)存放变量c的值，为变量a的地址，将该地址上的值变为3。我们看到，函数f()获得了main函数中变量的指针。我们再来看一下void f(int*)的反汇编代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>* c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        *c = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> *b = &amp;a;</span><br><span class="line">        <span class="built_in">f</span>(b);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/11/07/%E5%BC%95%E7%94%A8/5.png" alt="5"></p><p><img src="/2021/11/07/%E5%BC%95%E7%94%A8/6.png" alt="6"></p><p>和传指针的汇编代码，执行的操作是一样的。</p><h2 id="其它函数中-返回类型为引用类型"><a href="#其它函数中-返回类型为引用类型" class="headerlink" title="其它函数中,返回类型为引用类型"></a>其它函数中,返回类型为引用类型</h2><h3 id="return-局部变量"><a href="#return-局部变量" class="headerlink" title="return 局部变量"></a>return 局部变量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">f</span><span class="params">(<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        b = b+<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="built_in">f</span>(a);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>报错：</p><p><img src="/2021/11/07/%E5%BC%95%E7%94%A8/image-20211107155329342.png" alt="image-20211107155329342"></p><p><img src="/2021/11/07/%E5%BC%95%E7%94%A8/image-20211107160841526.png" alt="image-20211107160841526"></p><p>gdb调试查看汇编</p><p><img src="/2021/11/07/%E5%BC%95%E7%94%A8/image-20211107161603255.png" alt="image-20211107161603255"></p><p>main函数，-0x8(%rbp)存放a变量，赋值为1，传给rdi寄存器(edi是rdi的低32位)。</p><p><img src="/2021/11/07/%E5%BC%95%E7%94%A8/image-20211107162450323.png" alt="image-20211107162450323"></p><p>f()中，-0x4(%rbp)存放变量b，b赋值为1+2，将0放入rax寄存器(eax是rax的低32位)。</p><p><img src="/2021/11/07/%E5%BC%95%E7%94%A8/image-20211107162822226.png" alt="image-20211107162822226"></p><p>返回main函数，mov (%rax), %eax的意思是：将以rax寄存器的值指向的内容，放入到rax寄存器(给eax赋值会改变整个rax)中。执行该句后，报错，显然是因为rax里的值是0的缘故：</p><p><img src="/2021/11/07/%E5%BC%95%E7%94%A8/image-20211107162939823.png" alt="image-20211107162939823"></p><p>段错误，访问了不该访问的内存！</p><p><strong>结论：不可将局部变量作为引用类型返回！</strong></p><hr><h3 id="return-堆上空间的值"><a href="#return-堆上空间的值" class="headerlink" title="return 堆上空间的值"></a>return 堆上空间的值</h3><h4 id="将int-amp-类型的返回值赋值给int类型的变量"><a href="#将int-amp-类型的返回值赋值给int类型的变量" class="headerlink" title="将int&amp;类型的返回值赋值给int类型的变量"></a>将int&amp;类型的返回值赋值给int类型的变量</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">f</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>* b =(<span class="keyword">int</span>*) <span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br><span class="line">        *b = a+<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> *b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="built_in">f</span>(a);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/11/07/%E5%BC%95%E7%94%A8/image-20211107170640916.png" alt="image-20211107170640916"></p><p>main函数中，-0x8(%rip)存放了变量a，rdi寄存器保存变量a的值1，进入f()</p><p><img src="/2021/11/07/%E5%BC%95%E7%94%A8/image-20211107171606010.png" alt="image-20211107171606010"></p><p>f()函数中，-0x14(%rbp)存放值1，rdi赋值为4作为malloc的参数，调用malloc函数。</p><p>malloc函数返回后，rax已经存放了堆上的地址，-0x8(%rbp)存放int<em> b变量，将堆上地址赋值给int</em> b变量。</p><p>lea 0x2(%rax),%eax, 表示将0x3指向的空间的地址，也就是0x3赋值给rax寄存器，将0x3放入int* b指向的空间。</p><p>返回值是堆上空间的地址。</p><p><img src="/2021/11/07/%E5%BC%95%E7%94%A8/image-20211107170333419.png" alt="image-20211107170333419"></p><p>返回main函数，%rax存放了堆上空间的地址，-0x4(%rip)存放了变量c，将堆上空间的值放入-0x4(%rip)。</p><p><strong>问题：</strong>返回main后，没有变量可以指代堆上空间的地址，也就无法释放掉堆上空间</p><p>如果再返回main前，释放掉b指向的空间，我们来看看汇编：</p><p><img src="/2021/11/07/%E5%BC%95%E7%94%A8/image-20211107173119809.png" alt="image-20211107173119809"></p><p>在f()中调用free(b)，再return *b;</p><p><img src="/2021/11/07/%E5%BC%95%E7%94%A8/image-20211107173330061.png" alt="image-20211107173330061"></p><p>堆上空间的值，已经被free(b)清零了。<img src="/2021/11/07/%E5%BC%95%E7%94%A8/image-20211107173438290.png" alt="image-20211107173438290"></p><p>最后把值0返回给了c，这不是我们想要的结果！</p><p><strong>结论：将堆上空间的值作为引用类型返回给int变量，实际上是先返回堆上空间的地址，再将堆上空间的值赋值给rax寄存器，rax寄存器再赋值给变量。</strong></p><p><strong>但是由于不再有变量指代堆上空间，程序将不能释放这个堆上空间，导致这部分堆上空间在程序的剩余执行时间内，不再可用，浪费掉了！这叫做内存泄漏。</strong></p><p><strong>而在返回前释放堆上空间，会导致堆上空间清零，虽然返回了堆上空间地址，但赋值给rax寄存器的值是错误的！</strong></p><hr><h4 id="将int-amp-类型的返回值赋值给int-amp-类型的变量"><a href="#将int-amp-类型的返回值赋值给int-amp-类型的变量" class="headerlink" title="将int&amp;类型的返回值赋值给int&amp;类型的变量"></a>将int&amp;类型的返回值赋值给int&amp;类型的变量</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">f</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>* b =(<span class="keyword">int</span>*) <span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br><span class="line">        *b = a+<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> *b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>&amp; c = <span class="built_in">f</span>(a);</span><br><span class="line">        c = <span class="number">3</span>;</span><br><span class="line">        <span class="built_in">free</span>(&amp;c);</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/11/07/%E5%BC%95%E7%94%A8/image-20211107175503044.png" alt="image-20211107175503044"></p><p>从f()返回main后，-0x8(%rbp)存放c变量的值，将堆上空间的值放入了c变量中</p><p><img src="/2021/11/07/%E5%BC%95%E7%94%A8/image-20211107180018364.png" alt="image-20211107180018364"></p><p>c作为堆上空间值的引用，存放了堆上空间的地址，赋值给c时，将值存放到了堆上空间，free(&amp;c)也的确释放了堆上空间。</p><p><strong>结论：将堆上空间的值作为引用类型返回给int&amp;变量，从汇编的角度看c存放了*b的地址，从C++的角度看，c和*b一样，是有着堆上空间地址的int变量。可以通过free(&amp;c)释放掉堆上空间。</strong></p><hr><h3 id="return-堆上空间的地址"><a href="#return-堆上空间的地址" class="headerlink" title="return 堆上空间的地址"></a>return 堆上空间的地址</h3><p><img src="/2021/11/07/%E5%BC%95%E7%94%A8/image-20211107180713880.png" alt="image-20211107180713880"></p><p>报错，编译不通过。看来使用int&amp;作为返回类型，必须return int类型的变量</p><hr><h2 id="返回全局变量"><a href="#返回全局变量" class="headerlink" title="返回全局变量"></a>返回全局变量</h2><h3 id="将int-amp-类型的返回值赋值给int类型的变量-1"><a href="#将int-amp-类型的返回值赋值给int类型的变量-1" class="headerlink" title="将int&amp;类型的返回值赋值给int类型的变量"></a>将int&amp;类型的返回值赋值给int类型的变量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        i = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="built_in">f</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/11/07/%E5%BC%95%E7%94%A8/image-20211107194634919.png" alt="image-20211107194634919"></p><p>在f()中，全局变量int i的地址放入了rax寄存器中</p><p><img src="/2021/11/07/%E5%BC%95%E7%94%A8/image-20211107194833278.png" alt="image-20211107194833278"></p><p>将rax存放的地址指向的值，赋值给int类型的接收变量</p><hr><h3 id="将int-amp-类型的返回值赋值给int-amp-类型的变量-1"><a href="#将int-amp-类型的返回值赋值给int-amp-类型的变量-1" class="headerlink" title="将int&amp;类型的返回值赋值给int&amp;类型的变量"></a>将int&amp;类型的返回值赋值给int&amp;类型的变量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        i = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>&amp; a = <span class="built_in">f</span>();</span><br><span class="line">        a = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/11/07/%E5%BC%95%E7%94%A8/image-20211107195403884.png" alt="image-20211107195403884"></p><p>在f()中，同样将全局变量int i的地址放入了rax寄存器中</p><p><img src="/2021/11/07/%E5%BC%95%E7%94%A8/image-20211107195518061.png" alt="image-20211107195518061"></p><p>int&amp;类型的接收变量a，存放了rax寄存器中的地址，在a=3的执行中，表现的像int类型变量一样，将3赋值给了地址指向的空间，我们知道这个地址就是全局变量i的地址，所以它也改变了i。</p><hr><h1 id="类的引用类型"><a href="#类的引用类型" class="headerlink" title="类的引用类型"></a>类的引用类型</h1><h2 id="main函数中，创建类A的实例"><a href="#main函数中，创建类A的实例" class="headerlink" title="main函数中，创建类A的实例"></a>main函数中，创建类A的实例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">A</span>(<span class="keyword">int</span> b)&#123;a = b;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="function">A <span class="title">a1</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/11/07/%E5%BC%95%E7%94%A8/image-20211107204851274.png" alt="image-20211107204851274"></p><p>进入main后，再进入A的构造函数A()，在A中初始化类A的成员变量，A a1创建的对象，成员变量在栈上。A a1 = new A创建的对象，成员变量在堆上。所有函数都存放在内存的代码区中。</p><h2 id="main函数中，类A的对象赋值给类A的对象"><a href="#main函数中，类A的对象赋值给类A的对象" class="headerlink" title="main函数中，类A的对象赋值给类A的对象"></a>main函数中，类A的对象赋值给类A的对象</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">A</span>(<span class="keyword">int</span> b)&#123;a=b;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="function">A <span class="title">a1</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">        <span class="function">A <span class="title">a2</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">        a1 = a2;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/11/07/%E5%BC%95%E7%94%A8/image-20211107214336672.png" alt="image-20211107214336672"></p><p>对象a1的成员变量存放在0x7fffffffdf80，即-0x10(%rbp)处，对象a2的成员变量存放在0x7fffffffdf84，即-0xc(%rbp)处，对象的赋值，就是把a2的成员变量赋值给a1的成员变量。</p><p>A类有两个成员变量也是一样的操作：只不过这次移动了64位</p><p><img src="/2021/11/07/%E5%BC%95%E7%94%A8/image-20211107215714204.png" alt="image-20211107215714204"></p><p>A类有3个成员变量也是一样的操作：只不过分64位，32位各移动了一次</p><p><img src="/2021/11/07/%E5%BC%95%E7%94%A8/image-20211107220125398.png" alt="image-20211107220125398"></p><h2 id="main函数中，A赋值给A-amp"><a href="#main函数中，A赋值给A-amp" class="headerlink" title="main函数中，A赋值给A&amp;"></a>main函数中，A赋值给A&amp;</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">A</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;</span><br><span class="line">                _a = a;</span><br><span class="line">                _b = b;</span><br><span class="line">        &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> _a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> _b = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="function">A <span class="title">a1</span><span class="params">(<span class="number">2</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">        A&amp; a2 = a1;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/11/07/%E5%BC%95%E7%94%A8/image-20211107220546454.png" alt="image-20211107220546454"></p><p>-0x10(%rbp)存放对象a1，-0x18(%rbp)存放对象a2，把对象a1的地址，赋值给了对象a2。 </p><h2 id="成员函数中，形参为引用类型"><a href="#成员函数中，形参为引用类型" class="headerlink" title="成员函数中，形参为引用类型"></a>成员函数中，形参为引用类型</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">A</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;</span><br><span class="line">                _a = a;</span><br><span class="line">                _b = b;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">A</span>(A&amp; a)&#123;</span><br><span class="line">                _a = a._a;</span><br><span class="line">                _b = a._b;</span><br><span class="line">        &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> _a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> _b = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="function">A <span class="title">a</span><span class="params">(<span class="number">2</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">        <span class="function">A <span class="title">b</span><span class="params">(a)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/11/07/%E5%BC%95%E7%94%A8/image-20211107221844365.png" alt="image-20211107221844365"></p><p>main函数中，进入A()构造对象a，将对象a的地址存放到寄存器rdi中，进入成员函数A(A&amp;)</p><p><img src="/2021/11/07/%E5%BC%95%E7%94%A8/image-20211107222503560.png" alt="image-20211107222503560"></p><p>借助传入的对象a的地址，将对象a的值赋值给对象b。</p><h2 id="成员函数中，返回类型为类类型"><a href="#成员函数中，返回类型为类类型" class="headerlink" title="成员函数中，返回类型为类类型"></a>成员函数中，返回类型为类类型</h2><h3 id="main函数先构造对象b再接受返回变量，f-返回构造好的对象；"><a href="#main函数先构造对象b再接受返回变量，f-返回构造好的对象；" class="headerlink" title="main函数先构造对象b再接受返回变量，f()返回构造好的对象；"></a>main函数先构造对象b再接受返回变量，f()返回构造好的对象；</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类A有2个整型成员变量</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">A</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span><br><span class="line">        &#123;</span><br><span class="line">                _a = a;</span><br><span class="line">                _b = b;</span><br><span class="line">        &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> _a;</span><br><span class="line">        <span class="keyword">int</span> _b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="function">A <span class="title">a</span><span class="params">(<span class="number">2</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="function">A <span class="title">b</span><span class="params">(<span class="number">1</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line">        b = <span class="built_in">f</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入main()，进入A()构造对象b，进入f()，进入A()构造对象a，返回f()，将对象a的两个成员变量值放入rax寄存器中，返回main()，将rax寄存器中的值赋值给对象b。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类A有3个int型成员变量</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">A</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span><br><span class="line">        &#123;</span><br><span class="line">                _a = a;</span><br><span class="line">                _b = b;</span><br><span class="line">                _c = c;</span><br><span class="line">        &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> _a;</span><br><span class="line">        <span class="keyword">int</span> _b;</span><br><span class="line">        <span class="keyword">int</span> _c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="function">A <span class="title">a</span><span class="params">(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="function">A <span class="title">b</span><span class="params">(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line">        b = <span class="built_in">f</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入main()，进入A()构造对象b，进入f()，进入A()构造对象a，返回f()，<strong>将对象a的三个成员变量值拷贝一份(属实迷惑到我了，5 个整型变量又不拷贝一份了)</strong>，将拷贝后的值放入rax(64位)和rcx(32位)寄存器中，返回main()，将rax和rcx寄存器中的值赋值给对象b。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类A有一个数量为5的int型数组</span></span><br><span class="line"><span class="keyword">int</span> aarray[<span class="number">5</span>] = &#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> barray[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">A</span>(<span class="keyword">int</span>* a)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=<span class="number">4</span>; i++)</span><br><span class="line">                        _a[i] = a[i];</span><br><span class="line">        &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> _a[<span class="number">5</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="function">A <span class="title">a</span><span class="params">(aarray)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function">A <span class="title">b</span><span class="params">(barray)</span></span>;</span><br><span class="line">        b = <span class="built_in">f</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/11/07/%E5%BC%95%E7%94%A8/image-20211107233517399.png" alt="image-20211107233517399"></p><p>进入main()，进入A()构造对象b，进入f()，进入A()构造对象a，返回f()，将对象a的地址赋值给rax寄存器，返回main()，借助rax，rbx寄存器将对象a的数组值拷贝给对象b的数组。</p><p><strong>将类A改成有5个整型成员变量，也是一样的操作，借助rax，rbx寄存器将对象a的值，拷贝给对象b的数组</strong></p><h3 id="f-直接返回构造函数"><a href="#f-直接返回构造函数" class="headerlink" title="f()直接返回构造函数"></a>f()直接返回构造函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">A</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span><br><span class="line">        &#123;</span><br><span class="line">                _a = a;</span><br><span class="line">                _b = b;</span><br><span class="line">        &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> _a;</span><br><span class="line">        <span class="keyword">int</span> _b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">A</span>(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="function">A <span class="title">b</span><span class="params">(<span class="number">1</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line">        b = <span class="built_in">f</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入main()，进入A()构造对象b，进入f()，进入A()构造对象a，返回f()，将对象a的两个成员变量值放入rax寄存器中，返回main()，将rax寄存器中的值赋值给对象b。<strong>与1无区别</strong></p><h3 id="main函数直接用f-的返回变量构造对象b"><a href="#main函数直接用f-的返回变量构造对象b" class="headerlink" title="main函数直接用f()的返回变量构造对象b"></a>main函数直接用f()的返回变量构造对象b</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">A</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span><br><span class="line">        &#123;</span><br><span class="line">                _a = a;</span><br><span class="line">                _b = b;</span><br><span class="line">        &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> _a;</span><br><span class="line">        <span class="keyword">int</span> _b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="function">A <span class="title">a</span><span class="params">(<span class="number">2</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        A b = <span class="built_in">f</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入main()，进入f()，进入A()构造对象，返回f()，将对象的两个成员变量值放入rax寄存器中，返回main()，将rax寄存器中的值赋值给对象b。<strong>相比1，少调用一次构造函数构造b</strong></p><h3 id="main函数直接用f-的返回变量构造对象b，f-直接返回构造函数"><a href="#main函数直接用f-的返回变量构造对象b，f-直接返回构造函数" class="headerlink" title="main函数直接用f()的返回变量构造对象b，f()直接返回构造函数"></a>main函数直接用f()的返回变量构造对象b，f()直接返回构造函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">A</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span><br><span class="line">        &#123;</span><br><span class="line">                _a = a;</span><br><span class="line">                _b = b;</span><br><span class="line">        &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> _a;</span><br><span class="line">        <span class="keyword">int</span> _b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">A</span>(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        A b = <span class="built_in">f</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>同3，相比1，少调用一次构造函数构造b</strong></p><h2 id="成员函数中，返回类型为引用类型"><a href="#成员函数中，返回类型为引用类型" class="headerlink" title="成员函数中，返回类型为引用类型"></a>成员函数中，返回类型为引用类型</h2><h3 id="return-局部变量-1"><a href="#return-局部变量-1" class="headerlink" title="return 局部变量"></a>return 局部变量</h3><p><img src="/2021/11/07/%E5%BC%95%E7%94%A8/image-20211108002331594.png" alt="image-20211108002331594"></p><p>同样不能返回局部对象，通不过编译</p><h3 id="return-堆上对象"><a href="#return-堆上对象" class="headerlink" title="return 堆上对象"></a>return 堆上对象</h3><h4 id="接收变量为类型A"><a href="#接收变量为类型A" class="headerlink" title="接收变量为类型A"></a>接收变量为类型A</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">A</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span><br><span class="line">        &#123;</span><br><span class="line">                _a = a;</span><br><span class="line">                _b = b;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> _a;</span><br><span class="line">        <span class="keyword">int</span> _b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A&amp; <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *(<span class="keyword">new</span> <span class="built_in">A</span>(<span class="number">1</span>,<span class="number">1</span>));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        A b = <span class="built_in">f</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/11/07/%E5%BC%95%E7%94%A8/image-20211108003228999-16363027511231.png" alt="image-20211108003228999"></p><p>进入f()，new一个8字节(类A实例的大小)的空间，进入A()构造对象，将对象的地址放到rax寄存器中，返回f()，返回main()</p><p><img src="/2021/11/07/%E5%BC%95%E7%94%A8/image-20211108003633970.png" alt="image-20211108003633970"></p><p>借助构造对象的地址，将对象的值，存放到对象b中，<strong>然后丢失new的地址</strong>。</p><h4 id="接受变量为类型A-amp"><a href="#接受变量为类型A-amp" class="headerlink" title="接受变量为类型A&amp;"></a>接受变量为类型A&amp;</h4><p><img src="/2021/11/07/%E5%BC%95%E7%94%A8/image-20211108003907226.png" alt="image-20211108003907226"></p><p>将对象的地址，存放到对象b中。</p><h3 id="return-全局对象"><a href="#return-全局对象" class="headerlink" title="return 全局对象"></a>return 全局对象</h3><p>崩看了，所有分析都与普通变量无二。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HandleImage</title>
      <link href="/2021/11/06/HandleImage/"/>
      <url>/2021/11/06/HandleImage/</url>
      
        <content type="html"><![CDATA[<h1 id="这篇博文讲解了本地图片的路径设置"><a href="#这篇博文讲解了本地图片的路径设置" class="headerlink" title="这篇博文讲解了本地图片的路径设置"></a>这篇博文讲解了本地图片的路径设置</h1><p><a href="https://blog.csdn.net/m0_43401436/article/details/107191688">(32条消息) hexo博客中插入图片失败——解决思路及个人最终解决办法_m0_43401436的博客-CSDN博客</a></p><p>本地source文件夹里的md文件和图片整好后，hexo执行编译工作，在public文件夹中生成网页及图片</p><h1 id="下载插件并修改代码确实解决了问题"><a href="#下载插件并修改代码确实解决了问题" class="headerlink" title="下载插件并修改代码确实解决了问题"></a>下载插件并修改代码确实解决了问题</h1><p>安装的插件是hexo-asset-image, 将/node_modules/hexo-asset-image/index.js的代码修改为:</p><p>具体过程可以参考这篇博文<a href="https://www.cnblogs.com/cscshi/p/15196100.html">Hexo-NexT 添加图片 - chang101 - 博客园 (cnblogs.com)</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> cheerio = <span class="built_in">require</span>(<span class="string">&#x27;cheerio&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPosition</span>(<span class="params">str, m, i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.split(m, i).join(m).length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> version = <span class="built_in">String</span>(hexo.version).split(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">hexo.extend.filter.register(<span class="string">&#x27;after_post_render&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> config = hexo.config;</span><br><span class="line">  <span class="keyword">if</span>(config.post_asset_folder)&#123;</span><br><span class="line">        <span class="keyword">var</span> link = data.permalink;</span><br><span class="line">    <span class="keyword">if</span>(version.length &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">Number</span>(version[<span class="number">0</span>]) == <span class="number">3</span>)</span><br><span class="line">       <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">&#x27;/&#x27;</span>, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">       <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">&#x27;/&#x27;</span>, <span class="number">3</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.</span></span><br><span class="line">    <span class="keyword">var</span> endPos = link.lastIndexOf(<span class="string">&#x27;/&#x27;</span>) + <span class="number">1</span>;</span><br><span class="line">    link = link.substring(beginPos, endPos);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> toprocess = [<span class="string">&#x27;excerpt&#x27;</span>, <span class="string">&#x27;more&#x27;</span>, <span class="string">&#x27;content&#x27;</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; toprocess.length; i++)&#123;</span><br><span class="line">      <span class="keyword">var</span> key = toprocess[i];</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">var</span> $ = cheerio.load(data[key], &#123;</span><br><span class="line">        <span class="attr">ignoreWhitespace</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">xmlMode</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">lowerCaseTags</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">decodeEntities</span>: <span class="literal">false</span></span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      $(<span class="string">&#x27;img&#x27;</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ($(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>))&#123;</span><br><span class="line">            <span class="comment">// For windows style path, we replace &#x27;\&#x27; to &#x27;/&#x27;.</span></span><br><span class="line">            <span class="keyword">var</span> src = $(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>).replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span>(!<span class="regexp">/http[s]*.*|\/\/.*/</span>.test(src) &amp;&amp;</span><br><span class="line">               !<span class="regexp">/^\s*\//</span>.test(src)) &#123;</span><br><span class="line">              <span class="comment">// For &quot;about&quot; page, the first part of &quot;src&quot; can&#x27;t be removed.</span></span><br><span class="line">              <span class="comment">// In addition, to support multi-level local directory.</span></span><br><span class="line">              <span class="keyword">var</span> linkArray = link.split(<span class="string">&#x27;/&#x27;</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">              &#125;);</span><br><span class="line">              <span class="keyword">var</span> srcArray = src.split(<span class="string">&#x27;/&#x27;</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span> &amp;&amp; elem != <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">              &#125;);</span><br><span class="line">              <span class="keyword">if</span>(srcArray.length &gt; <span class="number">1</span>)</span><br><span class="line">                srcArray.shift();</span><br><span class="line">              src = srcArray.join(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">              $(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>, config.root + link + src);</span><br><span class="line">              <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">&quot;update link as:--&gt;&quot;</span>+config.root + link + src);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">&quot;no src attr, skipped...&quot;</span>);</span><br><span class="line">            <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info($(<span class="built_in">this</span>));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      data[key] = $.html();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="持久化文章url后，出现了新的问题"><a href="#持久化文章url后，出现了新的问题" class="headerlink" title="持久化文章url后，出现了新的问题"></a>持久化文章url后，出现了新的问题</h1><p>&emsp;&emsp;本博客参考了系列视频<a href="https://space.bilibili.com/13282871/video">卷二兔的个人空间_哔哩哔哩_bilibili</a>制作，作者使用了持久化文章url的技术。        </p><p>&emsp;&emsp;持久化文章url-uniform resource locator-同一资源定位符，是为了文章更好地被搜索引擎收录(需要不少配置)，生成简单且不随标题而改变的url。</p><p>&emsp;&emsp;<strong>但是！使用abbrlink持久化文章链接名称后，图片路径在本地没问题，部署到github后，其html网页中的图片路径会出新问题。</strong></p><p>&emsp;&emsp;试图看index.js在干嘛，无果，于是怕麻烦的我取消了持久化，回到了美好的从前。</p><h1 id="可以使用图床"><a href="#可以使用图床" class="headerlink" title="可以使用图床"></a>可以使用图床</h1><p>&emsp;&emsp;本博客参考了系列视频<a href="https://space.bilibili.com/13282871/video">卷二兔的个人空间_哔哩哔哩_bilibili</a>制作，其中提到了图床技术，将所有图片上传到github上的图床仓库，这样本地md文件和生成的网页中，图片的地址就都是网上图片了，从而不用考虑文件结构的变化。理论上，使用图床，就可以解决持久化url的问题。</p><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>访问github并不容易</span></div>    <div class="hide-content"><p>&emsp;&emsp;可是访问github并不容易，需要处理域名污染(查真实ip地址来改hosts，防止dns-domain name server-域名服务器返回错误的ip地址)，需要vpn(加密请求的ip地址，使其符合路由节点的入站规则，拿到东西了再在本机上解密)。</p><p>&emsp;&emsp;然而网页和图片都在github的服务器上，所以要么都能访问到，要么都访问不到，所以真要搞一个基于github的博客，这样搞还是挺好的。</p><p>&emsp;&emsp;但是我只是想有一个记录自己所思所想的博客，觉得本地搞好方便，省去了搞ip的麻烦，果然还是回退到二吧。</p></div></div><p>&emsp;&emsp;其实根本原因还是不知道hexo是怎么把source中的md文件和图片生成为pulic中的网页和图片的，要是我知道用什么语法改哪个配置文件，就能自己设置两者的对应关系了。</p>]]></content>
      
      
      <categories>
          
          <category> blog in hexo+github </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>通用测量单位</title>
      <link href="/2021/11/03/%E9%80%9A%E7%94%A8%E6%B5%8B%E9%87%8F%E5%8D%95%E4%BD%8D/"/>
      <url>/2021/11/03/%E9%80%9A%E7%94%A8%E6%B5%8B%E9%87%8F%E5%8D%95%E4%BD%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h1><p>一秒到底是多久？一米到底是多长？一克到底是多重？……？</p><p>没有统一的标准，就无法观测和记录世间的一切客观属性。把很多个相同的东西作为1，才有了2,3,4,5,6…</p><p>那么，我们习以为常的观测单位是怎么产生的呢？又是如何去测量客观事物某种属性的呢？</p><h1 id="国际单位制"><a href="#国际单位制" class="headerlink" title="国际单位制"></a>国际单位制</h1><p>&emsp;&emsp;国际单位制（法语：Système International d’Unités ，缩写：SI）是国际计量大会采纳和推荐的单位标准。国际单位制是国际通用的测量标准，是人类描述和定义世间万物的标尺。</p><div class="table-container"><table><thead><tr><th style="text-align:center">物的属性</th><th style="text-align:center">基本单位</th></tr></thead><tbody><tr><td style="text-align:center">时间</td><td style="text-align:center">秒(second)</td></tr><tr><td style="text-align:center">长度</td><td style="text-align:center">米</td></tr><tr><td style="text-align:center">质量</td><td style="text-align:center">千克</td></tr><tr><td style="text-align:center">电流</td><td style="text-align:center">安培</td></tr><tr><td style="text-align:center">温度</td><td style="text-align:center">开尔文</td></tr><tr><td style="text-align:center">物质的量</td><td style="text-align:center">摩尔</td></tr><tr><td style="text-align:center">发光强度</td><td style="text-align:center">坎德拉</td></tr></tbody></table></div><h2 id="时间：一秒到底是多久？"><a href="#时间：一秒到底是多久？" class="headerlink" title="时间：一秒到底是多久？"></a>时间：一秒到底是多久？</h2><p>&emsp;&emsp;时间是其中最抽象的概念，不像长短，重量给人的直观感受，人是通过周围事物的改变，通过太阳升起又落下，树木枯萎又抽芽，温度冷转冷又转热，朱颜辞镜花辞树，才感觉到：事物在一刻不停地改变着。有一种不可阻挡，永不回头，完全不可控的力量，推动着万物的改变。人称此力为时，时如川，裹挟着落花，不停地向前流动。</p><p>&emsp;&emsp;人觉得有必要记录重要的事物特征，顺应天时以求更好地过活，于是根据事物重要特征的出现，确定了重要的<strong>时点</strong>：如日出之时，日落之时。根据时点的间隔又定义了原始的<strong>时间单位</strong>，时间这个词总结的真是好，意思就是时点的间隔：如一日。从而又产生了新的时点和时间单位：如月缺之日，月圆之日，一月，温暖之月，寒冷之月，一季等。</p><p>&emsp;&emsp;一开始，人类确定了重要的时点，随之产生了时间单位的概念（日，月，年等），接着，人类试图<strong>用规律变化的工具来人造更小的时间单位</strong>。然后再用人造的小时间单位重新定义日，月，天这样大的时间单位。</p><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>古老的计时工具</span></div>    <div class="hide-content"><p>运用自然物质和简单物理原理来计时</p><p><img src="/2021/11/03/%E9%80%9A%E7%94%A8%E6%B5%8B%E9%87%8F%E5%8D%95%E4%BD%8D/fed0faca79b740aa9676d782d24f0cc8.jpeg" alt="img"></p><p>水钟也叫漏刻，以水的流动计时</p><p><img src="/2021/11/03/%E9%80%9A%E7%94%A8%E6%B5%8B%E9%87%8F%E5%8D%95%E4%BD%8D/9cffe790183c4eaab13c1e71e915a5bd.gif" alt="img"></p><p>沙漏计时器，以沙的流动计时</p><p><img src="/2021/11/03/%E9%80%9A%E7%94%A8%E6%B5%8B%E9%87%8F%E5%8D%95%E4%BD%8D/866571d17fae47ceb1c8f054dc33f729.jpg" alt="img"></p><p>古代计时器——日晷，立杆成影的成语即来源于此，借助太阳的位置变化，光的直线传播计时</p><p><img src="/2021/11/03/%E9%80%9A%E7%94%A8%E6%B5%8B%E9%87%8F%E5%8D%95%E4%BD%8D/56d058943da347efa022bbc40df141bc.jpeg" alt="img"></p><p>1090年，北宋发明</p><p>水运仪象台（现代复建），是世界上的钟表鼻祖，具有天文观测，天文演示，自动报时功能。</p></div></div><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>伽利略发现了摆的等时性</span></div>    <div class="hide-content"><p>&emsp;&emsp;据说,有一次伽利略到教堂作礼拜,礼拜开始不久,一位工人给教堂中的大吊灯添加灯油时,不经意触动了吊灯,使它来回摆动。摆动着的大吊灯映入了伽利略的眼帘,引起他的注意。伽利略聚精会神地观察着,他感觉到吊灯来回摆动的时间好像是相等的。</p><p>&emsp;&emsp;伽利略知道人的<strong>脉搏是均匀跳动</strong>(将中指食指无名指轻压在手腕偏里侧，轻轻默念鼓动的次数，直观感觉上你也会认为脉搏是两次跳动是没有区别的)的,于是,他利用自己的脉搏计时,同时数着吊灯的摆动次数。起初,吊灯在摆动的幅度比较大,摆动速度也比较大,伽利略测算了来回摆动一次的时间。过了一会儿,吊灯摆动的幅度变小了,摆动速度也变慢了,此时,他又测量了吊灯来回摆动一次的时间。让他大为吃惊的是,两次测量的时间是相同的。于是伽利略继续测量来回摆动一次的时间,直到吊灯几乎停止摆动时才结束。可是每次测量的结果都表明来回摆动一次需要相同的时间。通过这些测量使伽利略发现:吊灯来回摆动一次需要的时间 与摆动幅度的大小无关,无论摆幅大小如何,来回摆动一次所需时间是相同的,也就是说吊灯的摆动具有等时性,或者说具有周期性。</p><p>&emsp;&emsp; 伽利略是一位十分认真又喜欢研究问题的人,根本不会满足只从一次实验中得到的结果。对于自然现象,他总是反复进行实验研究,探索其中蕴藏的奥秘。他想,吊灯摆动的快慢(也称为摆动的周期)可能跟哪些因素有关呢? 通过在教堂中的观察,伽利略已经知道,摆动的周期跟摆动幅度无关。他猜想,是否跟吊灯的轻重有关呢?是否跟吊绳的长短有关呢?还有没有其他因素呢? 为了模拟吊灯的摆动,他找来丝线、细绳、大小不同的木球、铁球、石块、铜球等实验材料,用细绳的一端系上小球,将另一端系在天花板上,这样就做成了一个摆。用这套装置,伽利略继续测量探索摆动的周期。他先用铜球实验,又分别换用铁球和木球实验。实验使伽利略看到,无论用铜球、铁球,还是木球实验,只要摆长不变,来回摆动一次所用时间就相同。这表明单摆的摆动周期与摆球的质量无关。伽利略又做了十几个摆长不同的摆,逐个测量它们的周期。实验表明:<strong>摆长越长,周期也越长,摆动得就越慢</strong>。</p><p>&emsp;&emsp;<strong>现在我们有了更小的时之间隔单位，脉搏两次跳动之间的时间，各种长度的单摆摆动一次的时间</strong>。</p></div></div><p>再后来出现了晶振，机械表升级成为电子表，对时间间隔的定义也精确到了微秒级。</p><p>后来通过研究电子跃迁，发明了原子钟。精度可以达到几十万年一秒的误差。</p><p>再后来研究相对论，这些就脱离了日常生活，接触不到了，故不谈。</p><h1 id="长度：一米到底是多长？"><a href="#长度：一米到底是多长？" class="headerlink" title="长度：一米到底是多长？"></a>长度：一米到底是多长？</h1><p> 一根木棍</p><p>法国子午线的十万分之一</p><p>氪原子能级跃迁释放的电磁波的波长</p><p>光速</p><h1 id="质量：一千克到底是多重？"><a href="#质量：一千克到底是多重？" class="headerlink" title="质量：一千克到底是多重？"></a>质量：一千克到底是多重？</h1><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>弹簧测力计</span></div>    <div class="hide-content"><p>加同等小砝码，观察弹簧形变，形变等长</p></div></div><h1 id="电流？"><a href="#电流？" class="headerlink" title="电流？"></a>电流？</h1><p>视频：<a href="https://www.youtube.com/watch?v=dnSy1COwy5I">https://www.youtube.com/watch?v=dnSy1COwy5I</a></p><p>闪电</p><p>玳瑁的壳做的首饰，经过摩擦之后就会吸引一些小东西</p><p>磁石可以吸铁，琥珀经过摩擦之后也可以吸引小东西，electrica希腊语里表示琥珀</p><p>摩擦制造静电</p><p>存储电的装置，莱顿瓶，最早的电容器。</p><p>用闪电给莱顿瓶充电</p><p>电是由于物质具有的电荷产生的现象</p><p>正电荷，负电荷</p><p>电是可以传播的</p><p>静电力满足库伦定律</p><p>安培是电流强度的基本单位，电流强度表示单位时间内通过某一个截面的电荷量</p><p>1安培的大小，析出银，力定义安培</p><p>发现电子，可以测量出一个基本电荷量，可以定义库伦</p><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>摩擦起电</span></div>    <div class="hide-content"></div></div><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>莱顿瓶</span></div>    <div class="hide-content"></div></div><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>富兰克林风筝实验</span></div>    <div class="hide-content"></div></div><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>静电力-库仑定律</span></div>    <div class="hide-content"></div></div><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>安培</span></div>    <div class="hide-content"></div></div><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>电子</span></div>    <div class="hide-content"></div></div><h1 id="温度：一度到底是多热？"><a href="#温度：一度到底是多热？" class="headerlink" title="温度：一度到底是多热？"></a>温度：一度到底是多热？</h1><p>&emsp;&emsp;一开始温度也是靠感觉判断的。寒夜里，生个火堆很温暖。大冷天，泡个热水澡很舒服。衣服多穿很暖和。人们感觉到，有一种热能(使东西热的某种物质)在所有东西里都有，会被冷的东西取走，被热的东西给予。</p><p>&emsp;&emsp;怎么给这种冷热的感觉加一个通用测量标准？</p><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>伽利略的温度计</span></div>    <div class="hide-content"><p>讲解温度计发展的文章：<a href="https://www.163.com/dy/article/FFJPEGEO0511DDSV.html">https://www.163.com/dy/article/FFJPEGEO0511DDSV.html</a></p><p>水温度计的小试验：<a href="https://www.youtube.com/watch?v=cdtWgaXExDw">https://www.youtube.com/watch?v=cdtWgaXExDw</a></p><p>&emsp;&emsp;1592年的一天，意大利物理学家和数学家伽利略正在威尼斯的帕多瓦大学讲课，边讲边做加热水的实验。</p><p>&emsp;&emsp;“罐内水温升高的时候，为什么水面会上升？”伽利略问学生。</p><p>&emsp;&emsp;“因为水温升高的时候体积增大，水面就上升；水温下降的时候体积减小，水面就下降。”学生回答说。</p><p>&emsp;&emsp;听到学生的回答，伽利略偶然联想到此前遇到的一个问题。</p><p>&emsp;&emsp;原来，曾有一些医生找过伽利略，恳求他说：“先生，人生病的时候体温一般会升高，能不能想个办法，准确测出体温，帮助诊断病情呢？”</p><p>&emsp;&emsp;联想到这一问题，伽利略就在学生回答的启发下，利用热胀冷缩原理，经多次研制，于1593年发明了泡状玻璃管温度计。这个温度计的顶端是一个玻璃泡，玻璃管和它相连，倒置在装有水的杯子中来测量温度。它的工作原理是，<strong>当被测温度的物质与玻璃泡接触的时候，玻璃管内上方的空气就会因为热胀冷缩而发生体积变化，使有色液柱对应下降或上升</strong>；玻璃管上标明一些可作标准的“热度”——现在所说的温度。这就是世界上第一支标有刻度的温度计——气体温度计。</p><p><img src="/2021/11/03/%E9%80%9A%E7%94%A8%E6%B5%8B%E9%87%8F%E5%8D%95%E4%BD%8D/image-20211117155921009.png" alt="image-20211117155921009"></p></div></div><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>温度计的改进，等长度划分温度点</span></div>    <div class="hide-content"><p>气体温度计，玻璃管太长，蛇状</p><p>液体温度计，装置倒置，用水的热胀冷缩反映温度(上面那个小实验的做法)；密闭玻璃管口防止液体蒸发。</p><p>固体温度计…</p></div></div><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>理论温度</span></div>    <div class="hide-content"><p>开氏温标的特点是，与物体的任何性质无关，热力学温度只与热量有关。开氏温标的优点是，不受测温物质的影响，解除了测温物质因为凝固和汽化而受到的限制。</p></div></div><h1 id="物质的量"><a href="#物质的量" class="headerlink" title="物质的量"></a>物质的量</h1><p>&emsp;&emsp;物质的量是表示物质所含微粒数(N)（如：分子，原子等）与<a href="https://baike.baidu.com/item/阿伏加德罗常数/867715">阿伏加德罗常数</a>(NA)之比，即n=N/NA。阿伏伽德罗常数的数值约为0.012kg ¹²C所含碳原子的个数，为6.02214076×10²³。它是把一定数目的<a href="https://baike.baidu.com/item/微观粒子/1125264">微观粒子</a>与可称量的宏观物质联系起来的一种物理量。</p><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>怎么观测微粒？</span></div>    <div class="hide-content"></div></div><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>阿伏伽德罗常数？</span></div>    <div class="hide-content"></div></div><h1 id="发光强度"><a href="#发光强度" class="headerlink" title="发光强度"></a>发光强度</h1><p>视频：<a href="https://www.youtube.com/watch?v=q93igRffczI">https://www.youtube.com/watch?v=q93igRffczI</a></p><p>朗伯，人看到的亮度和距离的平方成反比。</p><p>物体本身的亮度叫做发光强度，也叫光度，我们看到的亮度叫做亮度。</p><p>一支蜡烛的发光强度当做单位1，单位就叫做candle(蜡烛)坎德尔。</p><p>一磅鲸脑油制成6支蜡烛，调整灯芯，使每秒燃烧120格令，(约7.78g)</p><p>把白炽灯的平均发光强度定义为1国际烛光</p><p>用以区分，单位名改为拉丁文的蜡烛(candela)坎德拉</p><p>处于金属铂凝固点温度下的<strong>黑体？</strong>，每平方厘米的发光强度为60烛光。</p><p><strong>光的本质是电磁波？</strong>，人体主观感受和实际电磁波<strong>辐射强度？</strong>不同，测量出一个主观的光度函数，明视觉函数，暗视觉函数。</p><p>辐射强度经光度函数作用后就是发光强度。</p>]]></content>
      
      
      <categories>
          
          <category> 基石 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
