<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计算机中的数值</title>
      <link href="/2021/11/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E6%95%B0%E5%80%BC/"/>
      <url>/2021/11/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E6%95%B0%E5%80%BC/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>套接字网络编程</title>
      <link href="/2021/11/12/%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
      <url>/2021/11/12/%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>（服务器IP地址+端口号，客户机ip地址+端口号）唯一指定一个连接</p><h1 id="建立链接"><a href="#建立链接" class="headerlink" title="建立链接"></a>建立链接</h1><h2 id="服务器程序"><a href="#服务器程序" class="headerlink" title="服务器程序"></a>服务器程序</h2><p>listenq，维护两个数组</p><p>accept</p><h2 id="客户端程序"><a href="#客户端程序" class="headerlink" title="客户端程序"></a>客户端程序</h2><p>connect</p><h1 id="同步读写"><a href="#同步读写" class="headerlink" title="同步读写"></a>同步读写</h1><p>服务器程序读，写，…，</p><p>客户程序写，读，…，关闭。</p><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p>同时服务多个客户</p><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>节省了创建和销毁线程的开销</p><h1 id="异步读写"><a href="#异步读写" class="headerlink" title="异步读写"></a>异步读写</h1><p>读，写不再等待，不能就立刻返回</p><h1 id="IO复用之epoll"><a href="#IO复用之epoll" class="headerlink" title="IO复用之epoll"></a>IO复用之epoll</h1><p>监听链接，读，写</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何用电存储和传输数据</title>
      <link href="/2021/11/10/%E5%A6%82%E4%BD%95%E7%94%A8%E7%94%B5%E5%AD%98%E5%82%A8%E5%92%8C%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE/"/>
      <url>/2021/11/10/%E5%A6%82%E4%BD%95%E7%94%A8%E7%94%B5%E5%AD%98%E5%82%A8%E5%92%8C%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 电 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>自然常数e</title>
      <link href="/2021/11/08/%E8%87%AA%E7%84%B6%E5%B8%B8%E6%95%B0e/"/>
      <url>/2021/11/08/%E8%87%AA%E7%84%B6%E5%B8%B8%E6%95%B0e/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 数 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>随机变量的矩</title>
      <link href="/2021/11/08/%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E7%9F%A9/"/>
      <url>/2021/11/08/%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E7%9F%A9/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 数 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>映射</title>
      <link href="/2021/11/08/%E6%98%A0%E5%B0%84/"/>
      <url>/2021/11/08/%E6%98%A0%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h1 id="从定义域到值域"><a href="#从定义域到值域" class="headerlink" title="从定义域到值域"></a>从定义域到值域</h1><p><strong>定义域</strong>：原始值的集合，比如几个学生的姓名{小明，小王，小张}</p><p><strong>值域</strong>：目标值的集合，比如几个学生的学号{1,2,3}</p><p><strong>映射</strong>：(原始值,目标值)对的集合，反映从定义域的某个值变成某个值的对应关系，比如学生和学号的对应关系{(1,小明)，(2,小王)，(3,小张)}</p><p><strong>函数</strong>：一个函数，是从一个映射(对应关系)产生的一种作用，称学生姓名小王在函数<strong>学号=将学生姓名变成学号作用(姓名)</strong>(简称函数f)的作用下，变成了2。称在这种作用中，学生姓名为自变量(因)，称学号为因变量(果)。</p><p>&emsp;&emsp;函数一词的由来(老实说，改成作用更好)：函数，最早由中国清朝数学家李善兰翻译，出于其著作《代数学》。之所以这么翻译，他给出的原因是“凡此变数中函彼变数者，则此为彼之函数”，也即函数指一个量随着另一个量的变化而变化，或者说一个量中包含另一个量。<strong>从中可以看出，函数是指代因变量，表示因变量是含有自变量的变数，故而我们常称在作用y=5x中，y是x的一个函数</strong></p><h1 id="经典的映射"><a href="#经典的映射" class="headerlink" title="经典的映射"></a>经典的映射</h1><h2 id="指数"><a href="#指数" class="headerlink" title="指数"></a>指数</h2><h2 id="对数"><a href="#对数" class="headerlink" title="对数"></a>对数</h2><h2 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h2><p><strong>……</strong></p>]]></content>
      
      
      <categories>
          
          <category> 数 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>加减乘除</title>
      <link href="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/"/>
      <url>/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="1-9"><a href="#1-9" class="headerlink" title="1-9"></a>1-9</h1><div style="float:left;border:solid 1px 000;margin:2px;height:30;width:30;"><img src="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/001EFA2D.png" width="48" height="48"></div><p>记为1，</p><br><div style="float:left;border:solid 1px 000;margin:2px;height:30;width:30;"><img src="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/001EFA2D.png" width="48" height="48"></div><div style="float:left;border:solid 1px 000;margin:2px;height:30;width:30;"><img src="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/001EFA2D.png" width="48" height="48"></div><p>记为2，</p><br><div style="float:left;border:solid 1px 000;margin:2px;height:30;width:30;"><img src="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/001EFA2D.png" width="48" height="48"></div><div style="float:left;border:solid 1px 000;margin:2px;height:30;width:30;"><img src="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/001EFA2D.png" width="48" height="48"></div><div style="float:left;border:solid 1px 000;margin:2px;height:30;width:30;"><img src="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/001EFA2D.png" width="48" height="48"></div><p>记为3,</p><br><p><strong>…</strong></p><div style="float:left;border:solid 1px 000;margin:2px;height:30;width:30;"><img src="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/001EFA2D.png" width="48" height="48"></div><div style="float:left;border:solid 1px 000;margin:2px;height:30;width:30;"><img src="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/001EFA2D.png" width="48" height="48"></div><div style="float:left;border:solid 1px 000;margin:2px;height:30;width:30;"><img src="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/001EFA2D.png" width="48" height="48"></div><div style="float:left;border:solid 1px 000;margin:2px;height:30;width:30;"><img src="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/001EFA2D.png" width="48" height="48"></div><div style="float:left;border:solid 1px 000;margin:2px;height:30;width:30;"><img src="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/001EFA2D.png" width="48" height="48"></div><div style="float:left;border:solid 1px 000;margin:2px;height:30;width:30;"><img src="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/001EFA2D.png" width="48" height="48"></div><div style="float:left;border:solid 1px 000;margin:2px;height:30;width:30;"><img src="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/001EFA2D.png" width="48" height="48"></div><div style="float:left;border:solid 1px 000;margin:2px;height:30;width:30;"><img src="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/001EFA2D.png" width="48" height="48"></div><div style="float:left;border:solid 1px 000;margin:2px;height:30;width:30;"><img src="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/001EFA2D.png" width="48" height="48"></div><p>记为9</p><br><p><strong>十进制，当低位有十个苹果时，低位清零，进1到高位：</strong></p><div style="float:left;border:solid 1px 000;margin:2px;height:30;width:30;"><img src="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/001EFA2D.png" width="48" height="48"></div><div style="float:left;border:solid 1px 000;margin:2px;height:30;width:30;"><img src="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/001EFA2D.png" width="48" height="48"></div><div style="float:left;border:solid 1px 000;margin:2px;height:30;width:30;"><img src="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/001EFA2D.png" width="48" height="48"></div><div style="float:left;border:solid 1px 000;margin:2px;height:30;width:30;"><img src="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/001EFA2D.png" width="48" height="48"></div><div style="float:left;border:solid 1px 000;margin:2px;height:30;width:30;"><img src="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/001EFA2D.png" width="48" height="48"></div><div style="float:left;border:solid 1px 000;margin:2px;height:30;width:30;"><img src="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/001EFA2D.png" width="48" height="48"></div><div style="float:left;border:solid 1px 000;margin:2px;height:30;width:30;"><img src="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/001EFA2D.png" width="48" height="48"></div><div style="float:left;border:solid 1px 000;margin:2px;height:30;width:30;"><img src="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/001EFA2D.png" width="48" height="48"></div><div style="float:left;border:solid 1px 000;margin:2px;height:30;width:30;"><img src="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/001EFA2D.png" width="48" height="48"></div><div style="float:left;border:solid 1px 000;margin:2px;height:30;width:30;"><img src="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/001EFA2D.png" width="48" height="48"></div><p>记为10</p><br><div style="float:left;border:solid 1px 000;margin:2px;height:30;width:30;"><img src="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/001EFA2D.png" width="48" height="48"></div><div style="float:left;border:solid 1px 000;margin:2px;height:30;width:30;"><img src="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/001EFA2D.png" width="48" height="48"></div><div style="float:left;border:solid 1px 000;margin:2px;height:30;width:30;"><img src="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/001EFA2D.png" width="48" height="48"></div><div style="float:left;border:solid 1px 000;margin:2px;height:30;width:30;"><img src="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/001EFA2D.png" width="48" height="48"></div><div style="float:left;border:solid 1px 000;margin:2px;height:30;width:30;"><img src="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/001EFA2D.png" width="48" height="48"></div><div style="float:left;border:solid 1px 000;margin:2px;height:30;width:30;"><img src="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/001EFA2D.png" width="48" height="48"></div><div style="float:left;border:solid 1px 000;margin:2px;height:30;width:30;"><img src="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/001EFA2D.png" width="48" height="48"></div><div style="float:left;border:solid 1px 000;margin:2px;height:30;width:30;"><img src="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/001EFA2D.png" width="48" height="48"></div><div style="float:left;border:solid 1px 000;margin:2px;height:30;width:30;"><img src="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/001EFA2D.png" width="48" height="48"></div><div style="float:left;border:solid 1px 000;margin:2px;height:30;width:30;"><img src="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/001EFA2D.png" width="48" height="48"></div><div style="float:left;border:solid 1px 000;margin:2px;height:30;width:30;"><img src="/2021/11/08/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/001EFA2D.png" width="48" height="48"></div><p>记为11</p><p><br><strong>…</strong></p><p><strong>数字简化了有关数量的表述</strong></p><h1 id="加"><a href="#加" class="headerlink" title="加+"></a>加+</h1><p>1个苹果+1个苹果= 2个苹果</p><p>1个苹果+9个苹果 = 10个苹果</p><p>5个苹果+6个苹果 = 11个苹果</p><p><strong>加法规则可以对两批已知数量的苹果，计算总数</strong></p><h1 id="减"><a href="#减" class="headerlink" title="减-"></a>减-</h1><p>1个苹果-1个苹果 = 0个苹果</p><p>12个苹果-2个苹果 = 10个苹果</p><p><strong>减法规则是加法规则的变形，可以将一批苹果，分成两批</strong></p><h1 id="乘×"><a href="#乘×" class="headerlink" title="乘×"></a>乘×</h1><p>2个苹果×3份 = 2+2+2个苹果 = 6个苹果</p><p>4个苹果×11份 = 4+4+4+4+4+4+4+4+4+4+4个苹果 = 44个苹果</p><p><strong>乘法规则基于加法规则得来，可以快速计算多批等数量苹果的总数</strong></p><h1 id="除÷"><a href="#除÷" class="headerlink" title="除÷"></a>除÷</h1><p>6个苹果÷3份 = 2个苹果</p><p>44个苹果÷4个苹果 = 11份</p><p><strong>除法规则是乘法规则的变形，可以快速将一批苹果分成多批等数量的苹果</strong></p>]]></content>
      
      
      <categories>
          
          <category> 数 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>眼睛是怎么看到东西的？</title>
      <link href="/2021/11/08/%E7%9C%BC%E7%9D%9B%E6%98%AF%E6%80%8E%E4%B9%88%E7%9C%8B%E5%88%B0%E4%B8%9C%E8%A5%BF%E7%9A%84%EF%BC%9F/"/>
      <url>/2021/11/08/%E7%9C%BC%E7%9D%9B%E6%98%AF%E6%80%8E%E4%B9%88%E7%9C%8B%E5%88%B0%E4%B8%9C%E8%A5%BF%E7%9A%84%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 光 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>malloc</title>
      <link href="/2021/11/08/malloc/"/>
      <url>/2021/11/08/malloc/</url>
      
        <content type="html"><![CDATA[<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>Randal E. Bryant, David R. O’Hallaron. Computer Systems A Programmer’s Perspective. ISBN: 978-1-488-67207-1. 第十章 虚拟存储器</p><h1 id="背景知识-虚拟主存"><a href="#背景知识-虚拟主存" class="headerlink" title="背景知识 虚拟主存"></a>背景知识 虚拟主存</h1><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>前言</span></div>    <div class="hide-content"><p>&emsp;&emsp;<strong>时钟信号在不停地产生，CPU在不停地执行指令，总线在不停的传递数据，内核也只是从一开始就执行的程序，中断也只是改了rip让CPU执行中断处理程序</strong>。</p><p>&emsp;&emsp;<strong>磁盘-&gt;进程的虚拟主存-&gt;物理主存。主存映射mmap将磁盘文件和虚拟页关联起来，地址翻译硬件和页表将虚拟页放入到物理主存中，交换文件将页在物理主存和磁盘之间换来换去</strong></p><p>&emsp;&emsp;<strong>使用主存时遇到的问题：</strong>系统中的所有进程都共享主存(memory)资源，如果太多的进程需要太多的主存，就会有一些倒霉蛋进程因为<strong>主存空间不够</strong>而无法继续运行。此外，如果某个进程不小心<strong>写了另一个进程正在使用的主存空间</strong>，另一个进程可能以非常迷惑的方式失败。</p><p>&emsp;&emsp;<strong>虚拟主存的意义：</strong>为了有效地管理主存，并且少出错，现代系统提供了一种对主存的抽象概念，叫做虚拟主存(virtual memory)。虚拟主存为每个进程提供了一个大的、一致的、私有的地址空间。虚拟主存提供了三个重要的能力：①它将主存看成是一个高速缓存，缓存磁盘上的空间。②在主存中保存进程的活动区域。③并根据需要在磁盘和主存之间来回传送数据。通过这种方式，它高效使用了主存；为每个进程提供了一致的地址空间，从而简化了存储器管理；它保护了每个进程的地址空间不被其他进程破坏。虚拟主存是硬件异常，硬件地址翻译，主存，磁盘文件和内核的完美交互。</p><p>&emsp;&emsp;虚拟主存是计算机系统中最重要的概念之一。为什么程序员要理解它？</p><ul><li>虚拟主存是中心的。虚拟主存涉及计算机的所有层面，在硬件机场、汇编器、链接器、加载器、共享对象、文件和进程的设计中扮演着重要角色。理解虚拟存储器将帮助你更好地理解系统通常是如何工作的。</li></ul><ul><li>虚拟主存是强大的。虚拟主存给予应用程序强大的能力，可以创建和删除主存块，将主存块映射到磁盘文件的某个部分，以及与其他进程共享主存。比如，你知道你可以通过读写主存位置读或者修改一个磁盘文件的内容吗？或者是你可以加在一个文件的内容到主存中，而不需要进行任何显示地拷贝吗？</li></ul><ul><li>虚拟主存是危险的。每次应用程序引用一个变量、间接引用一个指针，或者调用一个诸如malloc这样的动态分配包程序时，它就会和虚拟主存发生交互。</li></ul><p>&emsp;&emsp;这一章从两个角度来讨论虚拟主存。前一部分描述虚拟主存是如何工作的，后一部分描述应用程序如何使用和管理虚拟主存。</p></div></div><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>10.1 物理和虚拟寻址</span></div>    <div class="hide-content"><p>&emsp;&emsp;<strong>主存的物理结构和物理寻址：</strong>计算机系统的主存被组织成一个由M个连续的字节大小的单元组成的数组。每字节都有一个唯一的物理地址(physical address, PA)。对于这种主存结构，CPU访问主存最自然的方式就是使用物理地址，我们称这种方式为物理寻址(physical addressing)。下图展示了一个物理寻址的例子，此时CPU正在执行一条加载指令，读取从物理地址4处开始的字。</p><p><img src="/2021/11/08/malloc/image-20211109183726847.png" alt="image-20211109183726847"></p><p>&emsp;&emsp;当CPU执行这条加载指令时，它会生成一个有效的物理地址，通过存储器总线，把它传递给主存。主存取出从物理地址4处开始的4字节的字，返回给CPU, CPU会将它存放在一个就差你器里。</p><p>&emsp;&emsp;<strong>虚拟寻址：</strong>早期的PC使用物理寻址，而且诸如数字信号处理器、嵌入式微控制器以及Cray超级计算机这样的系统仍然继续使用这种寻址方式。然而，为通用计算设计的现代处理器使用的是虚拟寻址(virtual addressing)。</p><p><img src="/2021/11/08/malloc/image-20211109184247542.png" alt="image-20211109184247542"></p><p>&emsp;&emsp;根据虚拟寻址，CPU通过生成一个虚拟地址(virtual address, VA)访问主存，这个虚拟地址在被送到主存之前被转换成物理地址。将一个虚拟地址转换为物理地址的任务叫做地址翻译(address translation)。CPU芯片上叫做MMU(memory management unit，主存管理单元)的专用硬件，利用存放在主存中的查询表来动态翻译虚拟地址，该表的内容由操作系统管理。</p></div></div><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>10.2 地址空间</span></div>    <div class="hide-content"><p>&emsp;&emsp; <strong>地址空间</strong>(address space)是一个非负整数地址的有序集合:{0, 1, 2, … }</p><p>&emsp;&emsp;如果地址空间中的整数是连续的，那么我们说它是一个<strong>线性地址空间</strong>(linear address space)。</p><p>&emsp;&emsp;在一个带虚拟主存的系统中，CPU从一个有N=2^n个地址的地址空间中生成虚拟地址，这个地址空间称为<strong>虚拟地址空间</strong>(virtual address space): {0, 1, 2, …, N-1}</p><p>&emsp;&emsp;一个地址空间，可以由表示最大地址所需要的位数来描述。例如，一个包含N=2^n个地址的虚拟地址空间就叫做一个n位地址空间。现代系统一般都支持32位或64位虚拟地址空间。</p><p>&emsp;&emsp;一个系统中海油一个<strong>物理地址空间</strong>(physical address space)，它与系统中物理主存的M个字节相对应: {0, 1, 2, …, M-1}</p><p>&emsp;&emsp;如此，我们能够清楚地区分数据对象(字节)和它们的属性(地址)，在使用虚拟主存的系统中，每个数据对象既有一个选自虚拟地址空间的虚拟地址，还有一个选自物理地址空间的物理地址。</p></div></div><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>10.3 主存作为虚拟主存的缓存</span></div>    <div class="hide-content"><p>&emsp;&emsp;<strong>虚拟主存</strong>被组织为存放在磁盘上的N个连续的字节大小的单元组成的数组。每个字节都有一个唯一的虚拟地址。磁盘上数组的内容被缓存在主存中。和存储器层次结构中其他缓存一样，磁盘(较低层)上的数据被分割成块，这些块作为磁盘和主存(较高层)之间的传输单元。虚拟主存系统将虚拟主存分割为称为<strong>虚拟页</strong>(virtual page,VP)的大小固定的块，物理主存被分割为<strong>物理页</strong>(physical page,PP)。页的大小一般为4KB。</p><p>&emsp;&emsp;任意时间点，虚拟页由3部分不相交的子集构成：</p><ul><li><strong>未分配的虚拟页</strong>：虚拟主存系统还未分配的页。未分配的页不与任何数据关联，不占用任何磁盘空间。</li><li><strong>已分配未缓存的虚拟页</strong>：没有缓存在物理主存中的已分配页。</li><li><strong>已缓存的虚拟页</strong>：当前缓存在物理主存中的已分配页。</li></ul><p>&emsp;&emsp;下图展示了一个有8个虚拟页的虚拟主存。虚拟页0、3还没有分配，磁盘上还不存在。虚拟页1、4、6被缓存在物理主存中，页2、5、7已经被分配了，但是当前并为缓存在主存中。</p><p><img src="/2021/11/08/malloc/image-20211110142235210.png" alt="image-20211110142235210"></p><p><strong>10.3.1 高速缓存的组织结构</strong></p><p>&emsp;&emsp;使用术语<strong>SRAM缓存</strong>来表示位于CPU和物理主存之间的L1和L2高速缓存，使用术语<strong>DRAM缓存</strong>来表示虚拟主存系统的缓存:物理主存。DRAM比SRAM慢10倍，磁盘比DRAM慢100000多倍。因此DRAM缓存的不命中(miss)比起SRAM的不命中要昂贵的多，因为DRAM缓存不命中要有磁盘来服务，而SRAM缓存不命中由DRAM来服务。所以，DRAM缓存这种结构完全是用巨大的不命中开销换空间。</p><p><strong>10.3.2 页表</strong></p><p>&emsp;&emsp;虚拟主存系统需要判定一个虚拟页是否在物理主存中，如果在，存放在物理主存的哪个物理页中。当不命中时，虚拟页放到哪个物理页。这些功能是由许多软硬件联合提供的，包括：操作系统软件，MMU(memory management unit)中的地址翻译硬件，和一个存放在物理主存中叫做页表的数据结构。<strong>页表</strong>存放在物理主存中，将虚拟页映射到物理页。每次<strong>地址翻译硬件</strong>将一个虚拟地址转换成物理地址时，都会读取页表。<strong>操作系统</strong>负责维护页表内容，以及在磁盘与物理主存之间来回传送页。</p><p>&emsp;&emsp;下图展示了一个页表的结构。页表是一个PTE(page table entry，页表条目)的数组。虚拟地址空间中的每个页在页表中的一个固定偏移量处都有一个PTE。我们假设每个PTE是由一个有效位(valid bit)和一个n位地址字段组成的。有效位表明改虚拟页当前是否被缓存在物理主存中。如果设置了有效位，那么地址字段就表示物理主存中相应物理页的起始位置，这个物理页中缓存了该虚拟页。如果没有设置有效位，那么一个空地址表示这个虚拟页还未被分配。分则，这个地址就指向磁盘上虚拟页的起始位置。</p><p>&emsp;&emsp;下图展示了一个有8个虚拟页和4个物理页的系统的页表。四个虚拟页1、2、7已被缓存在物理主存中，两个页0、5还没分配。剩下的页3、6已被分配还未缓存。</p><p><img src="/2021/11/08/malloc/image-20211110145708890.png" alt="image-20211110145708890"></p><p><strong>10.3.3 页命中</strong></p><p>&emsp;&emsp;考虑一下当CPU读虚拟主存中的一个字时，它的地址被VP2包含，且被缓存在DRAM中，会发生什么？地址翻译硬件将虚拟地址作为一个索引，来定位PTE2，由于设置了有效位，地址翻译硬件就知道VP2已经缓存在物理主存DRAM中了，所以它使用PTE中的物理主存地址构造出这个字的物理地址。</p><p><img src="/2021/11/08/malloc/image-20211110150622783.png" alt="image-20211110150622783"></p><p><strong>10.3.4 缺页</strong></p><p>&emsp;&emsp;通常将DRAM缓存不命中称为缺页(page fault)。下图展示了在缺页之前我们的示例页表的状态。</p><p><img src="/2021/11/08/malloc/image-20211110151117891.png" alt="image-20211110151117891"></p><p>&emsp;&emsp;CPU使用了VP3中的一个字，地址翻译硬件从存储器中读取PTE3，从有效位推断出VP3未被缓存，触发一个缺页异常。</p><p>&emsp;&emsp;缺页异常调用内核中的缺页异常处理程序，该程序会选择一个牺牲页，此例中就是PP3，如果PP3中的VP4已经被修改了，内核就将VP4拷贝回磁盘。无论哪种情况，内核都会修改VP4的页表条目，反映出VP4不再缓存在主存中这一事实。</p><p>&emsp;&emsp;接下来，内核从磁盘拷贝VP3到物理主存中的PP3，更新PTE3，随后返回。当异常处理程序返回时，它会重新执行导致缺页的指令，该指令会把导致缺页的虚拟地址重新发送到地址翻译硬件。但是现在VP3已经缓存在物理主存中了，那么地址翻译硬件就能正常地将虚拟地址变成物理地址了。</p><p><img src="/2021/11/08/malloc/image-20211110151807094.png" alt="image-20211110151807094"></p><p>&emsp;&emsp;虚拟主存是在20世纪60年代早期发明的，远在SRAM之前。在虚拟主存的习惯说法中，块被称为页。在磁盘和主存之间传送页的活动叫做<strong>交换</strong>(swapping)或者<strong>页面调度</strong>(paging)。页从磁盘换入DRAM，和从DRAM换出磁盘。仅当不命中发生时，才换入页的策略被称为按需页面调度(demand paging)。其他的方法也是可能的，比如尝试着预测不命中，在页实际被引用之前就换入页。然而，所有现代系统都使用的是按需页面调度的方式。</p><p><strong>10.3.5 分配页面</strong></p><p>&emsp;&emsp;下图展示了当操作系统分配一个新的虚拟页时，对示例页表的影响，例如，调用malloc。在这个示例中，通过在磁盘上创建空间，并更新PTE5，使它指向磁盘上这个新创建的页面，从而分配VP5。<img src="/2021/11/08/malloc/image-20211110154046679.png" alt="image-20211110154046679"></p><p><strong>10.3.6 局部性再次搭救</strong></p><p>&emsp;&emsp;在了解到虚拟主存是把物理主存当做磁盘的缓存，通过页表和缺页异常将磁盘上的页放入物理主存时，我们的第一印象：不命中的惩罚辣么大，虚拟主存系统的效率一定很低。实际上虚拟主存工作的相当好，这归功于<strong>局部性</strong>(locality)。</p><p>&emsp;&emsp;尽管在整个运行过程中程序引用的所有页面大小可能超出物理主存的大小，但是程序往往趋向于在一个较小的<strong>活动页面集</strong>(active page set)上工作，这个集合叫做<strong>工作集</strong>(working set)或者<strong>常驻集合</strong>(resident set)。在初始开销，也就是将工作集中的页调入主存中后，在接下来的指令执行中，将大量命中工作集的页，而不会产生多少额外的缺页开销。这种现象称为局部性。</p><p>&emsp;&emsp;如果我们的程序有良好的局部性，虚拟主存系统就能工作得相当好。当然，不是所有的程序都有良好的局部性。如果工作集的大小超出了物理存储器的大小，那么程序将处于一种不幸的状态，叫做<strong>颠簸</strong>(thrashing)，这时页面将不断地换进换出。如果一个程序执行慢得像爬一样，那么聪明的程序员会考虑看是不是发生了颠簸。</p><p><em><strong>旁注：统计缺页次数</strong></em>：你可以用unix的getusage函数监测缺页的数量(以及许多其他的信息)。</p></div></div><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>10.4 虚拟主存作为主存管理的工具</span></div>    <div class="hide-content"><p>&emsp;&emsp;上述内容，使我们看到虚拟主存是如何用DRAM来缓存来自更大虚拟地址空间的页面。到目前为止，我们都假设有一个单独的页表，将一个虚拟地址空间映射到物理地址空间。实际上，操作系统为每个进程提供了一个独立的页表，因而每个进程都有一个独立的虚拟地址空间。下图示例中，进程i的页表将VP1映射到PP2，VP2映射到PP7。相似地，进程j的页表将VP1映射到PP67, VP2映射到PP10。注意，多个虚拟页面可以映射到同一个共享物理页上。</p><p><img src="/2021/11/08/malloc/image-20211110162016209.png" alt="image-20211110162016209"></p><p>&emsp;&emsp;按需页面调度和独立的虚拟地址空间的结合对系统中主存的使用和管理造成了深远的影响。特别的，虚拟主存简化了程序的链接和加载，共享代码和数据，以及对程序分配主存。</p><p><strong>10.4.1 简化链接</strong></p><p>&emsp;&emsp;独立的地址空间允许每个进程使用相同的结构存放如虚拟主存，而不管代码和数据实际存放在物理主存的何处。例如，每个Linux进程都使用下图所示的格式。</p><p>&emsp;&emsp;文本区总是从虚拟地址0x08048000处开始，栈总是从0xbfffffff向下伸展，共享库代码总是从地址0x40000000处开始，而操作系统代码和数据总是从0xc0000000开始。这样的一致性极大地简化了链接器的设计和实现，允许链接器生成全链接的可执行文件，这些可执行文件是独立于物理存储器中代码和数据的最终位置的。</p><p><img src="/2021/11/08/malloc/image-20211110162453991.png" alt="image-20211110162453991"></p><p><strong>10.4.2 简化共享</strong></p><p>&emsp;&emsp;独立地址空间为操作系统提供了管理进程共享的机制。一般而言，每个进程都有自己私有的代码、数据、堆以及栈区域，是不和其他进程共享的。在这种情况中，操作系统创建页表，将相应的虚拟页映射到不同的物理页面。</p><p>&emsp;&emsp;然而，有时需要进程共享代码和数据。例如，每个进程必须调用相同的操作系统内核代码，而每个C程序都会调用标准库中的程序，比如printf。操作系统通过将不同进程中适当的虚拟页面映射到的物理页面，从而使多个进程共享代码，而不是在每个进程中都包括单独的内核和C标准库的拷贝。</p><p><strong>10.4.3 简化主存分配</strong></p><p>&emsp;&emsp;当一个程序要求额外的对空间时(例如调用malloc的结果)，操作系统分配k个连续的虚拟主存页，并且将它们映射到物理主存中任意k个页。由于页表工作的方式，操作系统没有必要分配k个连续的物理主存页面。页面可以随机地分散在物理存储器中。</p><p><strong>10.4.4 简化加载</strong></p><p>&emsp;&emsp;虚拟主存也使加载可执行文件和已共享目标文件到主存中变得容易。ELF(Executable and Linkable Format)可执行文件中的.txt和.data节是相邻的。为了加载这些节到一个新创建的进程中，Linux加载程序分配了一个从地址0x08048000处开始的连续的虚拟页区域，将它们标识为无效(即未缓存)，并将它们的页表条目指向目标文件中适当的位置。</p><p>&emsp;&emsp;有趣的是，加载器从不真正地从磁盘中拷贝任何数据到主存中。当每个页面第一次被引用时，虚拟主存系统将通过缺页异常把数据从磁盘上调入到主存。</p><p>&emsp;&emsp;映射一个连续虚拟页的集合到任意一个文件中的任意一个位置，叫做主存映射(memory mapping)。Unix提供了一个叫做mmap的系统调用，允许应用程序进行主存映射。我们将在10.8节中更详细地描述应用层主存映射。</p></div></div><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>10.5 虚拟主存作为主存保护的工具</span></div>    <div class="hide-content"><p>&emsp;&emsp;任何现代计算机系统必须为操作系统提供手段来控制进程对主存的访问。不允许一个用户进程修改它的只读文本段，也不应该允许它读或修改任何内核中的代码和数据结构，不应该允许它读或写其他进程的私有主存，不允许它修改任何与其他进程共享的虚拟页面，除非所有共享者显示地允许它这么做。</p><p>&emsp;&emsp;提供独立的地址空间使得分离不同进程的私有主存变得容易。每次CPU生成一个地址时，地址翻译硬件都会读一个PTE，可以通过在PTE上添加一些额外的许可位来控制对一个虚拟页面内容的访问。</p><p><img src="/2021/11/08/malloc/image-20211110183033531.png" alt="image-20211110183033531"></p><p>&emsp;&emsp;在这个示例中，我们已经添加了三个许可位到每个PTE。SUP位表示进程是否必须运行在内核模式下才能访问该页。运行在内核模式中的进程可以访问任何页，但是运行在用户模式中的进程只允许访问那些SUP为0的页面。READ位和WRITE位控制对页面的读和写访问。例如，如果进程i运行在用户模式下，那么它有读VP0和读写VP1的权限。然而不允许它访问VP2。</p><p>&emsp;&emsp;如果一条指令违反了这些许可条件，那么CPU就触发一个一般保护屏障，执行一个内核中的异常处理程序。Unix shell将这种异常报告为”段错误(segmentation fault)”。</p></div></div><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>10.6 地址翻译</span></div>    <div class="hide-content"><p>&emsp;&emsp;这一节讲的是地址翻译的基础知识，省略了大量细节，尤其是和时钟相关的细节，虽然这些细节对硬件设计者来说是非常重要的，但是超出了我们讨论的范围。下图概括了本节使用的所有符号：</p><p><img src="/2021/11/08/malloc/image-20211110184631885.png" alt="image-20211110184631885"></p><p>&emsp;&emsp;地址翻译是一个N元素的虚拟地址空间(VAS)中的元素和一个M元素的物理地址空间(PAS)中元素的映射。</p><p>&emsp;&emsp;MAP(A) = A’ 如果虚拟地址A出的数据在PAS的物理地址A‘处</p><p>   &emsp;&emsp;&emsp;&emsp;&emsp;=∅ 如果虚拟地址A出的数据不在物理主存中</p><p>&emsp;&emsp;<strong>下图展示了MMU是如何利用页表来实现虚拟地址到物理地址的转换。</strong>CPU中的一个控制寄存器，<strong>页表基址寄存器</strong>(page table base register, PTBR)指向当前进程的页表。n位的虚拟地址包含两个部分：一个p位的VPO(virtual page offset，虚拟页面偏移)和一个(n-p)位的VPN(virtual page number，虚拟页号)。MMU利用VPN来选择适当的PTE。例如，VPN0选择PTE0, VPN1选择PTE1, 以此类推。将页表条目中的PPN(physical page number，物理页号)和虚拟地址中的VPO拼接，就得到相应的物理地址。</p><p><img src="/2021/11/08/malloc/image-20211110184736396.png" alt="image-20211110184736396"></p><p><strong>下图展示了页命中时，CPU硬件执行的步骤。</strong></p><ul><li>第一步：处理器生成一个虚拟地址，并把它传给MMU。</li><li>第二步：MMU生成PTE地址，并从高速缓存/主存请求得到它。</li><li>第三步：高速缓存/主存向MMU返回PTE。</li><li>第四步：MMU构造物理地址，并把它传送给高速缓存/主存。</li><li>第五步：高速缓存/主存返回所请求的数据字给处理器。</li></ul><p><img src="/2021/11/08/malloc/image-20211110190300518.png" alt="image-20211110190300518"></p><p><strong>缺页时，要求硬件和操作系统内核协作完成地址映射</strong></p><ul><li>第一步：处理器生成一个虚拟地址，并把它传给MMU。</li><li>第二步：MMU生成PTE地址，并从高速缓存/主存请求得到它。</li><li>第三步：高速缓存/主存向MMU返回PTE。</li><li>第四步：PTE中的有效位是0，MMU触发一次异常，执行内核中的缺页异常处理程序。</li><li>第五步：缺页处理程序找到一个物理主存中的牺牲页，如果这个页已经被修改了，就把它换出到磁盘。</li><li>第六步：缺页处理程序调入新的页面到主存，并更新主存中的PTE。</li><li>第七步：缺页处理程序返回到原来的进程，重新执行导致缺页的指令。CPU将引起缺页的虚拟地址重新发送给MMU。这次虚拟页面在主存中。MMU向高速缓存/主存请求PTE, 高速缓存/主存返回PTE, MMU构造物理地址发送给高速缓存/主存，高速缓存/主存返回所请求的数据字给CPU。</li></ul><p><img src="/2021/11/08/malloc/image-20211110191121387.png" alt="image-20211110191121387"></p><p><strong>10.6.1 结合高速缓存和虚拟主存</strong></p><p>&emsp;&emsp;在任何既使用虚拟主存又使用SRAM缓存的系统中，都有应该使用虚拟地址还是使用物理地址来访问高速缓存的问题。大多数系统选择物理寻址。使用物理寻址，多个进程同时在高速缓存中有存储块和共享来自相同虚拟页面的块成为很简单的事。而且，高速缓存无需处理保护问题，因为访问权限的检查是地址翻译的一部分。</p><p><img src="/2021/11/08/malloc/image-20211110191843187.png" alt="image-20211110191843187"></p><p><strong>10.6.2 使用TLB加速地址翻译</strong></p><p>&emsp;&emsp;每次CPU产生一个虚拟地址，MMU就必须查阅一个PTE, 以便将虚拟地址翻译为物理地址。在最糟糕的情况下，这会要求一次对存储器的额外的取数据，代价是几十到几百个周期。如果PTE碰巧缓存在L1中，那么开销就下降到1个或2个周期。然而，许多系统都试图消除这样的开销，它们在MMU中包括了一个关于PTE的小的缓存，称为TLB(translation lookaside buffer，翻译后备缓冲器)。</p><p>&emsp;&emsp;TLB是一个小的、虚拟寻址的缓存，其中每一行都保存着一个由单个PTE组成的块。用于组选择和行匹配的索引和标记字段是从虚拟地址中的虚拟页号中提取出来的(索引找到组，标记找到行)。如果TLB有T=2^t个组，那么TLB索引是由VPN的t个最低位组成的，而TLB标记是由VPN中剩余的位组成的。</p><p><img src="/2021/11/08/malloc/image-20211110193146823.png" alt="image-20211110193146823"></p><p><strong>TLB命中时，地址翻译的步骤：</strong></p><ul><li>第一步：CPU产生一个虚拟地址。</li><li>第二步和第三步：MMU从TLB中取出相应的PTE。</li><li>第四步：MMU将这个虚拟地址翻译成一个物理地址，并且将它发送到高速缓存/主存。</li><li>第五步：高速缓存/主存将所请求的数据字返回给CPU。</li></ul><p><img src="/2021/11/08/malloc/image-20211110193443627.png" alt="image-20211110193443627"></p><p><strong>当TLB不命中时，MMU必须从L1缓存中取出相应的PTE放入TLB中，可能会覆盖一个已有的条目</strong></p><p>&emsp;&emsp;如果该组有空行，则缓存入空行；如果该组中没有空行，就选择一个非空行进行替换。</p><p><img src="/2021/11/08/malloc/image-20211110193508099.png" alt="image-20211110193508099"></p><p><strong>10.6.3 多级页表</strong></p><p>&emsp;&emsp;每个进程都有一个页表，在地址空间为32位的系统中，如果每个页大小4KB，每个PTE大小4字节，则每个进程需要4M(4*2^32/2^12)B大小的页表驻留在主存中。</p><p>&emsp;&emsp;用来压缩页表的常用方法是使用层次结构。比如在一个两级页表结构中，让每个页表的大小都为4KB，每个页表就有1K个PTE。一级页表中的每个PTE指向一个二级页表，一个二级页表存放了1k个正常的PTE。所以一个一级页表的PTE相当于映射了1K个页，即1K*4KB=4MB的虚拟地址空间。一个一级页表有1K个PTE，就相当于映射了1K*4MB=4GB的虚拟地址空间到物理主存。</p><p><img src="/2021/11/08/malloc/image-20211110195246419.png" alt="image-20211110195246419"></p><p>&emsp;&emsp;这种层级页表结构节省了很多空间，如果一级页表中的一个PTE是空的，那么就没有二级页表，对于一个普通程序而言，4GB的虚拟地址空间大部分都是未分配的。只有一级页表和最经常使用的二级页表才需要缓存在主存中。</p><p>&emsp;&emsp;使用k级页表结构的地址翻译。虚拟地址被划分成了k个VPN和1个VPO。每个VPNi都是一个找到i级页表的索引，1≤i≤k。第j级页表中的每个PTE，1≤j≤k-1，都指向第j+1级的某个页表的基址。第k级页表中的每个PTE都包含某个物理页面的PPN，或者一个磁盘块的地址。为了构造物理地址，MMU必须访问k个PTE。</p><p><img src="/2021/11/08/malloc/image-20211110201809977.png" alt="image-20211110201809977"></p><p>&emsp;&emsp;访问k个PTE, 乍一看是昂贵的。然而，这里TLB能够起作用，通过将页表中不同层次上的PTE缓存起来，实际中，多级页表的地址翻译并不比单级页表慢很多。</p><p><strong>10.6.4 综合：端到端的地址翻译</strong></p><p>&emsp;&emsp;这一节，我们通过一个具体的端到端的地址翻译示例，来综合一下我们刚学过的内容。这个示例运行在有一个TLB和L1缓存的小系统上。我们假设：</p><ul><li>主存是按字节寻址的。</li><li>主存访问的字长是1字节。</li><li>虚拟地址是14位长(n=14)。</li><li>物理地址是12位长(m=12)。</li><li>页面大小是64字节(P=64)。</li><li>TLB有四组，每组4行，共16个条目。</li><li>L1缓存是物理寻址，16组，每组一行，每行大小4字节(也叫直接映射)。</li></ul><p>&emsp;&emsp;因为页面大小是64=2^6字节，所以虚拟地址和物理地址的低6位分别是VPO和PPO。虚拟地址的高8位作为VPN。物理地址的高6位作为PPN。</p><p><img src="/2021/11/08/malloc/image-20211110202649191.png" alt="image-20211110202649191"></p><p><strong>TLB、页表、L1cache某时间点的状态：</strong></p><ul><li>TLB。TLB是利用VPN的为进行虚拟寻址的。因为TLB有四个组，所以VPN的低两位就作为组索引(TLBI)。VPN中剩下的高6位作为标记(TLBT)，用来区别可能映射到同一个TLB组的不同的VPN。</li></ul><p><img src="/2021/11/08/malloc/image-20211110203159830.png" alt="image-20211110203159830"></p><ul><li>页表。这个页表是一级结构，一共有2^14/2^6=2^8个页，也就是有256个页表条目。然而我们只对开头的16个感兴趣。为了方便，我们用索引它的VPN标识每个PTE; 但要记住这些VPN并不是页表的一部分，也不在主存中。</li></ul><p><img src="/2021/11/08/malloc/image-20211110203251665.png" alt="image-20211110203251665"></p><ul><li>缓存。直接映射的缓存，是通过物理地址中的字段来寻址的。因为处理器只要4字节，而cache一行有16字节，分为4块，所以物理地址的低2位作为块偏移。因为有16组，所以接下来的4位就用来表示组索引(CI)，剩下6位作为标记(CT)。</li></ul><p><img src="/2021/11/08/malloc/image-20211110203631143.png" alt="image-20211110203631143"></p><p>&emsp;&emsp;给定了初始化设定。让我们来看看当CPU执行一条读地址0x03d4处字节的加载指令时，会发生什么？</p><p><img src="/2021/11/08/malloc/image-20211110204314000.png" alt="image-20211110204314000"></p><p>&emsp;&emsp;开始时，MMU从虚拟地址中抽出VPN(0x0f)，并且检查TLB是否缓存了PTE 0x0f的一个拷贝。TLB从VPN中抽取出TLB索引(0x3)和TLB标记(0x3)，组0x3的第二个条目中有效位匹配，命中，然后将缓存的PPN(0X0D)返回给MMU。如果TLB不命中，那么MMU就需要从主存中取出相应的PTE。</p><p>&emsp;&emsp;现在，MMU将PTE的PPN(0x0D)和来自虚拟地址的VPO(0x14)拼接起来，形成物理地址(0x354)。</p><p><img src="/2021/11/08/malloc/image-20211110205440198.png" alt="image-20211110205440198"></p><p>&emsp;&emsp;接下来，MMU将物理地址发送给缓存，缓存从物理地址中抽取出缓存偏移CO(0X0)、缓存组索引CI(0x5)以及缓存标记CT(0X0D)。组0x5中的标记与CT匹配，命中，读出在偏移量CO处的字节(0x36)，并将它返回给MMU，随后MMU将它传递会CPU。</p></div></div><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>10.7 案例研究 ：Linux主存系统</span></div>    <div class="hide-content"><p>&emsp;&emsp;Linux为每个进程维持了一个单独的虚拟地址空间。内核虚拟主存位于0xc0000000之上，包含内核中的代码和数据。内核虚拟主存的某些区域被映射到所有进程的共享物理页面。例如，每个进程共享内核的代码和全局数据结构。Linux也将一组连续的虚拟页面(大小为主存大小)映射到相应的一组连续的物理页面。这就为内核提供了一种便利的方法，来访问物理存储器中任何特定的位置。内核虚拟主存的其他区域包含每个进程都不相同的数据。示例包括页表、内核在进程的上下文中执行代码时用的栈，以及记录虚拟地址空间当前组织的各种数据结构。</p><p><img src="/2021/11/08/malloc/image-20211110215115625.png" alt="image-20211110215115625"></p><p><strong>Linux虚拟主存区域</strong></p><p>&emsp;&emsp;Linux将虚拟主存组织成一些**区域(也叫作段)**的集合。一个区域(area)是已经分配的连续虚拟页。例如代码段、数据段、堆、共享库段，以及用户栈都是不同的区域。每个已分配的虚拟页都保存在某个区域中。区域的概念允许虚拟地址空间有间隙。</p><p>&emsp;&emsp;图10.29展示了记录进程虚拟主存区域的内核数据结构。内核为每个进程维护一个单独的任务结构(task_struct)。任务结构中的元素包含或者指向内核运行该进程所需要的所有信息(例如，PID、指向用户栈的指针、可执行文件的名字，以及程序计数器)。</p><p>&emsp;&emsp;task_struct中的一个条目mm指向mm_struct, mm_struct描述了虚拟主存当前的状态。我们感兴趣的两个字段是pgd和mmap，其中pgd指向一级页表的基址，mmap指向一个vm_area_structs(区域结构)的链表，其中每个vm_area_structs都描述了当前虚拟地址空间的一个区域(area)。当内核运行这个进程时，它就将pgd存放在PDBR控制寄存器中。</p><p>&emsp;&emsp;一个区域结构(vm_area_struct)包含下面的字段：</p><ul><li>vm_start：指向这个区域的起始处。</li><li>vm_end：指向这个区域的结束处。</li><li>vm_port：描述这个区域内包含的所有页面的读写许可权限。</li><li>vm_flags：描述这个区域内的页面是否是与其他进程共享的，还是这个进程私有的(还描述了一些其他信息)。</li><li>vm_next：指向链表中下一个区域结构。</li></ul><p><img src="/2021/11/08/malloc/image-20211111103449044.png" alt="image-20211111103449044"></p><p><strong>Linux缺页异常处理</strong></p><p>&emsp;&emsp;假设MMU在试图翻译某个虚拟地址A时，触发了一个缺页。这个异常将导致CPU执行内核的缺页处理程序，处理程序执行如下步骤：</p><ol><li>&emsp;&emsp;虚拟地址A是合法的吗？换句话说，A在某个区域结构(vm_area_struct)定义的区域内吗？为了回答这个问题，缺页处理程序搜索区域结构链表，将A和每个区域结构中的vm_start和vm_end做比较。如果这个指令是不合法的，那么缺页处理程序就触发一个段错误，从而终止这个进程。这个情况在图10.30中标识为”1”。<br>&emsp;&emsp;因为一个进程可以创建任意数量的虚拟主存区域(使用下一节中描述的mmap函数)，所以顺序搜索区域结构的链表花销可能会很大。因此在实际中，Linux在链表中添加了一棵树，并在这棵树上查找。</li><li>&emsp;&emsp;试图进行的对存储器的访问是否合法？换句话说，进程是否有读或这写这个区域内页面的权限？例如，这个缺页是不是由一条试图对代码段里的只读页面进行写操作的存储指令造成的？这个缺页是不是因为一个运行在用户模式下的进程试图从内核虚拟主存中读取字造成的？如果试图进行的访问是不合法的，那么缺页处理程序会触发一个保护异常，终止这个进程。这种情况在图10.30中标识为“2”。</li><li>&emsp;&emsp;此时，内核知道了这个缺页是由于对合法的虚拟地址进行合法的操作造成的。它选择一个牺牲页面，如果这个牺牲页面被修改过，那么就将它交换出去，换入新的页面，并更新页表。当缺页处理程序返回时，CPU重新执行引起缺页的指令，这条指令将再次发送A到MMU，这一次，MMU就能正常地翻译A。</li></ol><p><img src="/2021/11/08/malloc/image-20211111110309063.png" alt="image-20211111110309063"></p></div></div><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>10.8 主存映射</span></div>    <div class="hide-content"><p>&emsp;&emsp;Linux通过将一个虚拟主存区域与一个磁盘上的对象(object)关联起来，以初始化这个虚拟主存区域的内容，这个过程称为主存映射(memory mapping)。虚拟主存区域可以映射到两种类型的对象：</p><ol><li>Unix文件系统中的普通文件：一个区域可以映射到一个普通磁盘文件(例如一个可执行目标文件)的连续部分。文件被分成页面大小的片，每一片包含一个虚拟页面的初始内容。因为按需进行页面调度，所以这些虚拟页面没有实际交换进入物理主存，直到CPU第一次引用到页面。如果区域比文件的这部分要大一些，就用0填充区域的剩下部分。</li><li>匿名文件：一个区域也可以映射到一个匿名文件，匿名文件是由内核创建的，包含的全是二进制零。CPU第一次引用这样一个区域内的虚拟页面时，内核就在物理主存中找到一个合适的牺牲页面，如果该页面被修改过，就将这个页面换出来，用二进制0覆盖牺牲页面，并更新页表，将这个页面标记为是驻留在存储器中的。注意在磁盘和主存之间并没有实际的数据传送。因为这个原因，映射到匿名文件的区域中的页面，有时也叫作二进制零的页(demand-zero page)。</li></ol><p>&emsp;&emsp;无论在那种情况，一旦一个虚拟页面被初始化了，它就在一个由内核维护的专门的<strong>交换文件</strong>(swap file)之间换来换去。交换文件也叫作交换空间或者交换区域。需要意识到很重要的一点是，任何时间点，交换空间都限制着当前运行着的程序能够分配的虚拟页面的总数。</p><p><strong>10.8.1 再看共享对象</strong></p><p>&emsp;&emsp;一个对象可以被映射到虚拟存储器的一个区域，要么作为共享对象，要么作为私有对象。如果一个进程将一个共享对象映射到它的虚拟地址空间的一个区域内，那么这个进程对这个区域的任何写操作，对于那些也把这个共享对象映射到它们虚拟主存的其他进程而言，也是可见的。而且，这些变化也会反映在磁盘上的原始对象中。</p><p>&emsp;&emsp;另一方面，对一个映射到私有对象的区域做的改变，对于其他进程来说是不可见的，并且进程对这个区域所做的任何写操作都不会反映在磁盘上的对象中。一个共享对象映射到的虚拟主存区域叫做共享区域，一个私有对象映射到主存区域叫做私有区域。</p><p>&emsp;&emsp;假设进程1将一个共享对象映射到它的虚拟主存的一个区域中，进程2将同一个共享对象也映射到它的虚拟主存中(虚拟地址不一定相同)。</p><p><img src="/2021/11/08/malloc/image-20211110213424453.png" alt="image-20211110213424453"></p><p>&emsp;&emsp;因为每个对象都有一个唯一的文件名，内核可以迅速判定进程1已经映射了这个对象，而且可以使进程2中的页表条目指向相应的物理页面。</p><p>&emsp;&emsp;私有对象使用叫做<strong>写时拷贝</strong>(copy-on-write)的巧妙技术被映射到虚拟主存中。一开始，多个进程将同一个私有对象映射到自己的虚拟主存时，在物理主存中只保存私有对象的一份拷贝。对于每个映射私有对象的进程，相应私有区域的页表条目都被标记为只读，并且区域结构被标记为私有的写时拷贝。只要没有进程试图写它自己的私有区域，它们就可以继续共享物理主存中对象的一个单独拷贝。然而，只要有一个进程试图写私有区域内的某个页面，那么这个写操作就会触发一个保护屏障。</p><p>&emsp;&emsp;当故障处理程序注意到保护异常是由于进程试图写私有的写时拷贝区域中的一个页面而引起的，他就会在物理主存中创建这个页面的一个新拷贝，更新页表条目指向这个新的拷贝，然后恢复这个页面的可写权限。当故障处理程序返回时，CPU重新执行这个写操作，现在在新创建的页面上这个写操作就可以正常执行了。</p><p>&emsp;&emsp;写时拷贝节省了稀有的物理主存。</p><p><img src="/2021/11/08/malloc/image-20211110214508298.png" alt="image-20211110214508298"></p><p><strong>10.8.2 再看fork函数</strong></p><p>&emsp;&emsp;现在，我们理解了虚拟主存和主存映射，那么我们可以清晰地知道fork函数是如何创建一个新进程的。</p><p>&emsp;&emsp;当fork函数被当前进程调用时，内核为新进程创建各种数据结构，并分配给它一个唯一的PID。为了给这个新进程创建虚拟主存，它创建了当前进程的 mm_struct、区域结构(vm_area_struct)和页表的原样拷贝。它标记两个进程中的每个页面为只读，并标记两个进程中每个区域结构为写时私有拷贝的。</p><p>&emsp;&emsp;当fork函数返回时，新进程的虚拟主存和调用fork时的虚拟主存相同。当这两个进程中的任一个后来进行写操作时，写时拷贝机制就会创建新页面并更新页表。</p><p><strong>10.8.3 再看execve函数</strong></p><p>&emsp;&emsp;虚拟主存和主存映射在将程序加载到主存的过程中扮演着关键的角色。假设运行在当前进程的程序执行了如下的execve调用：</p><p>&emsp;&emsp;Execve(“a.out”, argv, environ);</p><p>&emsp;&emsp;execve函数在当前进程中加载并运行包含在可执行目标文件a.out中的程序，用a.out程序替代当前程序。加载并运行a.out需要以下步骤：</p><ul><li>删除已存在的用户区域：删除当前进程虚拟地址的用户部分中已存在的区域结构。</li><li>映射私有区域：为新程序的文本、数据、bss和栈区域创建新的区域结构(task-&gt;mm-&gt;mmap-&gt;vm_area_structs)。所有这些新的区域都是私有的写时拷贝的。文本和数据区域被映射为a.out文件中的文本和数据区。bss区域是请求二进制零的，映射到匿名文件，其大小包含在a.out中。栈和堆区域也是请求二进制零的，初始长度为0。图10.33概括了私有区域的不同映射。</li><li>映射共享区域：如果a.out程序与共享对象链接，比如标准C库的lib.so，那么这些对象都是动态链接到这个程序的，并且映射到用户虚拟地址空间中的共享区域内。</li><li>设置程序计数器(PC)：execve做的最后一件事情就是设置当前进程上下文中(进程记住自己被切换时的寄存器值，如rip中的指令地址)的程序计数器，使之指向文本区域的入口点。</li></ul><p><img src="/2021/11/08/malloc/image-20211111113721701.png" alt="image-20211111113721701"></p><p><strong>10.8.4 使用mmap函数的用户级主存映射</strong></p><p>&emsp;&emsp;Unix进程可以使用mmap函数来创建新的虚拟主存区域，并将对象映射到这些区域中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">mmap</span><span class="params">(<span class="keyword">void</span>* start, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span>, offset)</span></span>;</span><br><span class="line"><span class="comment">//返回：若成功时则为指向映射区域的指针，若出错则为1</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;mmap函数让内核创建一个虚拟主存区域，最好是从地址start开始的一个区域，并将文件描述符fd指定的对象的一个连续组块(多个连续页)映射到这个新的区域。连续的组块大小为length字节，从距文件开始出偏移量为offset字节的地方开始。start地址通常被定义为NULL。</p><p><img src="/2021/11/08/malloc/image-20211111122753433.png" alt="image-20211111122753433"></p><p>&emsp;&emsp;参数port是新映射虚拟主存区域的访问权限字段(也就是，在相应区域结构中的vm_port字段)。</p><ul><li>PORT_EXEC：这个区域内的页面由可以被CPU执行的指令组成。</li><li>PORT_READ：这个区域内的页面可读。</li><li>PORT_WRITE：这个区域内的页面可写。</li><li>PORT_NONE：这个区域内的页面不能被访问。</li></ul><p>&emsp;&emsp;参数flags由描述被映射对象类型的位组成。如果MAP_ANON标记位被设置，并且fd为NULL，那么被映射的对象就是一个匿名对象，而相应的虚拟页面是请求二进制零的。MAP_PRIVATE表示被映射的对象是一个私有的写时拷贝对象，而MAP_SHARED表示是一个共享对象。例如：</p><p>&emsp;&emsp;bufp = Mmap(NULL, size, PORT_READ, MAP_PRIVATE|MAP_ANON, 0, 0);</p><p>让内核创建一个新的包含size字节的、只读、私有、请求二进制零的虚拟存储器区域。如果调用成功，bufp指代新区域的地址。</p><p>&emsp;&emsp;munmap函数删除虚拟存储器的区域：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span>* start, <span class="keyword">size_t</span> length)</span></span>;</span><br><span class="line"><span class="comment">//返回：若成功则为0，若出错则为-1</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;munmap函数删除从虚拟地址start开始的，由接下来length字节组成的区域。接下来对已删除区域的引用会导致段错误。</p></div></div><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>10.9 动态主存分配</span></div>    <div class="hide-content"><p>&emsp;&emsp;虽然可以使用低级的mmap和munmap函数来创建和删除虚拟主存的区域，但是大多数C程序还是会在运行时需要额外虚拟主存时，使用一种动态主存分配器(dynamic memory allocator)。</p><p>&emsp;&emsp;一个动态主存分配器维护着一个称为<strong>堆</strong>(heap)(图10.35)的进程虚拟主存区域。在大多数的Unix系统中，堆是一个请求二进制零的区域，它紧接在未初始化的bss区域后开始，并向上扩大(向更高的地址)。对于每个进程，内核维护着一个变量brk(读作“break”)，它指向堆的顶部。</p><p><img src="/2021/11/08/malloc/image-20211111124445279.png" alt="image-20211111124445279"></p><p>&emsp;&emsp;分配器将堆视为一组不同大小的<strong>块</strong>(block)的集合来维护。每个块就是一个连续的虚拟主存组块(连续多个虚拟页)，要么是已分配的，要么是空闲的。</p><p>&emsp;&emsp;分配器有两种基本风格。两种风格都要求程序显示地分配块，不同之处在于由负责释放已分配的块。</p><ul><li><p>显示分配器(explicit allocator)：要求程序显示地释放任何已分配的块。例如，C标准库提供一种叫做malloc程序包的显式分配器。C程序通过调用malloc函数来分配一个块，并通过调用free函数来释放一个块。C++中的new和delete操作符与C中的malloc和free相当。</p></li><li><p>隐式分配器(implicit allocator)：要求分配器检测何时一个已分配块不再被程序使用，然后就释放这个块。隐式分配器也叫作<strong>垃圾收集器</strong>(garbage collector)，而自动释放未使用的已分配的块的过程叫做<strong>垃圾收集</strong>(garbage collection)。诸如Lisp、ML以及Java之类的高级语言就用垃圾收集来释放已分配的块。</p></li></ul><p>&emsp;&emsp;本节剩下的部分讨论的是显示分配器的设计和实现。我们将在10.10小结中讨论隐式分配器。为了更具体，我们的讨论集中于管理堆区域的分配器。然而，学生们应该明白，主存分配是一个普遍的概念，例如，图形处理密集的程序就经常使用标准分配器来要求获得一大块虚拟主存，然后使用与应用相关的分配器来管理块中的主存，以支持图形节点的创建和销毁。</p><p><strong>10.9.1 malloc和free函数</strong></p><p>&emsp;&emsp;C标准库提供了一个称为malloc程序包的显示分配器。程序通过调用malloc函数来从堆中分配块。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="comment">//返回：若成功则为指针，若出错则为NULL</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;malloc函数返回一个指针，指向大小为至少size字节的主存块，这个块会为可能包含在这个块内的所有数据对象类型做对齐。在我们熟悉的Unix系统上，malloc返回一个8字节边界对齐的块。size_t类型被定义为unsigned int(无符号整数)。</p><p>&emsp;&emsp;如果malloc遇到问题(例如，程序要求的主存块比可用的虚拟主存还要大)，那么它就返回NULL，并设置errno。malloc不初始化它返回的主存。那些想要已初始化的动态主存的应用程序可以使用calloc，calloc是一个基于malloc的瘦包装函数，它将分配的主存初始化为0。想要改变一个以前已分配块的大小，可以使用realloc函数。</p><p>&emsp;&emsp;动态主存分配器(例如malloc)可以通过使用mmap和munmap函数，显示地分配和释放堆主存，还可以使用sbrk函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">sbrk</span><span class="params">(<span class="keyword">int</span> incr)</span></span>;</span><br><span class="line"><span class="comment">//返回：若成功则为老brk指针，若出错则为-1</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;sbrk通过将内核的brk指针增加incr来扩大和减小堆。若果成功，它就返回brk的旧值，否则，它就返回-1，并将errno设置为ENOMEM。如果incr为零，那么sbrk就返回brk的当前值。用一个为负的incr来调用sbrk是合法的。而且很巧妙，因为返回值(brk的旧值)指向在新堆顶上面的第abs(incr)字节。</p><p>&emsp;&emsp;程序通过调用free函数来释放已分配的堆块。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;</span><br><span class="line"><span class="comment">//返回：无</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;ptr参数必须指向一个从malloc获得的已分配块的起始位置。如果不是，那么free的行为就是错的0。更糟的是，free什么都不返回，就不会告诉应用程序出了错误。</p><p>&emsp;&emsp;图10.36展示了使用malloc和free是如何管理一个C程序的16字的(非常)小的堆的。每个方框代表一个4字节的字。内部有阴影的方框表示已分配，内部无阴影的方框表示空闲块。初始时，堆是由一个大小为16字的、双字对齐的空闲块组成的。</p><ul><li>图10.36(a)：程序请求一个4字的块。malloc的响应是：从空闲块的前部切出一个4字的块，并返回一个指向这个块的第一字的指针。</li><li>图10.36(b)：程序请求一个5字的块。malloc的响应时：从空闲块的前部分配一个6字的块。在本例中，malloc在块里填充了一个额外的字，是为了保持空闲块是双字边界对齐的。</li><li>图10.36(c)：程序请求一个6字的块，而malloc就从空闲块的前部切出一个6字的块。</li><li>图10.36(d)：程序释放在图10.36(b)中分配的那个6字的块。注意，在调用free返回之后，指针p2仍然指向被释放了的块。应用有责任在它调用一个新的malloc重新分配之前，不再使用p2。</li><li>图10.36(e)：程序请求一个2字的块。在这种情况中，malloc分配在前一步中被释放了的块的一部分，并返回一个指向这个新块的指针。</li></ul><p><img src="/2021/11/08/malloc/image-20211111164034631.png" alt="image-20211111164034631"></p><p><img src="/2021/11/08/malloc/image-20211111164049976.png" alt="image-20211111164049976"></p><p><strong>10.9.2 为什么要使用动态主存分配</strong></p><p>&emsp;&emsp;程序使用动态主存分配的最重要原因是，它们经常直到程序实际运行时，才知道某些数据结构的大小。例如，假设要求我们编写一个C程序，它读一个n个ASCII码整数的链表，每一行一个整数，从stdin到一个C数组。输入是由整数n，和接下来要读和存储到数组中的n个整数组成的。最简单的方法就是用某种硬编码的最大数组大小静态地定义这个数组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 15213</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, n;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">if</span> (n &gt; MAXN);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input file too big&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;<span class="built_in">array</span>[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;用这样的硬编码的大小来分配数组通常不是好想法。MAXN的值是任意的，和机器上可用的虚拟主存的实际数量没有关系。而且，如果这个程序的使用者想读取一个比MAXN更大的文件，唯一的办法就是用一个更大的MAXN值来重新编译这个程序。虽然对于这个简单的示例来说这不成问题，但是硬编码数组界限的出现对于拥有百万行代码和大量使用者的大型软件产品而言是一场维护的噩梦。</p><p>&emsp;&emsp;一种更好的办法是在运行时，在已知了n的值之后，动态地分配这个数组。使用这种方法，数组大小的最大值就只由可用的虚拟主存数量来限制了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *<span class="built_in">array</span>, i, n;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="built_in">array</span> = (<span class="keyword">int</span>*)Malloc(n * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;<span class="built_in">array</span>[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;动态主存分配是一种有用而重要的编程技术。</p><p><strong>10.9.3 分配器的要求和目标</strong></p><p>&emsp;&emsp;显示分配器必须在一些相当严格的约束条件下工作：</p><ul><li>处理任意请求序列。一个应用可以有任意序列的分配请求和释放请求，只要满足约束条件：每个释放请求必须对应于一个当前已分配的块，这个块产生于以前的分配请求。</li><li>立即响应请求。分配器必须立即相应分配请求。因此，不允许分配器为了提高性能缓冲请求重新排列。</li><li>只使用堆。分配器使用的任何非标量数据结构都必须保存在堆里。</li><li>对齐块。分配器必须对齐块，使得它可以保存任何类型的数据对象。在大多数系统中，这意味着分配器返回的块是8字节对齐的。</li><li>不修改已分配的块。分配器只能操作或者改变空闲块。特别是，一旦块被分配了，就不允许修改或者移动它了。因此，诸如压缩已分配块这样的技术是不允许使用的。</li></ul><p>&emsp;&emsp;在这些条件下，分配器的编写者试图实现吞吐率最大化和存储器使用率最大化，而这两个性能目标经常是相互冲突的。</p><ul><li><strong>目标1：最大化吞吐率</strong>。假定n个分配和释放请求的某种序列：R0,R1,…,Rk,…,Rn-1。<br>我们希望一个分配器的吞吐率最大化，吞吐率就是在每个单位时间里完成的请求数。例如，如果一个分配器在1秒中内完成500个分配请求和500个释放请求，那么它的吞吐率就是每秒1000次操作。一般而言，我们可以通过使满足分配和释放请求的平均时间最小化，来使吞吐率最大化。正如我们会看到的，开发一个具有合理性能的分配器并不困难，所谓合理性能是指一个分配请求的最糟运行时间与空闲块的数量成线性关系，而一个释放请求的运行时间是一个常数。</li><li><strong>目标2：最大化主存利用率</strong>。天真的程序员经常不正确地假设虚拟主存是一个无限的资源。实际上，一个系统中被所有进程分配的虚拟主存的全部数量是受磁盘上交换空间的数量限制的。好的程序员知道虚拟主存是一个有限的空间，必须高效地使用，对于可能被要求分配和释放大块主存的动态主存分配器来说，尤其如此。<br>有很多方式来描述一个分配器使用堆的效率如何。在我们的经验中，最有用的标准是<strong>峰值利用率</strong>(peak utilization)。假定n个分配和释放请求的某种序列：R0,R1,…,Rk,…,Rn-1。<br>如果一个应用程序请求一个p字节的块，那么得到的已分配块的<strong>有效载荷</strong>(payload)是p字节。在 请求Rk完成之后，<strong>聚集有效载荷</strong>(aggregate payload)，表示为Pk，为当前已分配的块的有效载荷之和，而Hk表示堆的当前的大小。<br>&emsp;&emsp;那么，前k个请求的峰值利用率，表示为 Uk = max(Pi) / Hk，i≤k。<br>那么，分配器的目标就是在真个序列中使峰值利用率Un-1最大化。正如我们将要看到的，在最大化吞吐率和最大化利用率之间是有平衡关系的。特别是，以堆利用率为代价，很容易编写出吞吐率最大化的分配器。分配器设计中一个有趣的挑战就是在两个目标之间找到一个适当的平衡。</li></ul><p><strong>10.9.4 碎片</strong></p><p>&emsp;&emsp;造成堆利用率很低的主要原因是一种称为<strong>碎片</strong>(fragmentation)的现象，这种现象是当有未使用的主存但不能满足分配请求。有两种形式的碎片：<strong>内部碎片</strong>(internal fragmentation)和<strong>外部碎片</strong>(external fragmentation)。</p><p>&emsp;&emsp;内部碎片是描述一个已分配块比有效载荷大的现象。很多原因都可能造成这个问题。例如，一个分配器的实现可能对增加块的大小以满足边界对齐。</p><p>&emsp;&emsp;内部碎片的量化是简单的，就是已分配块和它们的有效载荷之差的和。因此，在任意时间点，内部碎片的数量只取决之前的请求和分配器的实现方式。</p><p>&emsp;&emsp;外部碎片是描述空闲存储器合计起来能够满足一个分配请求，但是没有一个单独的空闲块大到能处理这个请求的现象。</p><p>&emsp;&emsp;外部碎片比内部碎片的量化要困难的多。因为它不仅取决于以前的请求和分配器的实现方式，还取决于未来的请求。假设k个请求之后，所有空闲块的大小都恰好是4个字。这个堆会有外部碎片吗？答案取决于将来的请求，如果将来所有的分配请求都比4个字小，那么就不会有外部碎片。如果有一个或多个请求比4个字大，那么这个堆就会有外部碎片。</p><p>&emsp;&emsp;因为外部碎片难以量化，所以分配器试图维持少量的大空闲块，而不是维持大量的小空闲块。</p><p><strong>10.9.5 实现问题</strong></p><p>&emsp;&emsp;可以想象出的最简单的分配器，会把堆组织成一个大的字节数组，还有一个指针P，初始指向这个数组的第一个字节。为了分配size字节，malloc将P的当前值保存在栈里，将P增加size，并将P的旧值返回到调用函数。free只是简单地返回调用函数，而不做任何其他事情。</p><p>&emsp;&emsp;这个简单的分配器是一种极端情况。因为每个malloc和free只执行很少量的指令，吞吐率会极好。然而，因为分配器从不重复使用任何块，存储器利用率将极差。一个实际的分配器要在吞吐率和利用率之间把握好平衡，就必须考虑以下几个问题。</p><ul><li><strong>空闲块组织：</strong>我们如何记录空闲块。</li><li><strong>放置：</strong>我们如何选择一个合适的空闲块来放置一个新分配的块？</li><li><strong>分隔：</strong>在我们将一个新分配的块放置到某个空闲块之后，我们如何处理这个空闲块中的剩余部分？</li><li><strong>合并：</strong>我们如何处理一个刚刚被释放的块？</li></ul><p>&emsp;&emsp;本章的剩余部分，将详细讨论这些问题。因为像放置、分隔以及合并这样的基本技术贯穿在许多不同的空闲块组织方式中，所以我们将在一种叫做隐式空闲链表的简单空闲块组织结构中来介绍它们。</p><p><strong>10.9.6 隐式空闲链表</strong></p><p>&emsp;&emsp;任何实际的分配器都需要一些数据结构，用来划分块边界，并区别已分配块和空闲块。大多数分配器将这些信息嵌在块本身当中。一个简单的方法如图10.37所示。</p><p><img src="/2021/11/08/malloc/image-20211111183244428.png" alt="image-20211111183244428"></p><p>&emsp;&emsp;在这种结构下，一个块是由一个字的头部、有效载荷，以及可能的填充组成的。头部记录了这个块的大小(包括头部和所有填充)，以及这个块是已分配的还是空闲的。如果我们强加一个双字的对齐约束条件，那么块大小就总是8的倍数，且块大小的最低3位总是零。因此，我们只需要存储块大小的29个高位，用剩余的3位来记录其他信息。我们用头部的最低位指明这个块是已分配的，还是空闲的。例如，假设我们有一个已分配的块，大小为24(0x18)字节。那么它的头部将是：</p><p>&emsp;&emsp;0x00000018 | 0x1 = 0x00000019.</p><p>&emsp;&emsp;类似地，一个块大小为40(0x28)字节的空闲块有如下的头部：</p><p>&emsp;&emsp;0x00000028 | 0x0 = 0x00000028.</p><p>&emsp;&emsp;头部后面就是应用调用malloc时申请的有效载荷。有效载荷后面是一块不使用的填充块，其大小可以是任意的。填充可能是分配器策略的一部分，用来对付外部碎片。或者也需要用它来满足对齐要求。</p><p>&emsp;&emsp;假设块的格式如图10.37所示，我们可以将堆组织为一个连续的已分配块和空闲块的序列，如图10.38所示。</p><p><img src="/2021/11/08/malloc/image-20211111185230381.png" alt="image-20211111185230381"></p><p>&emsp;&emsp;我们称这种结构为<strong>隐式空闲链表</strong>，是因为空闲块是通过头部中的大小字段隐式地连接着的。分配器可以通过遍历堆中的所有块，从而间接地遍历整个空闲块的结合。注意，我们需要特别标记出结束的块，在这个示例中，就是一个设置了已分配位而大小为0的终止头部(terminating header)。</p><p>&emsp;&emsp;隐式空闲链表的优点是简单。显著的缺点是任何操作的开销，例如放置分配的块需要搜索空闲块，与堆中已分配块和空闲块的总数呈线性关系。</p><p>&emsp;&emsp;很重要的一点是，意识到系统对齐要求和分配器对齐要求对最小快的大小有强制要求。例如，我们假设一个双字对齐的要求，那么每个块的大小都必须是双字(8字节)的倍数。因此，图10.37中的块格式就导致最小的块大小为两个字：一个字作头，另一个字维持对齐要求。</p><p><strong>10.9.7 放置分配的块</strong></p><p>&emsp;&emsp;当一个应用请求一个k字节的块时，分配器搜索空闲链表，查找一个足够大、可以放置所请求块的空闲块。分配器执行这种搜索的方式是由<strong>放置策略</strong>(placement policy)确定的。一些常见的策略是首次适配(first fit)、下一次适配(next fit)和最佳适配(best fit)。</p><p>&emsp;&emsp;<strong>首次适配</strong>从头开始搜索空闲链表，选择第一个合适的空闲块。<strong>下一次适配</strong>和首次适配很相似，只不过不是从链表的起始处开始每次搜索，而是从上一次查询结束的地方开始。<strong>最佳适配</strong>检查每个空闲块，选择匹配所需请求大小的最小空闲块。</p><p>&emsp;&emsp;首次适配的一个优点是它趋向于将大的空闲块保留在链表的后面。缺点是它趋向于在靠近链表起始处留下小空闲块的”碎片”，这就增加了对较大块的搜索时间。下一次适配是由Donald Knuth作为首次适配的一种替代品最早提出的，源于这样一个想法：如果我们上一次在某个空闲块里已经发现了一个匹配，那么很可能下一次我们也能在这个剩余块中发现匹配。下一次适配比首次适配运行起来明显要快一些。然而，一些研究表明，下一次适配的主存利用率比首次适配低得多。研究还表明最佳适配比首次试配和下一次适配的主存利用率都高一些。然而，在简单空闲链表组织结构中，比如隐式空闲链表中，使用最佳适配的缺点是它要求对堆进行彻底的搜索。在后面，我们将看到更加巧妙的分离式空闲链表结构，它实现了最佳适配策略，而不需要进行彻底的堆搜索。</p><p><strong>10.9.8 分割空闲块</strong></p><p>&emsp;&emsp;一旦分配器找到一个匹配的空闲块，它就必须做另一个策略决定，那就是分配这个空闲块中多少空间。一个选择是用整个空间块。虽然这种方式简单而快捷，但是主要的缺点是会造成内部碎片。如果放置策略趋向于生产好的匹配，那么额外的内部碎片也是可以接收的。</p><p>&emsp;&emsp;然而，如果匹配不太好，那么分配器通常会选择将这个空闲块分割成两部分。第一部分变成分配块，而剩下的变成一个新的空闲块。图10.39展示了分配器如何分隔图10.38中8个字的空闲块，来满足一个应用对堆主存3个字的请求。</p><p><img src="/2021/11/08/malloc/image-20211111192901515.png" alt="image-20211111192901515"></p><p><strong>10.9.9 获取额外的堆存储器</strong></p><p>&emsp;&emsp;如果分配器不能为请求找到合适的空闲块，将会发生什么呢？一个选择是通过合并那些虚拟主存中相邻的空闲块来创建一些更大的空闲块(在下一节中描述)。然而，如果这样还是不能生成一个足够大的块，那么分配器就会向内核请求额外的堆主存，要么是调用mmap，要么是通过调用sbrk函数。在任一种情况下，分配器都会将额外的(或增加的)主存转换成一个大的空闲块，将这个块插入到空闲链表中，然后将被请求的块放置在这个新的空闲块中。</p><p><strong>10.9.10 合并空闲块</strong></p><p>&emsp;&emsp;当分配器释放一个已分配块时，可能有其他空闲块与这个新释放的空闲块相邻。这些相邻的空闲块可能引起一种现象，叫做<strong>假碎片</strong>(fault fragmentation)，这里有许多可用的空闲块被切割称为小的、无法使用的空闲块。比如，图10.40展示了释放图10.39中分配块后得到的结果。结果是两个相邻的空闲块，每个有效载荷都为3个字。因此，接下来一个请求4字有效载荷的malloc就会失败，即使两个空间块的合计大小足够大，可以满足这个请求。</p><p><img src="/2021/11/08/malloc/image-20211111201537688.png" alt="image-20211111201537688"></p><p>&emsp;&emsp;为了对付假碎片问题，任何实际的分配器都必须合并相邻的空闲块，这个过程称为<strong>合并</strong>(coalescing)。这就提出了一个重要的策略决定，那就是何时执行合并。分配器可以选择<strong>立即合并</strong>(immediate coalescing)，也就是在一个块被释放的时候，就合并所有的相邻块。或者它也可以选择<strong>推迟合并</strong>(deferred coalescing)，也就是等到某个稍晚的时候再合并空闲块。例如，分配器可以推迟合并，直到某个分配请求失败，然后扫描整个堆，合并所有空闲块。</p><p>&emsp;&emsp;立即合并简单明了，可以在常数时间内完成，但是对于某些请求模式，这种方式会产生一种抖动：块会反复地合并，然后马上分割。例如，在图10.40中，反复地分配和释放一个3个字的块将产生大量不必要的分割和合并。在我们对分配器的讨论中，我们会假设使用立即合并，但是你应该了解，快速的分配器通常会选择某种形式的推迟合并。</p><p><strong>10.9.11 带边界标记的合并</strong></p><p>&emsp;&emsp;分配器是如何实现合并的？让我们称我们想要释放的块为当前块。那么，合并下一个空闲块很简单且高效。当前块的头部指向下一个块的额头不，可以检查这个指针以判断下一个块是否是空闲的。如果是，就将它的大小简单地加到当前块的头部上，这两个块在常数时间内被合并。</p><p>&emsp;&emsp;但是我们该如何合并前面的块呢？给定一个带头部的隐式空闲链表，唯一的选择将是搜索整个链表，记住前面块的位置，直到我们到达当前块。使用隐式链表，这意味着每次调用free的时间都与块的数目成线性关系。即使更巧妙的空闲链表组织，搜索时间也不会是常数。</p><p>&emsp;&emsp;Knuth提出了一种聪明而通用的技术，叫做<strong>边界标记(boundary tag)<strong>，允许在常数时间内进行对前面块的合并。这种思想，如图10.41所示，是在每个块的结尾处添加一个</strong>脚部</strong>(footer边界标记),其中脚部就是头部的一个副本。如果每个块包含这样一个脚部，那么分配器就可以通过检查它的脚部，判断前面一个块的起始位置和状态，这个脚部总是在距当前块结尾位置一个字的距离。</p><p><img src="/2021/11/08/malloc/image-20211111222157928.png" alt="image-20211111222157928"></p><p>考虑当分配器释放当前块时所有可能存在的情况：</p><ol><li>前面的块和后面的块都是已分配的。</li><li>前面的块是已分配的，后面的块是空闲的。</li><li>前面的块是空闲的，而后面的块是已分配的。</li><li>前面的和后面的块都是空闲的。</li></ol><p>图10.42展示了我们如何对这四种情况进行合并。</p><p><img src="/2021/11/08/malloc/image-20211111230158312.png" alt="image-20211111230158312"></p><p>&emsp;&emsp;边界标记是简单优雅的，它对许多不同类型的分配器和空闲链表结构都是通用的。然而，它也存在一个缺陷。要求每个块都保持一个头部和一个脚部，在应用程序操作许多小块时，会产生显著的主存开销，例如，如果一个图形应用通过反复调用malloc和free，来动态地创建和销毁图形节点，并且每个图形节点只要求两个字，那么头部和脚部将占用每个已分配块的一半的空间。</p><p>&emsp;&emsp;幸运的是，有一种非常聪明的边界标记的优化方法。已分配的块实际上不需要脚部，空闲的块才需要脚部。我们可以仅在块被释放，写脚部曾经的覆盖效载荷。</p><p><strong>10.9.12 综合：实现一个简单的分配器</strong></p><p>&emsp;&emsp;我们的分配器使用如图10.43所示的memlib.c包提供的一个堆模型。模型的目的在于允许我们再不干涉已存在的malloc包的情况下，运行我们的分配器。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//memlib.c 堆模型</span></span><br><span class="line"><span class="comment">/*private global variables*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *mem_start_brk; <span class="comment">/* points to first byte of the heap */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *mem_brk;       <span class="comment">/* points to last byte of the heap */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *mem_max_addr;  <span class="comment">/* max virtual address for the heap */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*mem_init - initializes the memory system model</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mem_init</span><span class="params">(<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mem_start_brk = (<span class="keyword">char</span> *)Malloc(size); <span class="comment">/* models available VM */</span></span><br><span class="line">    mem_brk = mem_start_brk;              <span class="comment">/* heap is initially empty */</span></span><br><span class="line">    mem_max_addr = mem_start_brk + size;  <span class="comment">/* max VM address for heap */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* mem_sbrk -simple model of the sbrk function. Extends the heap</span></span><br><span class="line"><span class="comment">* by incr bytes and returns the start address of the new area.</span></span><br><span class="line"><span class="comment">* In this model, the heap cannot be shrunk.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mem_sbrk</span><span class="params">(<span class="keyword">int</span> incr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* old_brk = mem_brk;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ( (incr&lt;<span class="number">0</span>) || ((mem_brk+incr) &gt; mem_max_addr)) &#123;</span><br><span class="line">        errno = ENOMEM;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">void</span>*)<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mem_brk += incr;</span><br><span class="line">    <span class="keyword">return</span> old_brk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;分配器包含在一个源文件中(malloc.c)，用户可以编译链接这个源文件到它们的应用之中。分配器提供三个函数给应用程序：</p><p>&emsp;&emsp;1. int mm_init(void);</p><p>&emsp;&emsp;2. void* mm_malloc(size_t size);</p><p>&emsp;&emsp;3. void* mm_free(void *bp);</p><p>&emsp;&emsp;分配器使用图10.41所示的块格式，空闲链表结构为隐式空闲链表，具有图10.44所示的恒定形式(invariant form)。</p><p><img src="/2021/11/08/malloc/image-20211112135230156.png" alt="image-20211112135230156"></p><p>&emsp;&emsp;第一个字(4字节)是一个用于与结尾块双字边界对齐的填充字。填充后面紧跟着一个特殊的序言块(prologue block)，这是一个8字节的已分配块，只由一个头部和一个脚部组成。序言块是在初始化时创建的，并且永不释放。在序言块后紧跟的是零个或多个由malloc或者free调用创建的普通块。堆总是以一个特殊的结尾块(epilogue block)来结束，这个块是一个大小为零的已分配块，只有一个头部组成。序言块和结尾块是一种消除合并时边界条件的技巧。分配器使用一个私有(静态)全局变量(heap_listp)，它总是指向序言块。(作为小优化，我们可以让它指向下一个块，而不是序言块)。</p><p>&emsp;&emsp;下面是我们在分配器编码中将要使用的基本常数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//操作空闲链表的基本常数和宏</span></span><br><span class="line"><span class="comment">/* Basic constants and macros */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WSIZE4<span class="comment">/* word size(bytes) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DSIZE8<span class="comment">/* doubleword size(bytes) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHUNKSIZE (1&lt;&lt;12) <span class="comment">/* initial heap size(bytes) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OVERHEAD 8  <span class="comment">/* overhead of header and footer(bytes) */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(x,y) ((x)&gt;(y) ? (x):(y))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Pack a size and allocated bit into a word */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PACK(size, alloc) ((size) | (alloc))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Read and write a word at address p */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET(p) (*(size_t *)(p))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUT(p, val) (*(size_t *)(p) = (val))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Read the size and allocated fields from address p */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_SIZE(p)  (GET(p) &amp; ~0x7) <span class="comment">//~0111 = 前面补1 1000 </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_ALLOC(p) (GET(p) &amp; 0x1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Given block ptr bp, compute address of its header and footer */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HDRP(bp) ((char*)(bp) - WSIZE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FTRP(bp) ((char*)(bp) + GET_SIZE(HDRP(bp)) - DSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Given block ptr bp, compute address of next and previous blocks */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NEXT_BLKP(bp) ((char*)(bp) + GET_SIZE(((char*)(bp)-WSIZE)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREV_BLKP(bp) ((char*)(bp) - GET_SIZE(((char*)(bp)-DSIZE)))</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在空闲链表中操作头部和脚部可能是很麻烦的，因为它要求大量使用强制类型转换和指针运算。因此，定义一个小的宏集合来访问和遍历空闲链表是很有帮助的。比如我们可以用如下代码确定下一个块的大小:</p><p>&emsp;&emsp;size_t size = GET_SIZE(HDRP(NEXT_BLKP(bp)));</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化空闲链表</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mm_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* create the initial empty heap */</span></span><br><span class="line">    <span class="keyword">if</span> ((heap_listp = mem_sbrk(<span class="number">4</span>*WSIZE)) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    PUT(heap_listp, <span class="number">0</span>);  <span class="comment">/* alignment padding */</span></span><br><span class="line">    PUT(heap_listp+WSIZE, PACK(OVERHEAD, <span class="number">1</span>)); <span class="comment">/* prologue header */</span></span><br><span class="line">    PUT(heap_listp+DSIZE, PACK(OVERHEAD, <span class="number">1</span>)); <span class="comment">/* prologue footer */</span></span><br><span class="line">    PUT(heap_listp+WSIZE+DSIZE, PACK(<span class="number">0</span>, <span class="number">1</span>));  <span class="comment">/* epilogue header */</span></span><br><span class="line">    heap_listp += DSIZE;<span class="comment">/* point to prologue block */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Extend the empty heap with a free block of CHUNKSIZE bytes */</span></span><br><span class="line">    <span class="keyword">if</span> (extend_heap(CHUNCKSIZE/WSIZE) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;mm_init函数从主存中得到4个字，并将它们初始化，从而创建一个空的空闲链表。然而它调用extend_heap函数(下面的代码块中展示)，这个函数将堆扩展CHUNKSIZE字节，并且创建初始空闲块。此刻分配器已初始化了，并且准备好接受来自应用的分配和释放请求。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">extend_heap</span><span class="params">(<span class="keyword">size_t</span> words)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* bp;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Allocate an even number of words to maintain alignment */</span></span><br><span class="line">    size = (words % <span class="number">2</span>) ? (words+<span class="number">1</span>)*WSIZE : words*WSIZE;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">int</span>)(bp = mem_sbrk(size)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Initialize free block header/footer and the epilogue header */</span></span><br><span class="line">    PUT(HDRP(bp), PACK(size, <span class="number">0</span>));<span class="comment">/* free block header */</span></span><br><span class="line">    PUT(FTRP(bp), PACK(size, <span class="number">0</span>));<span class="comment">/* free block footer */</span></span><br><span class="line">    PUT(HDRP(NEXT_BLKP(bp)), PACK(<span class="number">0</span>,<span class="number">1</span>)); <span class="comment">/* new epilogue header */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Coalesce if the previous block was free */</span></span><br><span class="line">    <span class="keyword">return</span> coalesce(bp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;extend_heap函数会在两种情况下被调用：①当堆被初始化时；②mm_malloc不能找到一个合适的匹配块时。为了保持对齐，extend_heap将请求大小向上取整为2字的倍数，然后向虚拟主存系统请求额外的堆空间。在很可能出现最后一个块是空闲块的情况下，我们调用coalesce函数来合并两个空闲块，并返回指向合并后的块的块指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//释放和合并块</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mm_free</span><span class="params">(<span class="keyword">void</span>* bp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> size = GET_SIZE(HDRP(bp));</span><br><span class="line">    </span><br><span class="line">    PUT(HDRP(bp), PACK(size,<span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(bp), PACK(size,<span class="number">0</span>));</span><br><span class="line">    coalesce(bp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">coalesce</span><span class="params">(<span class="keyword">void</span>* bp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> prev_alloc = GET_ALLOC(FTRP(PREV_BLKP(bp)));</span><br><span class="line">    <span class="keyword">size_t</span> next_alloc = GET_ALLOC(HDRP(NEXT_BKLP(bp)));</span><br><span class="line">    <span class="keyword">size_t</span> size = GET_SIZE(HDRP(bp));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (prev_alloc &amp;&amp; next_alloc)&#123;</span><br><span class="line">        <span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (prev_alloc &amp;&amp; !next_alloc)</span><br><span class="line">    &#123;</span><br><span class="line">        size += GET_SIZE(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">        PUT(HDRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(HDRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">return</span>(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!prev_alloc &amp;&amp; next_alloc)&#123;</span><br><span class="line">        size += GET_SIZE(HDRP(PREV_BLKP(bp)));</span><br><span class="line">        PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">return</span>(PREV_BLKP(bp));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        size += GET_SIZE(HDRP(PREV_BLKP(bp))) + GET_SIZE(FTRP(NEXT_BLKP(bp)));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(NEXT_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">return</span>(PREV_BLKP(bp));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们的空闲链表结构十分巧妙，它的序言块和结尾块总是标记为已分配，使得我们能够忽略麻烦的边界情况，也就是释放的块在堆的起始或结尾处。如果没有这些特殊的块，我们必须在每次释放块时，检查这些并不常见的边界情况，这将导致代码混乱，容易出错，执行更多指令。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分配块</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">mm_malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> asize;<span class="comment">/* adjusted block size */</span></span><br><span class="line">    <span class="keyword">size_t</span> extendsize;<span class="comment">/* amount to extend heap if no fit */</span></span><br><span class="line">    <span class="keyword">char</span>* bp;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Ignore spurious requests */</span></span><br><span class="line">    <span class="keyword">if</span> (size&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Adjust block size to include overhead and alignment reqs. */</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt;= DSIZE)</span><br><span class="line">        asize = DSIZE + OVERHAED;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        asize = DSIZE * ((size + (OVERHEAD) + (DSIZE<span class="number">-1</span>)) / DSIZE);</span><br><span class="line">    <span class="comment">/* Search the free list for a fit*/</span></span><br><span class="line">    <span class="keyword">if</span> ( (bp = find_fit(asize)) != <span class="literal">NULL</span> )&#123;</span><br><span class="line">        place(bp, asize);</span><br><span class="line">        <span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* No fit found. Get more memory and place the block */</span></span><br><span class="line">    extendsize = MAX(asize, CHUNKSIZE);</span><br><span class="line">    <span class="keyword">if</span> ( (bp = extend_heap(extendsize/WSIZE)) == <span class="literal">NULL</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    place(bp, asize);</span><br><span class="line">    <span class="keyword">return</span> bp;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;需要你为分配器实现一个find_fit函数，对隐式空闲链表执行首次适配搜索</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">find_fit</span><span class="params">(<span class="keyword">size_t</span> asize)</span></span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;需要你为分配器实现一个place函数，j将分配块放置在空闲块的起始位置，仅当剩余部分的大小大于等于最小块大小16字节时才分割(加块结构)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">place</span><span class="params">(<span class="keyword">void</span>* bp, <span class="keyword">size_t</span> asize)</span></span></span><br></pre></td></tr></table></figure><p><strong>10.9.13 显式空闲链表</strong></p><p>&emsp;&emsp;隐式空闲链表结构，因为块分配与堆块的综述呈线性关系，所以对通用的分配器，隐式空闲链表是不合适的(尽管对于堆块预先就知道是很小的特殊分配器来说，它是比较好的)。</p><p>&emsp;&emsp;一种更好的办法是将空闲块组织为某种形式的显示数据结构。因为程序不需要一个空闲块的主体，所以实现这个数据结构的指针可以存放在这些空闲块的主体里面。例如，可以使用一个双向空闲链表结构，在每个空闲块中，包含一个pred(前驱)和succ(后继)指针，如图10.50所示。</p><p><img src="/2021/11/08/malloc/image-20211112170857426.png" alt="image-20211112170857426"></p><p>&emsp;&emsp;使用双向链表，而不是隐式空闲链表，使首次适配的分配时间从块总数的线性时间，减少到了空闲块数量的线性时间。不过释放一个块的时间可以是线性的，也可以是常数的，这取决于我们在空闲链表中对块排序的策略。</p><p>&emsp;&emsp;一种方法是<strong>后进先出</strong>(LIFO)的顺序维护链表，将新释放的块放置在链表的开始处。使用LIFO的顺序和首次适配的放置策略，分配器会最先检查最近使用过的块。在这种情况下，释放一个块可以在常数时间内完成。如果使用了边界标记(当前块可以借助上一块的尾部找到上一块，是个隐式指针)，那么合并也可以在常数时间内完成。</p><p>&emsp;&emsp;另一种方法是按照<strong>地址顺序</strong>来维护链表，其中链表中每个块的地址都小于它的祖先的地址。在这种情况下，释放一个块需要线性时间的搜索，来定位合适的祖先。按照地址排序的首次适配比LIFO的首次适配有更高的存储器利用率，接近最佳适配的利用率。</p><p>&emsp;&emsp;一般而言，显示链表的缺点是空闲块必须足够大，以包含所有需要的指针，以及头部和可能的脚部。这就导致了更大的最小块大小，也潜在地提高了内部碎片的程度。</p><p><strong>10.9.14 分离的空闲链表</strong></p><p>&emsp;&emsp;就像我们已经看到的，一个使用单向空闲链表的分配器需要与空闲块数量成线性关系的时间来分配块。一种流行的减少分配时间的方法，通常称为<strong>分离存储</strong>(segregated storage)，维护多个空闲链表，其中每个链表中的块有大致相等的大小。</p><p>&emsp;&emsp;一般的思路是将所有可能的块大小分成几类(size class)。分配器维护着一个空闲链表数组，每类一个空闲链表数组，按照大小的升序排列。当分配器需要一个大小为n的块时，它就搜索相应的空闲链表。如果它不能找到相应大小的块与之匹配，它就搜索下一个链表，依次类推。</p><p>&emsp;&emsp;有关动态存储分配的文献描述了很多种分离存储方法，主要的区别在于它们如何划分类，何时进行合并，何时向操作系统请求额外的堆存储器，是否允许分隔，等等。为了使你大致了解有哪些可能性，我们会描述两种基本的方法：<strong>简单分离存储</strong>(simple segregated storage)和<strong>分离适配</strong>(segregated fit)。</p><p>&emsp;&emsp;<strong>简单分离存储</strong></p><p>&emsp;&emsp;使用简单分离存储，每个大小类的空闲链表包含大小相等的块。一个{17-32}大小块，其空闲链表全由32字节的块组成。</p><p>&emsp;&emsp;为了分配一个给定大小的块，我们检查相应的空闲链表。如果链表非空，我们就简单地分配其中第一块的全部。分空闲块是不会分割的。如果链表为空，分配器就向操作系统请求一个固定大小的额外主存组块(通常是页面大小的整数倍)，将这个组块(chunk)分成大小相等的块，并将这些块连接起来形成性的空闲链表。要释放一个块，分配器只要简单地将这个块插入到相应的空闲链表的前部。</p><p>&emsp;&emsp;这种方法有许多优点。分配和释放块都是很快的常数时间操作。而且，每个组块(chunk)中都是大小相等的块，不分割，不合并，这意味着每个块分配释放的开销很小。既然每个组块只有大小相同的块，那么一个已分配块的大小就可以从它的地址中推断出来。因为没有合并，所以已分配块的头部就不需要一个已分配/空闲标记。因此已分配块不需要头部，同时因为没有合并，它们也不需要脚部。因为分配和释放操作都是在空闲链表的起始处操作，所以链表只需要是单向的，而不用是双向的了。关键点在于，唯一在任何块中都需要的字段是每个空闲块中的一个字的succ指针，因此最小快大小就是一个字。</p><p>&emsp;&emsp;一个显著的缺点是，简单分离存储很容易造成内部和外部碎片。因为空闲块是不会被分隔的，所以可能会造成内部碎片。更糟的是，某些引用模式会引起极多的外部碎片，因为是不会合并空闲块的。</p><p>&emsp;&emsp;研究者提出了一种粗糙的合并形式来对付外部碎片问题。分配器记录操作系统返回的每个组块(chunk)中的空闲块的数量。无论何时，如果有一个组块完全由空闲块组成，那么分配器就从它的当前大小类中删除这个组块，使得它对其他大小类可用。</p><p>&emsp;&emsp;<strong>分离适配</strong></p><p>&emsp;&emsp;使用这种方法，分配器维护着一个空闲链表的数组。每个空闲链表适合一个大小类相关联的，每个链表包含大小不同的块，这些块的大小是大小类的元素。有许多不同的分离适配分配器，我们描述一个简单版本。</p><p>&emsp;&emsp;为了分配一个块，我们必须确定请求的大小类，并且对适当的空闲链表做首次适配，查找一个合适的块。如果我们找到了一个，那么我们(可选地)分割它，并将剩余的部分插入到适当的空闲链表中。如果我们找不到合适的块，那么我们就搜索下一个更大的大小类的空闲链表。如此重复，直到找到一个合适的块。如果没有空闲链表中有合适的块，那么我们就向操作系统请求额外的堆主存，从这个新的堆主存中分配出一块，将剩余的部分放置在最大的大小类中。要释放一个块，我们自行合并，并将结果放置到相应的空闲链表中。</p><p>&emsp;&emsp;分离适配方法是一种常见的选择，C标准库中提供GNU malloc包就是采用的这种方法，因为这种方法既快速，对主存的使用也很有效率。搜索时间减少了，因为搜索被限制在堆的某个部分，而不是整个堆。主存利用率得到了改善，因为有一个有趣的事实：对分离空闲链表的简单的首次适配搜索相当于对整个堆的最佳适配搜索。</p><p>&emsp;&emsp;<strong>伙伴系统</strong></p><p>&emsp;&emsp;伙伴系统(buddy system)是分离匹配的一种特例，其中每个大小类都是2的幂。基本的思路是假设一个堆的大小为2^m个字，我们为每个块大小2^k维护一个分离空闲链表，其中0≤k≤m。请求块大小向上取整为最接近的2的幂。最开始时，只有一个大小为2^m个字的空闲块。</p><p>&emsp;&emsp;为了分配一个大小为2^k的块，我们找到第一个可用的、大小为2^j的块，其中k≤j≤m。如果j=k，那么我们就找到了。否则，我们递归地二分这个块，直到j=k。当我们进行这样的分割时，每个剩下的半块(也叫作伙伴)，被放置在相应的空闲链表中。要释放一个大小为2^k的块，我们继续合并空闲的伙伴。当我们遇到一个已分配的伙伴时，我们就停止合并。</p><p>&emsp;&emsp;关于伙伴系统的一个关键事实是，给定地址和块大小，很容易计算出它的伙伴的地址。例如，一个块，大小为32字节，地址为：xxx…x00000，它的伙伴的地址为 xxx…x10000。换句话说，一个块的地址和它的伙伴只有一位不相同。</p><p>&emsp;&emsp;伙伴系统分配器的主要优点是它的快速搜索和快速合并。主要缺点是要求块大小为2的幂可能导致显著的内部碎片。因此，伙伴系统分配器不适合通用目的的工作负载。然而，对于某些与应用相关的工作负载，其中块大小预先知道是2的幂，伙伴系统分配器就很有吸引力了。</p></div></div><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>10.10 垃圾回收 To Do</span></div>    <div class="hide-content"><p><strong>10.10.1 垃圾收集器的基本要素</strong></p><p><strong>10.10.2 Mark&amp;Sweep垃圾收集器</strong></p><p><strong>C程序的保守Mark&amp;Sweep</strong></p></div></div><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>10.11 C程序中常见的与主存有关的错误 (咕咕咕!)</span></div>    <div class="hide-content"></div></div><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>10.12 扼要重述一些有关虚拟主存的关键概念 (咕咕咕!)</span></div>    <div class="hide-content"></div></div><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>10.13 小结 (咕咕咕!)</span></div>    <div class="hide-content"><p><a href="http://www.cs.colorado.edu/~zorn/DSA.html%E4%B8%8AZorn%E7%9A%84Dynamic">www.cs.colorado.edu/~zorn/DSA.html上Zorn的Dynamic</a> Storage Allocation Repository（动态存储分配仓库）是一个很方便的资源。它包括检测与主存相关错误的调试工具，以及malloc/free和垃圾收集器的实现。</p></div></div><h1 id="简单版本"><a href="#简单版本" class="headerlink" title="简单版本"></a>简单版本</h1><p>隐式空闲链表结构，mmap分配组块(chunk)，首次适配策略放置块，分割，边界标记便于合并。</p><p>简单起见，不对地址参数的正确性做检查</p><p>画图工具为google浏览器插件 Gliffy Diagrams。</p><h2 id="mmap和munmap"><a href="#mmap和munmap" class="headerlink" title="mmap和munmap"></a>mmap和munmap</h2><p>就是简单包裹了一下系统调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;syscall.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stddef.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">void</span>* paddr = (<span class="keyword">void</span> *)SYSCALL6(<span class="number">9</span>, addr, length, prot, flags, fd, offset);</span><br><span class="line">    <span class="keyword">return</span> paddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = (<span class="keyword">int</span>)SYSCALL2(<span class="number">11</span>, addr, length);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常量和宏"><a href="#常量和宏" class="headerlink" title="常量和宏"></a>常量和宏</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALIGN_UP_N_BYTES(size, n) ((((size) + (n) - 1) / (n)) * (n))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALIGN_UP_8_BYTES(size) ALIGN_UP_N_BYTES(size, 8)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALIGN_UP_4KB(size) ALIGN_UP_N_BYTES(size, 4096)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THRESHOLD_FOR_MMAP (256 * 1024)<span class="comment">//max block size in segment</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEGMENT_SIZE (2 * 1024 * 1024) </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEM_BLOCK_MINIMUM 16</span></span><br></pre></td></tr></table></figure><h2 id="Segment和块结构"><a href="#Segment和块结构" class="headerlink" title="Segment和块结构"></a>Segment和块结构</h2><p><strong>Segment结构</strong></p><p>Segment是通过mmap函数请求的区域。后面将只放一个大块的区域称为区域，将用来再分配给多个块的区域称为Segment。对每个请求到的Segment，添加16字节的Segment头部(前驱和后继指针)，用来放一个大块的区域，直接放一个块头部。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SLMemSegment</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SLMemSegment</span> *<span class="title">pPrevMemSegment</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SLMemSegment</span> *<span class="title">pNextMemSegment</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>经过测试，输出的结构大小为16字节，意味着一个指针变量的大小默认为8字节。</p><p><img src="/2021/11/08/malloc/image-20211113121707861.png" alt="image-20211113121707861"></p><p>Segment结构示意图：</p><p><img src="/2021/11/08/malloc/image-20211113140403399.png" alt="image-20211113140403399"></p><p><strong>块结构</strong></p><p>关于C的struct的位域，使用如下代码测试。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span>&#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> a : <span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> b : <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span> <span class="title">t</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span>* <span class="title">p</span> =</span> &amp;t;</span><br><span class="line">p-&gt;a = <span class="number">1</span>;</span><br><span class="line">p-&gt;b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gdb查看内存发现，先申请的在低位，后申请的在高位。且注意使用unsigned无符号数，不然1位的a为1时，会显示成负数。</p><p><img src="/2021/11/08/malloc/image-20211112230237761.png" alt="image-20211112230237761"></p><p>块头部大小为8个字节即64位，由于块是8字节对齐的，所以块大小的最低3位始终为0，只需要高61位表示块大小。第0位CurBlkInUseBit表示该块是否是空闲块，第1位PrevBlkInUseBit表示该块的上一块是否在使用，第3位FromMmapBit表示该块的虚拟主存空间是否字节通过mmap分配。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SLMemBlock</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> CurBlkInUseBit : <span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> PrevBlkInUseBit : <span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> FromMmapBit : <span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> ulBlockSize : <span class="number">61</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>块结构示意图：仅当该块为空闲块时，才写上脚部。由于其头部脚部皆为8字节，所以一个最小块大小为16字节。</p><p><img src="/2021/11/08/malloc/image-20211113152023237.png" alt="image-20211113152023237"></p><h2 id="分配原理"><a href="#分配原理" class="headerlink" title="分配原理"></a>分配原理</h2><p>MyMalloc函数。首先请求的size加上头部，再对size做对齐。超过256KB的请求，通过mmap分配区域，否则，从已分配的Segment中分配空间给块。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">MyMalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">size = ALIGN_UP_8_BYTES(size);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(size &lt; MEM_BLOCK_MINIMUM)</span><br><span class="line">size = MEM_BLOCK_MINIMUM;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">size += <span class="keyword">sizeof</span>(struct SLMemBlock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(size &gt;= THRESHOLD_FOR_MMAP)</span><br><span class="line"><span class="keyword">return</span> MallocBymmap(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> MallocBySegmentList(size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MallocBymmap函数。首先对加过头部的size进行4KB的对齐，通过mmap分配区域，让内核创建一个包含size字节的、请求二进制零的虚拟主存区域。如果调用成功，addr指代新区域的地址。将块头部写入区域的开始位置，返回主体的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">MallocBymmap</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line">&#123;</span><br><span class="line">size = ALIGN_UP_4KB(size);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *addr = mmap(<span class="literal">NULL</span>, size, PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(addr == MAP_FAILED)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SLMemBlock</span> *<span class="title">p</span> =</span> (struct SLMemBlock *)addr;</span><br><span class="line"></span><br><span class="line">p-&gt;CurBlkInUseBit = <span class="number">1</span>;</span><br><span class="line">p-&gt;PrevBlkInUseBit = <span class="number">1</span>;</span><br><span class="line">p-&gt;FromMmapBit = <span class="number">1</span>;</span><br><span class="line">p-&gt;ulBlockSize = size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">char</span> *)addr + <span class="keyword">sizeof</span>(struct SLMemBlock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MallocBySegmentList函数。遍历所有Segment，寻找合适的空闲块，找到返回块的主体地址。如果还没有Segment，或者找不到合适的空闲块，则获取新的Segment，在新的Segment中找到一个空闲块。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">MallocBySegmentList</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(struct SLMemSegment *pSegment = g_pSegmentList; pSegment != <span class="literal">NULL</span>; pSegment = pSegment-&gt;pNextMemSegment)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">void</span>* addr = GetFreeMemBlockFromSegment(pSegment, size);</span><br><span class="line"><span class="keyword">if</span>(addr != <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(GetAndInsertSegment() == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> GetFreeMemBlockFromSegment(g_pSegmentList, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GetAndInsertSegment函数。使用mmap函数请求一块大小为2MB的区域。将其起始位置的16字节设置为Segment头部，通过头部的前驱后继指针，将该Segment放入Segment链表的起始位置。再将8字节的块头部放入剩下部分的起始位置。由于该块目前是空闲的，将主体的最后8字节设置为脚部，包含块的大小。这里使用了强制类型转换使指针加减1对应的字节数不同，以此定位到脚部位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetAndInsertSegment</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">void</span> *addr = mmap(<span class="literal">NULL</span>, SEGMENT_SIZE, PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(addr == MAP_FAILED)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SLMemSegment</span> *<span class="title">pSegment</span> =</span> (struct SLMemSegment *)addr;</span><br><span class="line"></span><br><span class="line">pSegment-&gt;pNextMemSegment = g_pSegmentList;</span><br><span class="line">pSegment-&gt;pPrevMemSegment = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(g_pSegmentList != <span class="literal">NULL</span>)</span><br><span class="line">g_pSegmentList-&gt;pPrevMemSegment = pSegment;</span><br><span class="line"></span><br><span class="line">g_pSegmentList = pSegment;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SLMemBlock</span> *<span class="title">pFirstBlock</span> =</span> (struct SLMemBlock *)((<span class="keyword">char</span> *)addr + <span class="keyword">sizeof</span>(struct SLMemSegment));</span><br><span class="line"></span><br><span class="line">pFirstBlock-&gt;CurBlkInUseBit = <span class="number">0</span>;</span><br><span class="line">pFirstBlock-&gt;PrevBlkInUseBit = <span class="number">1</span>;</span><br><span class="line">pFirstBlock-&gt;FromMmapBit = <span class="number">0</span>;</span><br><span class="line">pFirstBlock-&gt;ulBlockSize = SEGMENT_SIZE - <span class="keyword">sizeof</span>(struct SLMemSegment);</span><br><span class="line"></span><br><span class="line">*((<span class="keyword">unsigned</span> <span class="keyword">long</span> *)((<span class="keyword">char</span> *)pFirstBlock + pFirstBlock-&gt;ulBlockSize) - <span class="number">1</span>) = pFirstBlock-&gt;ulBlockSize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GetFreeMemBlockFromSegment函数，从Segment中获取空闲块。输入为一个Segment地址和请求的块大小。遍历所有Segmetn中的所有块，找到当前未使用的(空闲)，满足请求大小的块。如果分割空闲块后的剩余部分比最小块大小要小，就不分割，更新下一块(如果有)的PrevBlkInUseBit位。如果可以分割，写新块的头部和脚部。更新空闲块的大小，返回找到空闲块的主体地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">GetFreeMemBlockFromSegment</span><span class="params">(struct SLMemSegment *pSegment, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SLMemBlock</span> *<span class="title">pBlock</span> =</span> (struct SLMemBlock *)((<span class="keyword">char</span> *)pSegment + <span class="keyword">sizeof</span>(struct SLMemSegment));</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SLMemBlock</span> *<span class="title">pEndBlock</span> =</span> (struct SLMemBlock *)((<span class="keyword">char</span> *)pSegment + SEGMENT_SIZE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(; pBlock &lt; pEndBlock; pBlock = (struct SLMemBlock *)((<span class="keyword">char</span> *)pBlock + pBlock-&gt;ulBlockSize))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(pBlock-&gt;CurBlkInUseBit == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pBlock-&gt;ulBlockSize &lt; size)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pBlock-&gt;ulBlockSize - size &lt; MEM_BLOCK_MINIMUM)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SLMemBlock</span> *<span class="title">pNextBlock</span> =</span> (struct SLMemBlock *)((<span class="keyword">char</span> *)pBlock + pBlock-&gt;ulBlockSize);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pNextBlock &lt; pEndBlock)</span><br><span class="line">pNextBlock-&gt;PrevBlkInUseBit = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">struct SLMemBlock *pNextBlock = (struct SLMemBlock *)((<span class="keyword">char</span> *)pBlock + size);</span><br><span class="line"></span><br><span class="line">pNextBlock-&gt;CurBlkInUseBit = <span class="number">0</span>;</span><br><span class="line">pNextBlock-&gt;PrevBlkInUseBit = <span class="number">1</span>;</span><br><span class="line">pNextBlock-&gt;FromMmapBit = <span class="number">0</span>;</span><br><span class="line">pNextBlock-&gt;ulBlockSize = pBlock-&gt;ulBlockSize - size;</span><br><span class="line"></span><br><span class="line">*((<span class="keyword">unsigned</span> <span class="keyword">long</span> *)((<span class="keyword">char</span> *)pNextBlock + pNextBlock-&gt;ulBlockSize) - <span class="number">1</span>) = pNextBlock-&gt;ulBlockSize;</span><br><span class="line"></span><br><span class="line">pBlock-&gt;ulBlockSize = size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pBlock-&gt;CurBlkInUseBit = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">char</span> *)pBlock + <span class="keyword">sizeof</span>(struct SLMemBlock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IsTheLastBlockInSegment函数，判断某块是否是某Segment的最后一个块。输入为某块地址。遍历段，如果该块地址大于Segment地址且该块下一字节的地址小于Segment下一字节的地址，说明该块不是最后一块，返回0。如果该块的下一字节地址，和某Segment下一字节的地址相同则为最后一块，返回1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsTheLastBlockInSegment</span><span class="params">(struct SLMemBlock *pBlock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *pEnd = (<span class="keyword">char</span> *)pBlock + pBlock-&gt;ulBlockSize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(struct SLMemSegment *pSegment = g_pSegmentList; pSegment != <span class="literal">NULL</span>; pSegment = pSegment-&gt;pNextMemSegment)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">char</span> *pSegmentEnd = (<span class="keyword">char</span> *)pSegment + SEGMENT_SIZE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(((<span class="keyword">char</span> *)pBlock &gt; (<span class="keyword">char</span> *)pSegment) &amp;&amp; (pEnd &lt; pSegmentEnd))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pEnd == pSegmentEnd)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="释放原理"><a href="#释放原理" class="headerlink" title="释放原理"></a>释放原理</h2><p>MyFree函数。输入一个块的主体地址。检查块头部，如果是mmap分配的区域，调用unmap释放区域。检查该块是否是最后一块。如果不是最后一块，如果下一块也空闲，记录新的块大小加上下一块大小。如果上一块也空闲，记录新的块大小加上上一块大小，同时更新型的块地址为上一块地址，更新新块的头部和脚部。如果新块不是Segment的最后一块，更新下一块头部的PrevBlkInUseBit=0。如果新块是最后一块，且块大小和去了Segment头部的Segment一样大，说明Segment为空，调用FreeSegment函数释放Segment。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyFree</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(ptr == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SLMemBlock</span> *<span class="title">pBlock</span> =</span> (struct SLMemBlock *)((<span class="keyword">char</span> *)ptr - <span class="keyword">sizeof</span>(struct SLMemBlock));</span><br><span class="line"><span class="keyword">if</span>(pBlock-&gt;FromMmapBit == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">munmap((<span class="keyword">void</span>*)pBlock, pBlock-&gt;ulBlockSize);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> len = pBlock-&gt;ulBlockSize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> bLast = IsTheLastBlockInSegment(pBlock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!bLast)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SLMemBlock</span> *<span class="title">pNextBlock</span> =</span> (struct SLMemBlock *)((<span class="keyword">char</span> *)pBlock + len);</span><br><span class="line"><span class="keyword">if</span>(pNextBlock-&gt;CurBlkInUseBit == <span class="number">0</span>)</span><br><span class="line">len += pNextBlock-&gt;ulBlockSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pBlock-&gt;PrevBlkInUseBit == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> prev_size = *((<span class="keyword">unsigned</span> <span class="keyword">long</span> *)pBlock - <span class="number">1</span>);</span><br><span class="line">len += prev_size;</span><br><span class="line"></span><br><span class="line">pBlock = (struct SLMemBlock *)((<span class="keyword">char</span> *)pBlock - prev_size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pBlock-&gt;ulBlockSize = len;</span><br><span class="line">pBlock-&gt;CurBlkInUseBit = <span class="number">0</span>;</span><br><span class="line">pBlock-&gt;PrevBlkInUseBit = <span class="number">1</span>;</span><br><span class="line">pBlock-&gt;FromMmapBit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">bLast = IsTheLastBlockInSegment(pBlock);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SLMemBlock</span> *<span class="title">pNextBlock</span> =</span> (struct SLMemBlock *)((<span class="keyword">char</span> *)pBlock + pBlock-&gt;ulBlockSize);</span><br><span class="line">*((<span class="keyword">unsigned</span> <span class="keyword">long</span> *)pNextBlock - <span class="number">1</span>) = pBlock-&gt;ulBlockSize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!bLast)</span><br><span class="line">&#123;</span><br><span class="line">pNextBlock-&gt;PrevBlkInUseBit = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(pBlock-&gt;ulBlockSize == SEGMENT_SIZE - <span class="keyword">sizeof</span>(struct SLMemSegment))</span><br><span class="line">FreeSegment((struct SLMemSegment *)((<span class="keyword">char</span> *)pBlock - <span class="keyword">sizeof</span>(struct SLMemSegment)));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FreeSegment函数，释放Segment。输入参数为Segment地址。如果该Segment在Segment链表初始位置，更新g_pSegmentList指向下一个Segment，如果下一个Segment存在，修改其前驱为NULL。否则修改其前驱的后继为其后继，如果其后继存在，修改其后继的前驱为其前驱。调用munmap释放Segment所占的区域。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FreeSegment</span><span class="params">(struct SLMemSegment *pSegment)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(g_pSegmentList == pSegment)</span><br><span class="line">&#123;</span><br><span class="line">g_pSegmentList = pSegment-&gt;pNextMemSegment;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(g_pSegmentList != <span class="literal">NULL</span>)</span><br><span class="line">g_pSegmentList-&gt;pPrevMemSegment = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">pSegment-&gt;pPrevMemSegment-&gt;pNextMemSegment = pSegment-&gt;pNextMemSegment;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pSegment-&gt;pNextMemSegment != <span class="literal">NULL</span>)</span><br><span class="line">pSegment-&gt;pNextMemSegment-&gt;pPrevMemSegment = pSegment-&gt;pPrevMemSegment;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">munmap((<span class="keyword">void</span>*)pSegment, SEGMENT_SIZE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="某一时间点分配器分配的虚拟主存快照"><a href="#某一时间点分配器分配的虚拟主存快照" class="headerlink" title="某一时间点分配器分配的虚拟主存快照"></a>某一时间点分配器分配的虚拟主存快照</h2><p>实际上，Segment中的块要更多，因为块大小超过256KB就会直接mmap申请一个4KB对齐的区域，而一个Segment的大小是2M。</p><p><img src="/2021/11/08/malloc/image-20211114013556567.png" alt="image-20211114013556567"></p><h2 id="效率分析"><a href="#效率分析" class="headerlink" title="效率分析"></a>效率分析</h2><p>直接由mmap分配的块，其分配和释放完全独立。</p><p>从Segment中分配的块：</p><p>吞吐率：搜索空闲块的开销与Segment和所有块的数目线性相关。释放块时需要确认块是否为Segment中最后一块，开销与Segment数目线性相关。</p><p>主存利用率：由于是8字节对齐，分配空闲块时进行分隔，内部碎片不多。由于使用首次适配策略放置空闲块，外部碎片要看请求序列是什么样，可能会有比较多的小空闲块不能被分配。</p><h1 id="显式空闲链表，加快分配"><a href="#显式空闲链表，加快分配" class="headerlink" title="显式空闲链表，加快分配"></a>显式空闲链表，加快分配</h1><h2 id="双向空闲链表"><a href="#双向空闲链表" class="headerlink" title="双向空闲链表"></a>双向空闲链表</h2><h3 id="总体设计"><a href="#总体设计" class="headerlink" title="总体设计"></a>总体设计</h3><p>新增一个全局指针变量g_pFreeBlockList，指向空闲块链表。</p><p>在空闲块的主体里增加先驱和后继的指针。以便空闲块能找到空闲链表中的前驱和后继，在合并时好修改空闲链表。</p><p>将新释放的空闲块放到链表最前面。</p><p>分配时，首次适配策略放置块，分割，更新空闲链表。</p><p>释放时，尝试合并虚拟主存地址相邻的块，合并后更新空闲链表。</p><h2 id="效率分析-1"><a href="#效率分析-1" class="headerlink" title="效率分析"></a>效率分析</h2><p>直接由mmap分配的块，其分配和释放完全独立。</p><p>从Segment中分配的块：</p><p>吞吐率：搜索空闲块的开销最糟与空闲块数目线性相关，吞吐率有了提高。释放块时需要确认块是否为Segment中最后一块，开销与Segment数目线性相关。修改空闲链表的开销为常数时间。</p><p>主存利用率：因为块多了两个指针变量，所以最小块大小变大，由于使用了优化的边界标记，所以仅当请求的块大小很小时，内部碎片才变多。仍然使用首次适配策略放置空闲块，外部碎片要看请求序列是什么样，可能会有比较多的小空闲块不能被分配。</p><h3 id="详细设计与实现"><a href="#详细设计与实现" class="headerlink" title="详细设计与实现"></a>详细设计与实现</h3><h4 id="Segment结构"><a href="#Segment结构" class="headerlink" title="Segment结构"></a>Segment结构</h4><p>不变</p><h4 id="块结构"><a href="#块结构" class="headerlink" title="块结构"></a>块结构</h4><p>头部并没有变。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SLMemBlock</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> CurBlkInUseBit : <span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> PrevBlkInUseBit : <span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> FromMmapBit : <span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> ulBlockSize : <span class="number">61</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>变的是仅当块空闲时，写在主体中的脚部。脚部也作为链表的组成单位。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SLFreeBlock</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SLFreeBlock</span>* <span class="title">pPrevFreeBlock</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SLFreeBlock</span>* <span class="title">pNextFreeBlock</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> ulBlockSize;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>块结构示意图：</p><p>仅当块空闲时，写脚部。脚部现在包含空闲块前驱指针，空闲块后继指针，空闲块大小。现在一个块的大小最小为32字节。</p><p><img src="/2021/11/08/malloc/image-20211113165715918.png" alt="image-20211113165715918"></p><h4 id="常量和宏-1"><a href="#常量和宏-1" class="headerlink" title="常量和宏"></a>常量和宏</h4><p>最小块的大小从16字节变为32字节。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALIGN_UP_N_BYTES(size, n) ((((size) + (n) - 1) / (n)) * (n))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALIGN_UP_8_BYTES(size) ALIGN_UP_N_BYTES(size, 8)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALIGN_UP_4KB(size) ALIGN_UP_N_BYTES(size, 4096)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THRESHOLD_FOR_MMAP (256 * 1024)<span class="comment">//max block size in segment</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEGMENT_SIZE (2 * 1024 * 1024) </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEM_BLOCK_MINIMUM 32<span class="comment">//it used to be 16, now its 32</span></span></span><br></pre></td></tr></table></figure><h4 id="分配原理-1"><a href="#分配原理-1" class="headerlink" title="分配原理"></a>分配原理</h4><p>MyMalloc函数。首先8字节对齐size，再给size加上头部大小。如果size小于最小块大小32字节，size就为32字节。如果size大于等于32字节，且size大于等于256KB，调用MallocBymmap单独分配一个区域放置该块，该块的分配和释放是完全独立的。否则，调用MallocBySegmentList函数从Segment中分配一个块。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">MyMalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">size = ALIGN_UP_8_BYTES(size);</span><br><span class="line">    size += <span class="keyword">sizeof</span>(struct SLMemBlock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(size &lt; MEM_BLOCK_MINIMUM)</span><br><span class="line">size = MEM_BLOCK_MINIMUM;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(size &gt;= THRESHOLD_FOR_MMAP)</span><br><span class="line"><span class="keyword">return</span> MallocBymmap(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> MallocByFreeBlockList(size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MallocBymmap不变。</p><p>MallocBySegmentList函数，改为MallocByFreeBlock函数，调用GetFreeBlockFromFreeBlockList搜索空闲链表，寻找第一个合适的空闲块，找到返回块的主体地址，取缔了GetFreeMemBlockFromSegment。如果还没有空闲块，或者找不到合适的空闲块，则获取新的Segment，更新空闲链表，再次搜索空闲链表，第一个就是合适的空闲块。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">MallocByFreeBlockList</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* addr = GetFreeBlockFromFreeBlockList(size);</span><br><span class="line">    <span class="keyword">if</span>(addr != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> addr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(GetAndInsertSegment() == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> GetFreeBlockFromFreeBlockList(size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GetAndInsertSegment函数。使用mmap函数请求一块大小为2MB的区域。将其起始位置的16字节设置为Segment头部，通过头部的前驱后继指针，将该Segment放入Segment链表的起始位置。再将8字节的块头部放入剩下部分的起始位置。将作为空闲链表组成单元的脚部放入区域的最后24字节。将脚部放入FreeBlock链表的起始位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetAndInsertSegment</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">void</span> *addr = mmap(<span class="literal">NULL</span>, SEGMENT_SIZE, PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(addr == MAP_FAILED)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SLMemSegment</span> *<span class="title">pSegment</span> =</span> (struct SLMemSegment *)addr;</span><br><span class="line"></span><br><span class="line">pSegment-&gt;pNextMemSegment = g_pSegmentList;</span><br><span class="line">pSegment-&gt;pPrevMemSegment = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(g_pSegmentList != <span class="literal">NULL</span>)</span><br><span class="line">g_pSegmentList-&gt;pPrevMemSegment = pSegment;</span><br><span class="line"></span><br><span class="line">g_pSegmentList = pSegment;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SLMemBlock</span> *<span class="title">pFirstBlock</span> =</span> (struct SLMemBlock *)((<span class="keyword">char</span> *)addr + <span class="keyword">sizeof</span>(struct SLMemSegment));</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SLFreeBlock</span> *<span class="title">pFirstFreeBlock</span> =</span> (struct SLFreeBlock *)((<span class="keyword">unsigned</span> <span class="keyword">long</span>*)((<span class="keyword">char</span>*)addr + SEGMENT_SIZE)<span class="number">-3</span>);</span><br><span class="line">    </span><br><span class="line">pFirstBlock-&gt;CurBlkInUseBit = <span class="number">0</span>;</span><br><span class="line">pFirstBlock-&gt;PrevBlkInUseBit = <span class="number">1</span>;</span><br><span class="line">pFirstBlock-&gt;FromMmapBit = <span class="number">0</span>;</span><br><span class="line">pFirstBlock-&gt;ulBlockSize = SEGMENT_SIZE - <span class="keyword">sizeof</span>(struct SLMemSegment);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pFirstFreeBlock-&gt;ulBlockSize = pFirstBlock-&gt;ulBlockSize;</span><br><span class="line">    pFirstFreeBlock-&gt;pPrevFreeBlock = <span class="literal">NULL</span>;</span><br><span class="line">    pFirstFreeBlock-&gt;pNextFreeBlock = g_pFreeBlockList;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(g_pFreeBlockList != <span class="literal">NULL</span>)</span><br><span class="line">g_pFreeBlockList-&gt;pPrevFreeBlock = pFirstFreeBlock;</span><br><span class="line">    </span><br><span class="line">    g_pFreeBlockList = pFirstFreeBlock;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GetFreeMemBlockFromSegment函数，改为GetFreeMemBlockFromFreeBlockList。遍历空闲块链表，找到当前未使用的(空闲)，满足请求大小的块。如果分割空闲块后的剩余部分比最小块大小要小，就不分割，更新空闲链表，如果有，更新下一块的PrevBlkInUseBit位。如果可以分割，写新块的头部和脚部，更新空闲链表。更新空闲块的大小，返回找到空闲块的主体地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">GetFreeBlockFromFreeBlockList</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SLFreeBlock</span>* <span class="title">pFreeBlock</span> =</span> g_pFreeBlockList;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span>(; <span class="literal">NULL</span> != pFreeBlock; pFreeBlock = pFreeBlock-&gt;pNextFreeBlock)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pFreeBlock-&gt;ulBlockSize &lt; size)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">     </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">SLMemBlock</span>* <span class="title">pBlock</span> =</span> (struct SLMemBlock*)( (<span class="keyword">unsigned</span> <span class="keyword">long</span>*)( (<span class="keyword">char</span>*)(pFreeBlock) - pFreeBlock-&gt;ulBlockSize ) + <span class="number">3</span> );</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//nocut</span></span><br><span class="line">        <span class="keyword">if</span>(pFreeBlock-&gt;ulBlockSize - size &lt; MEM_BLOCK_MINIMUM)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//Delete pFreeBlock from FreeBlockList</span></span><br><span class="line">            <span class="keyword">if</span>(g_pFreeBlockList == pFreeBlock)</span><br><span class="line">            &#123;</span><br><span class="line">                g_pFreeBlockList = pFreeBlock-&gt;pNextFreeBlock;</span><br><span class="line">                <span class="keyword">if</span>(g_pFreeBlockList != <span class="literal">NULL</span>)</span><br><span class="line">                g_pFreeBlockList-&gt;pPrevFreeBlock = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pFreeBlock-&gt;pPrevFreeBlock-&gt;pNextFreeBlock = pFreeBlock-&gt;pNextFreeBlock;</span><br><span class="line">                <span class="keyword">if</span>(pFreeBlock-&gt;pNextFreeBlock != <span class="literal">NULL</span>)</span><br><span class="line">            pFreeBlock-&gt;pNextFreeBlock-&gt;pPrevFreeBlock = pFreeBlock-&gt;pPrevFreeBlock;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">SLMemBlock</span>* <span class="title">pNextBlock</span> =</span> (struct SLMemBlock *)( (<span class="keyword">char</span>*)pFreeBlock + <span class="keyword">sizeof</span>(struct SLFreeBlock) );  </span><br><span class="line">            <span class="keyword">int</span> bLast = IsTheLastBlockInSegment(pBlock);</span><br><span class="line">            <span class="keyword">if</span>(!bLast)</span><br><span class="line">pNextBlock-&gt;PrevBlkInUseBit = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cut</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//add new header</span></span><br><span class="line">            struct SLMemBlock* pNextBlock = (struct SLMemBlock *)( (<span class="keyword">char</span>*)pBlock + size );</span><br><span class="line">pNextBlock-&gt;CurBlkInUseBit = <span class="number">0</span>;</span><br><span class="line">pNextBlock-&gt;PrevBlkInUseBit = <span class="number">1</span>;</span><br><span class="line">pNextBlock-&gt;FromMmapBit = <span class="number">0</span>;</span><br><span class="line">pNextBlock-&gt;ulBlockSize = pBlock-&gt;ulBlockSize - size;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//add new footer</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">SLFreeBlock</span>* <span class="title">pNextFreeBlock</span> =</span> (struct SLFreeBlock*)((<span class="keyword">unsigned</span> <span class="keyword">long</span>*)((<span class="keyword">char</span>*)pNextBlock + pNextBlock-&gt;ulBlockSize) - <span class="number">3</span>);</span><br><span class="line">pNextFreeBlock-&gt;ulBlockSize = pNextBlock-&gt;ulBlockSize;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//Delete pFreeBlock from FreeBlockList</span></span><br><span class="line">            <span class="keyword">if</span>(g_pFreeBlockList == pFreeBlock)</span><br><span class="line">            &#123;</span><br><span class="line">                g_pFreeBlockList = pFreeBlock-&gt;pNextFreeBlock;</span><br><span class="line">                <span class="keyword">if</span>(g_pFreeBlockList != <span class="literal">NULL</span>)</span><br><span class="line">                g_pFreeBlockList-&gt;pPrevFreeBlock = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pFreeBlock-&gt;pPrevFreeBlock-&gt;pNextFreeBlock = pFreeBlock-&gt;pNextFreeBlock;</span><br><span class="line">                <span class="keyword">if</span>(pFreeBlock-&gt;pNextFreeBlock != <span class="literal">NULL</span>)</span><br><span class="line">            pFreeBlock-&gt;pNextFreeBlock-&gt;pPrevFreeBlock = pFreeBlock-&gt;pPrevFreeBlock;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//add pNextFreeBlock to FreeBlockList</span></span><br><span class="line">            pNextFreeBlock-&gt;pPrevFreeBlock = <span class="literal">NULL</span>;</span><br><span class="line">            pNextFreeBlock-&gt;pNextFreeBlock = g_pFreeBlockList;</span><br><span class="line">            <span class="keyword">if</span>(g_pFreeBlockList != <span class="literal">NULL</span>)</span><br><span class="line">                g_pFreeBlockList-&gt;pPrevFreeBlock = pNextFreeBlock;</span><br><span class="line">            g_pFreeBlockList = pNextFreeBlock;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//update old size</span></span><br><span class="line">pBlock-&gt;ulBlockSize = size;           </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//update CurBlkInUseBit</span></span><br><span class="line">pBlock-&gt;CurBlkInUseBit = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">char</span> *)pBlock + <span class="keyword">sizeof</span>(struct SLMemBlock);        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IsTheLastBlockInSegment函数，不变。</p><h4 id="释放原理-1"><a href="#释放原理-1" class="headerlink" title="释放原理"></a>释放原理</h4><p>MyFree函数。输入一个块的主体地址。检查块头部，如果是mmap分配的区域，调用unmap释放区域。检查该块是否是最后一块。如果不是最后一块，如果下一块也空闲，记录新的块大小加上下一块大小，删除空闲链表。如果上一块也空闲，记录新的块大小加上上一块大小，删除空闲链表，同时更新型的块地址为上一块地址，更新新块的头部和脚部，更新空闲链表。如果新块不是Segment的最后一块，更新下一块头部的PrevBlkInUseBit=0，增加空闲链表。如果新块是最后一块，且块大小和去了Segment头部的Segment一样大，说明Segment为空，调用FreeSegment函数释放Segment，否则增加空闲链表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyFree</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(ptr == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SLMemBlock</span> *<span class="title">pBlock</span> =</span> (struct SLMemBlock *)((<span class="keyword">char</span> *)ptr - <span class="keyword">sizeof</span>(struct SLMemBlock));</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SLFreeBlock</span> *<span class="title">pFreeBlock</span> =</span> (struct SLFreeBlock *)( (<span class="keyword">unsigned</span> <span class="keyword">long</span>*)( (<span class="keyword">char</span> *)pNextBlock + pBlock-&gt;ulBlockSize ) - <span class="number">3</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//free by ummap</span></span><br><span class="line">    <span class="keyword">if</span>(pBlock-&gt;FromMmapBit == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">munmap((<span class="keyword">void</span>*)pBlock, pBlock-&gt;ulBlockSize);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> len = pBlock-&gt;ulBlockSize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> bLast = IsTheLastBlockInSegment(pBlock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//not last block</span></span><br><span class="line"><span class="keyword">if</span>(!bLast)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SLMemBlock</span> *<span class="title">pNextBlock</span> =</span> (struct SLMemBlock *)((<span class="keyword">char</span> *)pBlock + len);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SLFreeBlock</span> *<span class="title">pNextBlockFooter</span> =</span> (struct SLFreeBlock *)( (<span class="keyword">unsigned</span> <span class="keyword">long</span>*)( (<span class="keyword">char</span> *)pNextBlock + pBlock-&gt;ulBlockSize ) - <span class="number">3</span> );        </span><br><span class="line">        <span class="comment">//next block is free</span></span><br><span class="line">        <span class="keyword">if</span>(pNextBlock-&gt;CurBlkInUseBit == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//update size of new block</span></span><br><span class="line">            len += pNextBlock-&gt;ulBlockSize;</span><br><span class="line">            <span class="comment">//Delete pNextBlockFooter from FreeBlockList</span></span><br><span class="line">            <span class="keyword">if</span>(g_pFreeBlockList == pNextBlockFooter)</span><br><span class="line">            &#123;</span><br><span class="line">                g_pFreeBlockList = pNextBlockFooter-&gt;pNextFreeBlock;</span><br><span class="line">                <span class="keyword">if</span>(g_pFreeBlockList != <span class="literal">NULL</span>)</span><br><span class="line">                    g_pFreeBlockList-&gt;pPrevFreeBlock = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                pNextBlockFooter-&gt;pPrevFreeBlock-&gt;pNextFreeBlock = pNextBlockFooter-&gt;pNextFreeBlock;</span><br><span class="line">                <span class="keyword">if</span>(pNextBlockFooter-&gt;pNextFreeBlock != <span class="literal">NULL</span>)</span><br><span class="line">                    pNextBlockFooter-&gt;pNextFreeBlock-&gt;pPrevFreeBlock = pNextBlockFooter-&gt;pPrevFreeBlock;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//prev block is free</span></span><br><span class="line"><span class="keyword">if</span>(pBlock-&gt;PrevBlkInUseBit == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">SLFreeBlock</span>* <span class="title">pPrevBlockFooter</span> =</span> (struct SLFreeBlock*)( (<span class="keyword">unsigned</span> <span class="keyword">long</span>*)pBlock - <span class="number">3</span> );</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> prev_size = pPrevBlockFooter-&gt;ulBlockSize;</span><br><span class="line"><span class="comment">//update size of new block</span></span><br><span class="line">        len += prev_size;</span><br><span class="line"><span class="comment">//Delete pPrevBlockFooter from FreeBlockList</span></span><br><span class="line">        <span class="keyword">if</span>(g_pFreeBlockList == pPrevBlockFooter)</span><br><span class="line">        &#123;</span><br><span class="line">            g_pFreeBlockList = pPrevBlockFooter-&gt;pNextFreeBlock;</span><br><span class="line">            <span class="keyword">if</span>(g_pFreeBlockList != <span class="literal">NULL</span>)</span><br><span class="line">                g_pFreeBlockList-&gt;pPrevFreeBlock = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pPrevBlockFooter-&gt;pPrevFreeBlock-&gt;pNextFreeBlock = pPrevBlockFooter-&gt;pNextFreeBlock;</span><br><span class="line">            <span class="keyword">if</span>(pPrevBlockFooter-&gt;pNextFreeBlock != <span class="literal">NULL</span>)</span><br><span class="line">                pPrevBlockFooter-&gt;pNextFreeBlock-&gt;pPrevFreeBlock = pPrevBlockFooter-&gt;pPrevFreeBlock;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//update pBlock</span></span><br><span class="line">pBlock = (struct SLMemBlock *)((<span class="keyword">char</span> *)pBlock - prev_size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//new header</span></span><br><span class="line">pBlock-&gt;ulBlockSize = len;</span><br><span class="line">pBlock-&gt;CurBlkInUseBit = <span class="number">0</span>;</span><br><span class="line">pBlock-&gt;PrevBlkInUseBit = <span class="number">1</span>;</span><br><span class="line">pBlock-&gt;FromMmapBit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//new footer</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SLMemBlock</span> *<span class="title">pNextBlock</span> =</span> (struct SLMemBlock *)((<span class="keyword">char</span> *)pBlock + pBlock-&gt;ulBlockSize);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SLFreeBlock</span> *<span class="title">pBlockFooter</span> =</span> (struct SLFreeBlock *)( (<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(pNextBlock) - <span class="number">3</span> );</span><br><span class="line">    pBlockFooter-&gt;ulBlockSize = pBlock-&gt;ulBlockSize;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//new block is not last block</span></span><br><span class="line">bLast = IsTheLastBlockInSegment(pBlock);</span><br><span class="line"><span class="keyword">if</span>(!bLast)</span><br><span class="line">&#123;</span><br><span class="line">pNextBlock-&gt;PrevBlkInUseBit = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//add new footer to FreeBlockList</span></span><br><span class="line">        pBlockFooter-&gt;pPrevFreeBlock = <span class="literal">NULL</span>;</span><br><span class="line">        pBlockFooter-&gt;pNextFreeBlock = g_pFreeBlockList;</span><br><span class="line">        <span class="keyword">if</span>(g_pFreeBlockList != <span class="literal">NULL</span>)</span><br><span class="line">            g_pFreeBlockList-&gt;pPrevFreeBlock = pBlockFooter;</span><br><span class="line">        g_pFreeBlockList = pBlockFooter;  </span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//new block is last</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">//segment is free</span></span><br><span class="line"><span class="keyword">if</span>(pBlock-&gt;ulBlockSize == SEGMENT_SIZE - <span class="keyword">sizeof</span>(struct SLMemSegment))</span><br><span class="line">        &#123;</span><br><span class="line">FreeSegment((struct SLMemSegment *)((<span class="keyword">char</span> *)pBlock - <span class="keyword">sizeof</span>(struct SLMemSegment)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//segment is not free</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//add new footer to FreeBlockList</span></span><br><span class="line">            pBlockFooter-&gt;pPrevFreeBlock = <span class="literal">NULL</span>;</span><br><span class="line">            pBlockFooter-&gt;pNextFreeBlock = g_pFreeBlockList;</span><br><span class="line">            <span class="keyword">if</span>(g_pFreeBlockList != <span class="literal">NULL</span>)</span><br><span class="line">                g_pFreeBlockList-&gt;pPrevFreeBlock = pBlockFooter;</span><br><span class="line">            g_pFreeBlockList = pBlockFooter;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FreeSegment函数，不变。</p><h4 id="某一时间点分配器分配的虚拟主存快照-1"><a href="#某一时间点分配器分配的虚拟主存快照-1" class="headerlink" title="某一时间点分配器分配的虚拟主存快照"></a>某一时间点分配器分配的虚拟主存快照</h4><p><img src="/2021/11/08/malloc/image-20211114014635415.png" alt="image-20211114014635415"></p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>测试单个Segment</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *p1 = MyMalloc(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">void</span> *p2 = MyMalloc(<span class="number">256</span>*<span class="number">1024</span>);</span><br><span class="line"><span class="keyword">void</span> *p3 = MyMalloc(<span class="number">64</span>);</span><br><span class="line"><span class="keyword">void</span> *p4 = MyMalloc(<span class="number">71</span>);</span><br><span class="line">MyFree(p1);</span><br><span class="line">MyFree(p2);</span><br><span class="line"><span class="keyword">void</span> *p5 = MyMalloc(<span class="number">420</span>*<span class="number">1024</span>);</span><br><span class="line"><span class="keyword">void</span> *p6 = MyMalloc(<span class="number">99</span>);</span><br><span class="line">MyFree(p4);</span><br><span class="line">MyFree(p3);</span><br><span class="line">MyFree(p6);</span><br><span class="line">MyFree(p5);</span><br></pre></td></tr></table></figure><p>测试两个Segment</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *p1 = MyMalloc(<span class="number">262120</span>);  <span class="comment">//256*1024-24</span></span><br><span class="line"><span class="keyword">void</span> *p2 = MyMalloc(<span class="number">262120</span>);</span><br><span class="line"><span class="keyword">void</span> *p3 = MyMalloc(<span class="number">262120</span>);</span><br><span class="line"><span class="keyword">void</span> *p4 = MyMalloc(<span class="number">262120</span>);</span><br><span class="line"><span class="keyword">void</span> *p5 = MyMalloc(<span class="number">262120</span>);</span><br><span class="line"><span class="keyword">void</span> *p6 = MyMalloc(<span class="number">262120</span>);</span><br><span class="line"><span class="keyword">void</span> *p7 = MyMalloc(<span class="number">262120</span>);</span><br><span class="line"><span class="keyword">void</span> *p8 = MyMalloc(<span class="number">262120</span>);</span><br><span class="line"><span class="keyword">void</span> *p9 = MyMalloc(<span class="number">262120</span>);</span><br><span class="line">MyFree(p9);</span><br><span class="line">MyFree(p8);</span><br><span class="line">MyFree(p4);</span><br><span class="line">MyFree(p3);</span><br><span class="line">MyFree(p7);</span><br><span class="line">MyFree(p1);</span><br><span class="line">MyFree(p2);</span><br><span class="line">MyFree(p5);</span><br><span class="line">MyFree(p6);</span><br></pre></td></tr></table></figure><h2 id="分离空闲链表-To-Do"><a href="#分离空闲链表-To-Do" class="headerlink" title="分离空闲链表 To Do"></a>分离空闲链表 To Do</h2><p>将块大小分成数个类，分配器维护一个空闲链表数组，每个空闲链表包含对应大小的空闲块</p><h1 id="加锁，并发分配"><a href="#加锁，并发分配" class="headerlink" title="加锁，并发分配"></a>加锁，并发分配</h1><h3 id="为什么要加锁"><a href="#为什么要加锁" class="headerlink" title="为什么要加锁"></a>为什么要加锁</h3><p>比如这样一个场景：多线程递减一全局变量的问题。</p><p>C编译器将增减运算转换成3条机器指令：从内存装载到寄存器，递减寄存器，从寄存器存储到内存。</p><p>某个出错情形：线程A运行，把nconn的值3装载到一个寄存器。系统把运行线程从A切换到B，A的寄存器被保存，B的寄存器被恢复。线程B执行与C表达式nconn–相对应的3条指令，把新值2存储到nconn。一段时间后，系统把运行线程从B切换回A。A的寄存器被恢复，A从原来离开的地方继续执行，把那个寄存器值从3减为2，再把值2存储到nconn。由于A没读到B减过的数据，所以最后A写了脏数据到nocnn中。</p><p><strong>把问题放大的测试代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;pthread.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NLOOP 5000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> counter; <span class="comment">/* incremented by threads */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">doit</span><span class="params">(<span class="keyword">void</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> </span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">pthread_t</span> tidA, tidB;</span><br><span class="line"></span><br><span class="line">  Pthread_create(&amp;tidA, <span class="literal">NULL</span>, &amp;doit, <span class="literal">NULL</span>);</span><br><span class="line">  Pthread_create(&amp;tidB, <span class="literal">NULL</span>, &amp;doit, <span class="literal">NULL</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* wait for both threads to terminate */</span></span><br><span class="line">  Pthread_join(tidA, <span class="literal">NULL</span>);</span><br><span class="line">  Pthread_join(tidB, <span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">doit</span><span class="params">(<span class="keyword">void</span> *vptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, val;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Each threads fetches, prints, and increments the counter NLOOP times.The value of the counter should increase monotonically.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NLOOP; i++)&#123;</span><br><span class="line">    val = counter;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d: %d\n&quot;</span>, pthread_self(), val + <span class="number">1</span>);</span><br><span class="line">    counter = val + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>某段结果：<img src="/2021/11/08/malloc/image-20211113232125079.png" alt="image-20211113232125079"></p><h3 id="同步锁"><a href="#同步锁" class="headerlink" title="同步锁"></a>同步锁</h3><p>在主线程中初始化锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_mutex_t</span> allocater_mutex = PTHREAD_MUTEX_INITIALIZER;</span><br></pre></td></tr></table></figure><p>在线程执行的函数中加锁，解锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pthread_mutex_lock(&amp;counter_mutex);</span><br><span class="line">......</span><br><span class="line">Pthread_mutex_unlock(&amp;counter_mutex);</span><br></pre></td></tr></table></figure><h3 id="异步锁-To-Do"><a href="#异步锁-To-Do" class="headerlink" title="异步锁 To Do"></a>异步锁 To Do</h3><h3 id="每个线程一个私有空闲链表-To-Do"><a href="#每个线程一个私有空闲链表-To-Do" class="headerlink" title="每个线程一个私有空闲链表 To Do"></a>每个线程一个私有空闲链表 To Do</h3><h3 id="futex-To-Do"><a href="#futex-To-Do" class="headerlink" title="futex To Do"></a>futex To Do</h3><h3 id="CAS免锁-Compared-and-Swap-To-Do"><a href="#CAS免锁-Compared-and-Swap-To-Do" class="headerlink" title="CAS免锁 Compared and Swap To Do"></a>CAS免锁 Compared and Swap To Do</h3>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>特征函数</title>
      <link href="/2021/11/08/%E7%89%B9%E5%BE%81%E5%87%BD%E6%95%B0/"/>
      <url>/2021/11/08/%E7%89%B9%E5%BE%81%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="泰勒展开式"><a href="#泰勒展开式" class="headerlink" title="泰勒展开式"></a>泰勒展开式</h1><h1 id="傅里叶变换"><a href="#傅里叶变换" class="headerlink" title="傅里叶变换"></a>傅里叶变换</h1><h1 id="概率密度的特征函数"><a href="#概率密度的特征函数" class="headerlink" title="概率密度的特征函数"></a>概率密度的特征函数</h1><h1 id="特征函数的用途"><a href="#特征函数的用途" class="headerlink" title="特征函数的用途"></a>特征函数的用途</h1>]]></content>
      
      
      <categories>
          
          <category> 数 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>力</title>
      <link href="/2021/11/08/%E5%8A%9B/"/>
      <url>/2021/11/08/%E5%8A%9B/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 力 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>信号发射器</title>
      <link href="/2021/11/08/%E4%BF%A1%E5%8F%B7%E5%8F%91%E5%B0%84%E5%99%A8/"/>
      <url>/2021/11/08/%E4%BF%A1%E5%8F%B7%E5%8F%91%E5%B0%84%E5%99%A8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 电 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++的引用</title>
      <link href="/2021/11/07/%E5%BC%95%E7%94%A8/"/>
      <url>/2021/11/07/%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="写在前面的话："><a href="#写在前面的话：" class="headerlink" title="写在前面的话："></a>写在前面的话：</h1><p>&emsp;&emsp;<strong>rbp一般保存栈基址，rsp一般保存栈顶地址，rax一般用作保存返回值，rdi一般用作传一个参数</strong></p><p>&emsp;&emsp;<strong>rbp，rsp的值进入不同函数后是发生改变的</strong></p><p>&emsp;&emsp;<strong>使用gdb的layout regs方式进行汇编代码的调试</strong></p><h1 id="实验的结论是"><a href="#实验的结论是" class="headerlink" title="实验的结论是"></a>实验的结论是</h1><p><strong>这样理解：每个函数都有一个返回变量，放在rax寄存器中，而不要用返回值来称呼返回的东西。</strong></p><p><em><em>type&amp; 引用类型的变量：存放了赋值语句右边的type类型变量的地址，①在赋值时当作type变量使用，②在做形参时传地址(type</em>)，实参是存放这个地址的type&amp;引用变量，③在做返回变量时其实也就是赋值(某变量赋值给返回变量，返回变量赋值给接受变量)。</em>*</p><p>type&amp;作为函数的返回类型，相当于把rax寄存器作为引用变量使用，存放了return语句右边type类型变量的type*地址，当做type类型变量使用。</p><p>使用type变量接收type&amp;返回变量，type&amp;返回变量当做type类型的变量使用，即把返回变量的type值赋值给type接收变量。即把return语句右边的type类型变量赋值给type类型接收变量。</p><p>使用type&amp;变量接收type&amp;返回变量，type&amp;返回变量当做type类型的变量使用，接收变量存放返回变量的地址，可以当做type类型变量使用。即体type&amp;接收变量，存放return语句右边的type类型变量的地址，并当做type类型变量使用。</p><p><strong>对象实际上就是栈上的几个成员变量，函数都在代码区</strong>。</p><p><strong>当把返回对象直接赋值给接收对象时，只需要在局部函数中执行一次构造函数</strong></p><p><strong>除了调用构造函数外，与普通变量的引用并无什么差别</strong></p><h1 id="普通变量的引用类型"><a href="#普通变量的引用类型" class="headerlink" title="普通变量的引用类型"></a>普通变量的引用类型</h1><h2 id="main函数中，int赋值给int"><a href="#main函数中，int赋值给int" class="headerlink" title="main函数中，int赋值给int"></a>main函数中，int赋值给int</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = a;</span><br><span class="line">        <span class="comment">//int c[20] = &#123;0&#125;;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/11/07/%E5%BC%95%E7%94%A8/1.png" alt="1.png"></p><p>-0x8(%rbp)存放a的值，-0x4(%rbp)存放b的值。</p><p>注：只有ab变量时，没有sub rsp的操作，a,b在栈顶之外，加上c[20]数组后才有sub rsp的操作。</p><h2 id="main函数中，int赋值给int-amp"><a href="#main函数中，int赋值给int-amp" class="headerlink" title="main函数中，int赋值给int&amp;"></a>main函数中，int赋值给int&amp;</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; b = a;</span><br><span class="line">a = <span class="number">3</span>; </span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/11/07/%E5%BC%95%E7%94%A8/2.png" alt="2"></p><p>-0x14(%rbp)存放变量a的值，-0x10(%rbp)存放b的值，为变量a的地址。</p><h2 id="其它函数中-形参为引用类型"><a href="#其它函数中-形参为引用类型" class="headerlink" title="其它函数中,形参为引用类型"></a>其它函数中,形参为引用类型</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>&amp; c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        c = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>&amp; b = a;</span><br><span class="line">        <span class="built_in">f</span>(b);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/11/07/%E5%BC%95%E7%94%A8/3.png" alt="3"></p><p>-0x14(%rbp)存放变量a的值，-0x10(%rbp)存放变量b的值，为变量a的地址。变量a的地址存放到rdi，作为参数传给函数f。</p><p><img src="/2021/11/07/%E5%BC%95%E7%94%A8/4.png" alt="4"></p><p>-0x8(%rbp)存放变量c的值，为变量a的地址，将该地址上的值变为3。我们看到，函数f()获得了main函数中变量的指针。我们再来看一下void f(int*)的反汇编代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>* c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        *c = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> *b = &amp;a;</span><br><span class="line">        <span class="built_in">f</span>(b);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/11/07/%E5%BC%95%E7%94%A8/5.png" alt="5"></p><p><img src="/2021/11/07/%E5%BC%95%E7%94%A8/6.png" alt="6"></p><p>和传指针的汇编代码，执行的操作是一样的。</p><h2 id="其它函数中-返回类型为引用类型"><a href="#其它函数中-返回类型为引用类型" class="headerlink" title="其它函数中,返回类型为引用类型"></a>其它函数中,返回类型为引用类型</h2><h3 id="return-局部变量"><a href="#return-局部变量" class="headerlink" title="return 局部变量"></a>return 局部变量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">f</span><span class="params">(<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        b = b+<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="built_in">f</span>(a);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>报错：</p><p><img src="/2021/11/07/%E5%BC%95%E7%94%A8/image-20211107155329342.png" alt="image-20211107155329342"></p><p><img src="/2021/11/07/%E5%BC%95%E7%94%A8/image-20211107160841526.png" alt="image-20211107160841526"></p><p>gdb调试查看汇编</p><p><img src="/2021/11/07/%E5%BC%95%E7%94%A8/image-20211107161603255.png" alt="image-20211107161603255"></p><p>main函数，-0x8(%rbp)存放a变量，赋值为1，传给rdi寄存器(edi是rdi的低32位)。</p><p><img src="/2021/11/07/%E5%BC%95%E7%94%A8/image-20211107162450323.png" alt="image-20211107162450323"></p><p>f()中，-0x4(%rbp)存放变量b，b赋值为1+2，将0放入rax寄存器(eax是rax的低32位)。</p><p><img src="/2021/11/07/%E5%BC%95%E7%94%A8/image-20211107162822226.png" alt="image-20211107162822226"></p><p>返回main函数，mov (%rax), %eax的意思是：将以rax寄存器的值指向的内容，放入到rax寄存器(给eax赋值会改变整个rax)中。执行该句后，报错，显然是因为rax里的值是0的缘故：</p><p><img src="/2021/11/07/%E5%BC%95%E7%94%A8/image-20211107162939823.png" alt="image-20211107162939823"></p><p>段错误，访问了不该访问的内存！</p><p><strong>结论：不可将局部变量作为引用类型返回！</strong></p><hr><h3 id="return-堆上空间的值"><a href="#return-堆上空间的值" class="headerlink" title="return 堆上空间的值"></a>return 堆上空间的值</h3><h4 id="将int-amp-类型的返回值赋值给int类型的变量"><a href="#将int-amp-类型的返回值赋值给int类型的变量" class="headerlink" title="将int&amp;类型的返回值赋值给int类型的变量"></a>将int&amp;类型的返回值赋值给int类型的变量</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">f</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>* b =(<span class="keyword">int</span>*) <span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br><span class="line">        *b = a+<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> *b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="built_in">f</span>(a);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/11/07/%E5%BC%95%E7%94%A8/image-20211107170640916.png" alt="image-20211107170640916"></p><p>main函数中，-0x8(%rip)存放了变量a，rdi寄存器保存变量a的值1，进入f()</p><p><img src="/2021/11/07/%E5%BC%95%E7%94%A8/image-20211107171606010.png" alt="image-20211107171606010"></p><p>f()函数中，-0x14(%rbp)存放值1，rdi赋值为4作为malloc的参数，调用malloc函数。</p><p>malloc函数返回后，rax已经存放了堆上的地址，-0x8(%rbp)存放int* b变量，将堆上地址赋值给int* b变量。</p><p>lea 0x2(%rax),%eax, 表示将0x3指向的空间的地址，也就是0x3赋值给rax寄存器，将0x3放入int* b指向的空间。</p><p>返回值是堆上空间的地址。</p><p><img src="/2021/11/07/%E5%BC%95%E7%94%A8/image-20211107170333419.png" alt="image-20211107170333419"></p><p>返回main函数，%rax存放了堆上空间的地址，-0x4(%rip)存放了变量c，将堆上空间的值放入-0x4(%rip)。</p><p><strong>问题：</strong>返回main后，没有变量可以指代堆上空间的地址，也就无法释放掉堆上空间</p><p>如果再返回main前，释放掉b指向的空间，我们来看看汇编：</p><p><img src="/2021/11/07/%E5%BC%95%E7%94%A8/image-20211107173119809.png" alt="image-20211107173119809"></p><p>在f()中调用free(b)，再return *b;</p><p><img src="/2021/11/07/%E5%BC%95%E7%94%A8/image-20211107173330061.png" alt="image-20211107173330061"></p><p>堆上空间的值，已经被free(b)清零了。<img src="/2021/11/07/%E5%BC%95%E7%94%A8/image-20211107173438290.png" alt="image-20211107173438290"></p><p>最后把值0返回给了c，这不是我们想要的结果！</p><p><strong>结论：将堆上空间的值作为引用类型返回给int变量，实际上是先返回堆上空间的地址，再将堆上空间的值赋值给rax寄存器，rax寄存器再赋值给变量。</strong></p><p><strong>但是由于不再有变量指代堆上空间，程序将不能释放这个堆上空间，导致这部分堆上空间在程序的剩余执行时间内，不再可用，浪费掉了！这叫做内存泄漏。</strong></p><p><strong>而在返回前释放堆上空间，会导致堆上空间清零，虽然返回了堆上空间地址，但赋值给rax寄存器的值是错误的！</strong></p><hr><h4 id="将int-amp-类型的返回值赋值给int-amp-类型的变量"><a href="#将int-amp-类型的返回值赋值给int-amp-类型的变量" class="headerlink" title="将int&amp;类型的返回值赋值给int&amp;类型的变量"></a>将int&amp;类型的返回值赋值给int&amp;类型的变量</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">f</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>* b =(<span class="keyword">int</span>*) <span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br><span class="line">        *b = a+<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> *b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>&amp; c = <span class="built_in">f</span>(a);</span><br><span class="line">        c = <span class="number">3</span>;</span><br><span class="line">        <span class="built_in">free</span>(&amp;c);</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/11/07/%E5%BC%95%E7%94%A8/image-20211107175503044.png" alt="image-20211107175503044"></p><p>从f()返回main后，-0x8(%rbp)存放c变量的值，将堆上空间的值放入了c变量中</p><p><img src="/2021/11/07/%E5%BC%95%E7%94%A8/image-20211107180018364.png" alt="image-20211107180018364"></p><p>c作为堆上空间值的引用，存放了堆上空间的地址，赋值给c时，将值存放到了堆上空间，free(&amp;c)也的确释放了堆上空间。</p><p><strong>结论：将堆上空间的值作为引用类型返回给int&amp;变量，从汇编的角度看c存放了*b的地址，从C++的角度看，c和*b一样，是有着堆上空间地址的int变量。可以通过free(&amp;c)释放掉堆上空间。</strong></p><hr><h3 id="return-堆上空间的地址"><a href="#return-堆上空间的地址" class="headerlink" title="return 堆上空间的地址"></a>return 堆上空间的地址</h3><p><img src="/2021/11/07/%E5%BC%95%E7%94%A8/image-20211107180713880.png" alt="image-20211107180713880"></p><p>报错，编译不通过。看来使用int&amp;作为返回类型，必须return int类型的变量</p><hr><h2 id="返回全局变量"><a href="#返回全局变量" class="headerlink" title="返回全局变量"></a>返回全局变量</h2><h3 id="将int-amp-类型的返回值赋值给int类型的变量-1"><a href="#将int-amp-类型的返回值赋值给int类型的变量-1" class="headerlink" title="将int&amp;类型的返回值赋值给int类型的变量"></a>将int&amp;类型的返回值赋值给int类型的变量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        i = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="built_in">f</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/11/07/%E5%BC%95%E7%94%A8/image-20211107194634919.png" alt="image-20211107194634919"></p><p>在f()中，全局变量int i的地址放入了rax寄存器中</p><p><img src="/2021/11/07/%E5%BC%95%E7%94%A8/image-20211107194833278.png" alt="image-20211107194833278"></p><p>将rax存放的地址指向的值，赋值给int类型的接收变量</p><hr><h3 id="将int-amp-类型的返回值赋值给int-amp-类型的变量-1"><a href="#将int-amp-类型的返回值赋值给int-amp-类型的变量-1" class="headerlink" title="将int&amp;类型的返回值赋值给int&amp;类型的变量"></a>将int&amp;类型的返回值赋值给int&amp;类型的变量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        i = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>&amp; a = <span class="built_in">f</span>();</span><br><span class="line">        a = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/11/07/%E5%BC%95%E7%94%A8/image-20211107195403884.png" alt="image-20211107195403884"></p><p>在f()中，同样将全局变量int i的地址放入了rax寄存器中</p><p><img src="/2021/11/07/%E5%BC%95%E7%94%A8/image-20211107195518061.png" alt="image-20211107195518061"></p><p>int&amp;类型的接收变量a，存放了rax寄存器中的地址，在a=3的执行中，表现的像int类型变量一样，将3赋值给了地址指向的空间，我们知道这个地址就是全局变量i的地址，所以它也改变了i。</p><hr><h1 id="类的引用类型"><a href="#类的引用类型" class="headerlink" title="类的引用类型"></a>类的引用类型</h1><h2 id="main函数中，创建类A的实例"><a href="#main函数中，创建类A的实例" class="headerlink" title="main函数中，创建类A的实例"></a>main函数中，创建类A的实例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">A</span>(<span class="keyword">int</span> b)&#123;a = b;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="function">A <span class="title">a1</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/11/07/%E5%BC%95%E7%94%A8/image-20211107204851274.png" alt="image-20211107204851274"></p><p>进入main后，再进入A的构造函数A()，在A中初始化类A的成员变量，A a1创建的对象，成员变量在栈上。A a1 = new A创建的对象，成员变量在堆上。所有函数都存放在内存的代码区中。</p><h2 id="main函数中，类A的对象赋值给类A的对象"><a href="#main函数中，类A的对象赋值给类A的对象" class="headerlink" title="main函数中，类A的对象赋值给类A的对象"></a>main函数中，类A的对象赋值给类A的对象</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">A</span>(<span class="keyword">int</span> b)&#123;a=b;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="function">A <span class="title">a1</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">        <span class="function">A <span class="title">a2</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">        a1 = a2;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/11/07/%E5%BC%95%E7%94%A8/image-20211107214336672.png" alt="image-20211107214336672"></p><p>对象a1的成员变量存放在0x7fffffffdf80，即-0x10(%rbp)处，对象a2的成员变量存放在0x7fffffffdf84，即-0xc(%rbp)处，对象的赋值，就是把a2的成员变量赋值给a1的成员变量。</p><p>A类有两个成员变量也是一样的操作：只不过这次移动了64位</p><p><img src="/2021/11/07/%E5%BC%95%E7%94%A8/image-20211107215714204.png" alt="image-20211107215714204"></p><p>A类有3个成员变量也是一样的操作：只不过分64位，32位各移动了一次</p><p><img src="/2021/11/07/%E5%BC%95%E7%94%A8/image-20211107220125398.png" alt="image-20211107220125398"></p><h2 id="main函数中，A赋值给A-amp"><a href="#main函数中，A赋值给A-amp" class="headerlink" title="main函数中，A赋值给A&amp;"></a>main函数中，A赋值给A&amp;</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">A</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;</span><br><span class="line">                _a = a;</span><br><span class="line">                _b = b;</span><br><span class="line">        &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> _a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> _b = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="function">A <span class="title">a1</span><span class="params">(<span class="number">2</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">        A&amp; a2 = a1;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/11/07/%E5%BC%95%E7%94%A8/image-20211107220546454.png" alt="image-20211107220546454"></p><p>-0x10(%rbp)存放对象a1，-0x18(%rbp)存放对象a2，把对象a1的地址，赋值给了对象a2。 </p><h2 id="成员函数中，形参为引用类型"><a href="#成员函数中，形参为引用类型" class="headerlink" title="成员函数中，形参为引用类型"></a>成员函数中，形参为引用类型</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">A</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;</span><br><span class="line">                _a = a;</span><br><span class="line">                _b = b;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">A</span>(A&amp; a)&#123;</span><br><span class="line">                _a = a._a;</span><br><span class="line">                _b = a._b;</span><br><span class="line">        &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> _a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> _b = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="function">A <span class="title">a</span><span class="params">(<span class="number">2</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">        <span class="function">A <span class="title">b</span><span class="params">(a)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/11/07/%E5%BC%95%E7%94%A8/image-20211107221844365.png" alt="image-20211107221844365"></p><p>main函数中，进入A()构造对象a，将对象a的地址存放到寄存器rdi中，进入成员函数A(A&amp;)</p><p><img src="/2021/11/07/%E5%BC%95%E7%94%A8/image-20211107222503560.png" alt="image-20211107222503560"></p><p>借助传入的对象a的地址，将对象a的值赋值给对象b。</p><h2 id="成员函数中，返回类型为类类型"><a href="#成员函数中，返回类型为类类型" class="headerlink" title="成员函数中，返回类型为类类型"></a>成员函数中，返回类型为类类型</h2><h3 id="main函数先构造对象b再接受返回变量，f-返回构造好的对象；"><a href="#main函数先构造对象b再接受返回变量，f-返回构造好的对象；" class="headerlink" title="main函数先构造对象b再接受返回变量，f()返回构造好的对象；"></a>main函数先构造对象b再接受返回变量，f()返回构造好的对象；</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类A有2个整型成员变量</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">A</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span><br><span class="line">        &#123;</span><br><span class="line">                _a = a;</span><br><span class="line">                _b = b;</span><br><span class="line">        &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> _a;</span><br><span class="line">        <span class="keyword">int</span> _b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="function">A <span class="title">a</span><span class="params">(<span class="number">2</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="function">A <span class="title">b</span><span class="params">(<span class="number">1</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line">        b = <span class="built_in">f</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入main()，进入A()构造对象b，进入f()，进入A()构造对象a，返回f()，将对象a的两个成员变量值放入rax寄存器中，返回main()，将rax寄存器中的值赋值给对象b。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类A有3个int型成员变量</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">A</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span><br><span class="line">        &#123;</span><br><span class="line">                _a = a;</span><br><span class="line">                _b = b;</span><br><span class="line">                _c = c;</span><br><span class="line">        &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> _a;</span><br><span class="line">        <span class="keyword">int</span> _b;</span><br><span class="line">        <span class="keyword">int</span> _c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="function">A <span class="title">a</span><span class="params">(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="function">A <span class="title">b</span><span class="params">(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line">        b = <span class="built_in">f</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入main()，进入A()构造对象b，进入f()，进入A()构造对象a，返回f()，**将对象a的三个成员变量值拷贝一份(属实迷惑到我了，5 个整型变量又不拷贝一份了)**，将拷贝后的值放入rax(64位)和rcx(32位)寄存器中，返回main()，将rax和rcx寄存器中的值赋值给对象b。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类A有一个数量为5的int型数组</span></span><br><span class="line"><span class="keyword">int</span> aarray[<span class="number">5</span>] = &#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> barray[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">A</span>(<span class="keyword">int</span>* a)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=<span class="number">4</span>; i++)</span><br><span class="line">                        _a[i] = a[i];</span><br><span class="line">        &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> _a[<span class="number">5</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="function">A <span class="title">a</span><span class="params">(aarray)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function">A <span class="title">b</span><span class="params">(barray)</span></span>;</span><br><span class="line">        b = <span class="built_in">f</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/11/07/%E5%BC%95%E7%94%A8/image-20211107233517399.png" alt="image-20211107233517399"></p><p>进入main()，进入A()构造对象b，进入f()，进入A()构造对象a，返回f()，将对象a的地址赋值给rax寄存器，返回main()，借助rax，rbx寄存器将对象a的数组值拷贝给对象b的数组。</p><p><strong>将类A改成有5个整型成员变量，也是一样的操作，借助rax，rbx寄存器将对象a的值，拷贝给对象b的数组</strong></p><h3 id="f-直接返回构造函数"><a href="#f-直接返回构造函数" class="headerlink" title="f()直接返回构造函数"></a>f()直接返回构造函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">A</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span><br><span class="line">        &#123;</span><br><span class="line">                _a = a;</span><br><span class="line">                _b = b;</span><br><span class="line">        &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> _a;</span><br><span class="line">        <span class="keyword">int</span> _b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">A</span>(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="function">A <span class="title">b</span><span class="params">(<span class="number">1</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line">        b = <span class="built_in">f</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入main()，进入A()构造对象b，进入f()，进入A()构造对象a，返回f()，将对象a的两个成员变量值放入rax寄存器中，返回main()，将rax寄存器中的值赋值给对象b。<strong>与1无区别</strong></p><h3 id="main函数直接用f-的返回变量构造对象b"><a href="#main函数直接用f-的返回变量构造对象b" class="headerlink" title="main函数直接用f()的返回变量构造对象b"></a>main函数直接用f()的返回变量构造对象b</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">A</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span><br><span class="line">        &#123;</span><br><span class="line">                _a = a;</span><br><span class="line">                _b = b;</span><br><span class="line">        &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> _a;</span><br><span class="line">        <span class="keyword">int</span> _b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="function">A <span class="title">a</span><span class="params">(<span class="number">2</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        A b = <span class="built_in">f</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入main()，进入f()，进入A()构造对象，返回f()，将对象的两个成员变量值放入rax寄存器中，返回main()，将rax寄存器中的值赋值给对象b。<strong>相比1，少调用一次构造函数构造b</strong></p><h3 id="main函数直接用f-的返回变量构造对象b，f-直接返回构造函数"><a href="#main函数直接用f-的返回变量构造对象b，f-直接返回构造函数" class="headerlink" title="main函数直接用f()的返回变量构造对象b，f()直接返回构造函数"></a>main函数直接用f()的返回变量构造对象b，f()直接返回构造函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">A</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span><br><span class="line">        &#123;</span><br><span class="line">                _a = a;</span><br><span class="line">                _b = b;</span><br><span class="line">        &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> _a;</span><br><span class="line">        <span class="keyword">int</span> _b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">A</span>(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        A b = <span class="built_in">f</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>同3，相比1，少调用一次构造函数构造b</strong></p><h2 id="成员函数中，返回类型为引用类型"><a href="#成员函数中，返回类型为引用类型" class="headerlink" title="成员函数中，返回类型为引用类型"></a>成员函数中，返回类型为引用类型</h2><h3 id="return-局部变量-1"><a href="#return-局部变量-1" class="headerlink" title="return 局部变量"></a>return 局部变量</h3><p><img src="/2021/11/07/%E5%BC%95%E7%94%A8/image-20211108002331594.png" alt="image-20211108002331594"></p><p>同样不能返回局部对象，通不过编译</p><h3 id="return-堆上对象"><a href="#return-堆上对象" class="headerlink" title="return 堆上对象"></a>return 堆上对象</h3><h4 id="接收变量为类型A"><a href="#接收变量为类型A" class="headerlink" title="接收变量为类型A"></a>接收变量为类型A</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">A</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span><br><span class="line">        &#123;</span><br><span class="line">                _a = a;</span><br><span class="line">                _b = b;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> _a;</span><br><span class="line">        <span class="keyword">int</span> _b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A&amp; <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *(<span class="keyword">new</span> <span class="built_in">A</span>(<span class="number">1</span>,<span class="number">1</span>));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        A b = <span class="built_in">f</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/11/07/%E5%BC%95%E7%94%A8/image-20211108003228999-16363027511231.png" alt="image-20211108003228999"></p><p>进入f()，new一个8字节(类A实例的大小)的空间，进入A()构造对象，将对象的地址放到rax寄存器中，返回f()，返回main()</p><p><img src="/2021/11/07/%E5%BC%95%E7%94%A8/image-20211108003633970.png" alt="image-20211108003633970"></p><p>借助构造对象的地址，将对象的值，存放到对象b中，<strong>然后丢失new的地址</strong>。</p><h4 id="接受变量为类型A-amp"><a href="#接受变量为类型A-amp" class="headerlink" title="接受变量为类型A&amp;"></a>接受变量为类型A&amp;</h4><p><img src="/2021/11/07/%E5%BC%95%E7%94%A8/image-20211108003907226.png" alt="image-20211108003907226"></p><p>将对象的地址，存放到对象b中。</p><h3 id="return-全局对象"><a href="#return-全局对象" class="headerlink" title="return 全局对象"></a>return 全局对象</h3><p>崩看了，所有分析都与普通变量无二。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HandleImage</title>
      <link href="/2021/11/06/HandleImage/"/>
      <url>/2021/11/06/HandleImage/</url>
      
        <content type="html"><![CDATA[<h1 id="这篇博文讲解了本地图片的路径设置"><a href="#这篇博文讲解了本地图片的路径设置" class="headerlink" title="这篇博文讲解了本地图片的路径设置"></a>这篇博文讲解了本地图片的路径设置</h1><p><a href="https://blog.csdn.net/m0_43401436/article/details/107191688">(32条消息) hexo博客中插入图片失败——解决思路及个人最终解决办法_m0_43401436的博客-CSDN博客</a></p><p>本地source文件夹里的md文件和图片整好后，hexo执行编译工作，在public文件夹中生成网页及图片</p><h1 id="下载插件并修改代码确实解决了问题"><a href="#下载插件并修改代码确实解决了问题" class="headerlink" title="下载插件并修改代码确实解决了问题"></a>下载插件并修改代码确实解决了问题</h1><p>安装的插件是hexo-asset-image, 将/node_modules/hexo-asset-image/index.js的代码修改为:</p><p>具体过程可以参考这篇博文<a href="https://www.cnblogs.com/cscshi/p/15196100.html">Hexo-NexT 添加图片 - chang101 - 博客园 (cnblogs.com)</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> cheerio = <span class="built_in">require</span>(<span class="string">&#x27;cheerio&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPosition</span>(<span class="params">str, m, i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.split(m, i).join(m).length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> version = <span class="built_in">String</span>(hexo.version).split(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">hexo.extend.filter.register(<span class="string">&#x27;after_post_render&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> config = hexo.config;</span><br><span class="line">  <span class="keyword">if</span>(config.post_asset_folder)&#123;</span><br><span class="line">        <span class="keyword">var</span> link = data.permalink;</span><br><span class="line">    <span class="keyword">if</span>(version.length &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">Number</span>(version[<span class="number">0</span>]) == <span class="number">3</span>)</span><br><span class="line">       <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">&#x27;/&#x27;</span>, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">       <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">&#x27;/&#x27;</span>, <span class="number">3</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.</span></span><br><span class="line">    <span class="keyword">var</span> endPos = link.lastIndexOf(<span class="string">&#x27;/&#x27;</span>) + <span class="number">1</span>;</span><br><span class="line">    link = link.substring(beginPos, endPos);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> toprocess = [<span class="string">&#x27;excerpt&#x27;</span>, <span class="string">&#x27;more&#x27;</span>, <span class="string">&#x27;content&#x27;</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; toprocess.length; i++)&#123;</span><br><span class="line">      <span class="keyword">var</span> key = toprocess[i];</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">var</span> $ = cheerio.load(data[key], &#123;</span><br><span class="line">        <span class="attr">ignoreWhitespace</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">xmlMode</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">lowerCaseTags</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">decodeEntities</span>: <span class="literal">false</span></span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      $(<span class="string">&#x27;img&#x27;</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ($(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>))&#123;</span><br><span class="line">            <span class="comment">// For windows style path, we replace &#x27;\&#x27; to &#x27;/&#x27;.</span></span><br><span class="line">            <span class="keyword">var</span> src = $(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>).replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span>(!<span class="regexp">/http[s]*.*|\/\/.*/</span>.test(src) &amp;&amp;</span><br><span class="line">               !<span class="regexp">/^\s*\//</span>.test(src)) &#123;</span><br><span class="line">              <span class="comment">// For &quot;about&quot; page, the first part of &quot;src&quot; can&#x27;t be removed.</span></span><br><span class="line">              <span class="comment">// In addition, to support multi-level local directory.</span></span><br><span class="line">              <span class="keyword">var</span> linkArray = link.split(<span class="string">&#x27;/&#x27;</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">              &#125;);</span><br><span class="line">              <span class="keyword">var</span> srcArray = src.split(<span class="string">&#x27;/&#x27;</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span> &amp;&amp; elem != <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">              &#125;);</span><br><span class="line">              <span class="keyword">if</span>(srcArray.length &gt; <span class="number">1</span>)</span><br><span class="line">                srcArray.shift();</span><br><span class="line">              src = srcArray.join(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">              $(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>, config.root + link + src);</span><br><span class="line">              <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">&quot;update link as:--&gt;&quot;</span>+config.root + link + src);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">&quot;no src attr, skipped...&quot;</span>);</span><br><span class="line">            <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info($(<span class="built_in">this</span>));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      data[key] = $.html();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="持久化文章url后，出现了新的问题"><a href="#持久化文章url后，出现了新的问题" class="headerlink" title="持久化文章url后，出现了新的问题"></a>持久化文章url后，出现了新的问题</h1><p>&emsp;&emsp;本博客参考了系列视频<a href="https://space.bilibili.com/13282871/video">卷二兔的个人空间_哔哩哔哩_bilibili</a>制作，作者使用了持久化文章url的技术。        </p><p>&emsp;&emsp;持久化文章url-uniform resource locator-同一资源定位符，是为了文章更好地被搜索引擎收录(需要不少配置)，生成简单且不随标题而改变的url。</p><p>&emsp;&emsp;<strong>但是！使用abbrlink持久化文章链接名称后，图片路径在本地没问题，部署到github后，其html网页中的图片路径会出新问题。</strong></p><p>&emsp;&emsp;试图看index.js在干嘛，无果，于是怕麻烦的我取消了持久化，回到了美好的从前。</p><h1 id="可以使用图床"><a href="#可以使用图床" class="headerlink" title="可以使用图床"></a>可以使用图床</h1><p>&emsp;&emsp;本博客参考了系列视频<a href="https://space.bilibili.com/13282871/video">卷二兔的个人空间_哔哩哔哩_bilibili</a>制作，其中提到了图床技术，将所有图片上传到github上的图床仓库，这样本地md文件和生成的网页中，图片的地址就都是网上图片了，从而不用考虑文件结构的变化。理论上，使用图床，就可以解决持久化url的问题。</p><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>访问github并不容易</span></div>    <div class="hide-content"><p>&emsp;&emsp;可是访问github并不容易，需要处理域名污染(查真实ip地址来改hosts，防止dns-domain name server-域名服务器返回错误的ip地址)，需要vpn(加密请求的ip地址，使其符合路由节点的入站规则，拿到东西了再在本机上解密)。</p><p>&emsp;&emsp;然而网页和图片都在github的服务器上，所以要么都能访问到，要么都访问不到，所以真要搞一个基于github的博客，这样搞还是挺好的。</p><p>&emsp;&emsp;但是我只是想有一个记录自己所思所想的博客，觉得本地搞好方便，省去了搞ip的麻烦，果然还是回退到二吧。</p></div></div><p>&emsp;&emsp;其实根本原因还是不知道hexo是怎么把source中的md文件和图片生成为pulic中的网页和图片的，要是我知道用什么语法改哪个配置文件，就能自己设置两者的对应关系了。</p>]]></content>
      
      
      <categories>
          
          <category> blog in hexo+github </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>通用测量单位</title>
      <link href="/2021/11/03/%E9%80%9A%E7%94%A8%E6%B5%8B%E9%87%8F%E5%8D%95%E4%BD%8D/"/>
      <url>/2021/11/03/%E9%80%9A%E7%94%A8%E6%B5%8B%E9%87%8F%E5%8D%95%E4%BD%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h1><p>一秒到底是多久？一米到底是多长？一克到底是多重？……？</p><p>没有统一的标准，就无法观测和记录世间的一切客观属性。</p><p>那么，我们习以为常的观测单位是怎么产生的呢？</p><h1 id="国际单位制"><a href="#国际单位制" class="headerlink" title="国际单位制"></a>国际单位制</h1><p>&emsp;&emsp;国际单位制（法语：Système International d’Unités ，缩写：SI）源自米制，是国际计量大会采纳和推荐的单位标准。国际单位制是国际通用的测量标准，是人类描述和定义世间万物的标尺。</p><table><thead><tr><th align="center">物的属性</th><th align="center">基本单位</th></tr></thead><tbody><tr><td align="center">时间</td><td align="center">秒(second)</td></tr><tr><td align="center">长度</td><td align="center">米</td></tr><tr><td align="center">质量</td><td align="center">千克</td></tr><tr><td align="center">电流</td><td align="center">安培</td></tr><tr><td align="center">温度</td><td align="center">开尔文</td></tr><tr><td align="center">物质的量</td><td align="center">摩尔</td></tr><tr><td align="center">发光强度</td><td align="center">坎德拉</td></tr></tbody></table><h2 id="时间：一秒到底是多久？"><a href="#时间：一秒到底是多久？" class="headerlink" title="时间：一秒到底是多久？"></a>时间：一秒到底是多久？</h2><p>&emsp;&emsp;时间是其中最抽象的概念，不像长短，重量给人的直观感受，人是通过周围事物的改变，通过太阳升起又落下，树木枯萎又抽芽，温度冷转冷又转热，朱颜辞镜花辞树，才感觉到，事物在一刻不停地改变着，有一种不可阻挡，永不回头，完全不可控的力量，推动着万物的改变。人称此力为时，时如川，裹挟着落花，不停地向前流动。</p><p>&emsp;&emsp;人觉得有必要记录重要的事物特征，顺应天时以求更好地过活，于是根据事物重要特征的出现，定义了重要的时间点：如日出之时，日落之时。根据时间点的间隔又定义了原始的时间单位：如一日。从而又产生了新的时间点和时间单位：如月缺之日，月圆之日，一月，温暖之月，寒冷之月，一季等。</p><p>&emsp;&emsp;一开始，人定义了重要的时点，产生了时间单位的概念（日，月，年等），接着，人试图用规律变化的工具来人造更小的时段。</p><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>古老的计时工具</span></div>    <div class="hide-content"><p>运用自然物质和简单物理原理来计时</p><p><img src="/2021/11/03/%E9%80%9A%E7%94%A8%E6%B5%8B%E9%87%8F%E5%8D%95%E4%BD%8D/fed0faca79b740aa9676d782d24f0cc8.jpeg" alt="img"></p><p>水钟也叫漏刻，以水的流动计时</p><p><img src="/2021/11/03/%E9%80%9A%E7%94%A8%E6%B5%8B%E9%87%8F%E5%8D%95%E4%BD%8D/9cffe790183c4eaab13c1e71e915a5bd.gif" alt="img"></p><p>沙漏计时器，以沙的流动计时</p><p><img src="/2021/11/03/%E9%80%9A%E7%94%A8%E6%B5%8B%E9%87%8F%E5%8D%95%E4%BD%8D/866571d17fae47ceb1c8f054dc33f729.jpg" alt="img"></p><p>古代计时器——日晷，立杆成影的成语即来源于此，借助太阳的位置变化，光的直线传播计时</p><p><img src="/2021/11/03/%E9%80%9A%E7%94%A8%E6%B5%8B%E9%87%8F%E5%8D%95%E4%BD%8D/56d058943da347efa022bbc40df141bc.jpeg" alt="img"></p><p>1090年，北宋发明</p><p>水运仪象台（现代复建），是世界上的钟表鼻祖，具有天文观测，天文演示，自动报时功能。</p></div></div><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>伽利略发现了摆的等时性</span></div>    <div class="hide-content"><p>&emsp;&emsp;据说,有一次伽利略到教堂作礼拜,礼拜开始不久,一位工人给教堂中的大吊灯添加灯油时,不经意触动了吊灯,使它来回摆动。摆动着的大吊灯映入了伽利略的眼帘,引起他的注意。伽利略聚精会神地观察着,他感觉到吊灯来回摆动的时间好像是相等的。</p><p>&emsp;&emsp;伽利略知道人的脉搏是均匀跳动的,于是,他利用自己的脉搏计时,同时数着吊灯的摆动次数。起初,吊灯在摆动的幅度比较大,摆动速度也比较大,伽利略测算了来回摆动一次的时间。过了一会儿,吊灯摆动的幅度变小了,摆动速度也变慢了,此时,他又测量了吊灯来回摆动一次的时间。让他大为吃惊的是,两次测量的时间是相同的。于是伽利略继续测量来回摆动一次的时间,直到吊灯几乎停止摆动时才结束。可是每次测量的结果都表明来回摆动一次需要相同的时间。通过这些测量使伽利略发现:吊灯来回摆动一次需要的时间 与摆动幅度的大小无关,无论摆幅大小如何,来回摆动一次所需时间是相同的,也就是说吊灯的摆动具有等时性,或者说具有周期性。</p><p>&emsp;&emsp; 伽利略是一位十分认真又喜欢研究问题的人,根本不会满足只从一次实验中得到的结果。对于自然现象,他总是反复进行实验研究,探索其中蕴藏的奥秘。他想,吊灯摆动的快慢(也称为摆动的周期)可能跟哪些因素有关呢? 通过在教堂中的观察,伽利略已经知道,摆动的周期跟摆动幅度无关。他猜想,是否跟吊灯的轻重有关呢?是否跟吊绳的长短有关呢?还有没有其他因素呢? 为了模拟吊灯的摆动,他找来丝线、细绳、大小不同的木球、铁球、石块、铜球等实验材料,用细绳的一端系上小球,将另一端系在天花板上,这样就做成了一个摆。用这套装置,伽利略继续测量探索摆动的周期。他先用铜球实验,又分别换用铁球和木球实验。实验使伽利略看到,无论用铜球、铁球,还是木球实验,只要摆长不变,来回摆动一次所用时间就相同。这表明单摆的摆动周期与摆球的质量无关。伽利略又做了十几个摆长不同的摆,逐个测量它们的周期。实验表明:摆长越长,周期也越长,摆动得就越慢。</p></div></div><p>再后来出现了晶振，机械表升级成为电子表，对时间间隔的定义也精确到了微秒级。</p><p>后来通过研究电子跃迁，发明了原子钟。精度可以达到几十万年一秒的误差。</p><p>再后来研究相对论，这些就脱离了日常生活，接触不到了，故不谈。</p><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>长度：一米到底是多长？</span></div>    <div class="hide-content"></div></div><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>质量：一千克到底是多重？</span></div>    <div class="hide-content"></div></div><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>电流：？</span></div>    <div class="hide-content"></div></div><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>温度：？</span></div>    <div class="hide-content"></div></div><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>物质的量？</span></div>    <div class="hide-content"></div></div><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>发光强度？</span></div>    <div class="hide-content"></div></div>]]></content>
      
      
      <categories>
          
          <category> 基石 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
